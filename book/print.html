<!DOCTYPE HTML>
<html lang="eo" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Neoficiala Bevy Tromplibro</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <script async defer src="https://buttons.github.io/buttons.js"></script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="nagbar.css">
        <link rel="stylesheet" href="sidebar.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Enkonduko</a></li><li class="chapter-item expanded affix "><a href="overview.html">Superrigardo de Ĉapitroj</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="tutorial.html">Ĉu komencanto en Bevy? Tute Gvidita Instrukcio!</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="builtins.html">Listo de Bevy Enkonstruitaĵoj</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.</strong> Konsiloj pri Bevy Instalado</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/getting-started.html"><strong aria-hidden="true">1.1.</strong> Komencante</a></li><li class="chapter-item expanded "><a href="setup/bevy-git.html"><strong aria-hidden="true">1.2.</strong> Uzado de bleeding-edge Bevy (ĉefa)</a></li><li class="chapter-item expanded "><a href="setup/editor.html"><strong aria-hidden="true">1.3.</strong> Tekstredaktilo / Integra Ellaborad-Medio</a></li><li class="chapter-item expanded "><a href="setup/bevy-tools.html"><strong aria-hidden="true">1.4.</strong> Ellaboriloj kaj Redaktiloj por Bevy</a></li><li class="chapter-item expanded "><a href="setup/unofficial-plugins.html"><strong aria-hidden="true">1.5.</strong> Ekosistemo de Komunumaj Kromaĵoj</a></li><li class="chapter-item expanded "><a href="setup/bevy-config.html"><strong aria-hidden="true">1.6.</strong> Agordado de Bevy (trajtoj, modulareco)</a></li></ol></li><li class="chapter-item expanded "><a href="pitfalls.html"><strong aria-hidden="true">2.</strong> Ĝeneralaj Kaptiloj</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pitfalls/build-errors.html"><strong aria-hidden="true">2.1.</strong> Strangaj kompilad-eraroj el Bevy aŭ dependaĵoj</a></li><li class="chapter-item expanded "><a href="pitfalls/performance.html"><strong aria-hidden="true">2.2.</strong> Malrapida Plenumeco</a></li><li class="chapter-item expanded "><a href="pitfalls/into-system.html"><strong aria-hidden="true">2.3.</strong> Eraro aldonante funkcion kiel sistemo</a></li><li class="chapter-item expanded "><a href="pitfalls/ui-camera.html"><strong aria-hidden="true">2.4.</strong> UI ne bildiĝas</a></li><li class="chapter-item expanded "><a href="pitfalls/2d-camera-z.html"><strong aria-hidden="true">2.5.</strong> 2D-objektoj ne bildiĝas</a></li><li class="chapter-item expanded "><a href="pitfalls/3d-not-rendering.html"><strong aria-hidden="true">2.6.</strong> 3D-objektoj ne bildiĝas</a></li><li class="chapter-item expanded "><a href="pitfalls/split-borrows.html"><strong aria-hidden="true">2.7.</strong> Pruntepreni plurajn kampojn de struct</a></li><li class="chapter-item expanded "><a href="pitfalls/time.html"><strong aria-hidden="true">2.8.</strong> Interrompema moviĝo/animacio</a></li><li class="chapter-item expanded "><a href="pitfalls/ui-y-up.html"><strong aria-hidden="true">2.9.</strong> UI aranĝo estas inversigita</a></li><li class="chapter-item expanded "><a href="pitfalls/uv-coordinates.html"><strong aria-hidden="true">2.10.</strong> Teksturoj/Bildoj estas renversitaj</a></li></ol></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">3.</strong> Kerno de Bevy Ludmotoro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="features/coords.html"><strong aria-hidden="true">3.1.</strong> Koordinata Sistemo</a></li><li class="chapter-item expanded "><a href="features/transforms.html"><strong aria-hidden="true">3.2.</strong> Transformoj</a></li><li class="chapter-item expanded "><a href="features/time.html"><strong aria-hidden="true">3.3.</strong> Tempo kaj Tempigiloj</a></li><li class="chapter-item expanded "><a href="features/parent-child.html"><strong aria-hidden="true">3.4.</strong> Parento-Ido Hierarĥioj</a></li><li class="chapter-item expanded "><a href="features/fixed-timestep.html"><strong aria-hidden="true">3.5.</strong> Difinita Tempopaŝo</a></li><li class="chapter-item expanded "><a href="features/audio.html"><strong aria-hidden="true">3.6.</strong> Aŭdio</a></li></ol></li><li class="chapter-item expanded "><a href="assets.html"><strong aria-hidden="true">4.</strong> Administrado de Valoraĵoj</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="assets/handles.html"><strong aria-hidden="true">4.1.</strong> Priskribiloj (Handles)</a></li><li class="chapter-item expanded "><a href="assets/assetserver.html"><strong aria-hidden="true">4.2.</strong> Elŝuti Valoraĵojn el Dosieroj</a></li><li class="chapter-item expanded "><a href="assets/data.html"><strong aria-hidden="true">4.3.</strong> Atingo al la Valoraĵ-datumo</a></li><li class="chapter-item expanded "><a href="assets/assetevent.html"><strong aria-hidden="true">4.4.</strong> Reagi al Ŝanĝoj kun Valoraĵ-eventoj</a></li><li class="chapter-item expanded "><a href="assets/ready.html"><strong aria-hidden="true">4.5.</strong> Observi Elŝut-progreson</a></li><li class="chapter-item expanded "><a href="assets/hot-reload.html"><strong aria-hidden="true">4.6.</strong> Tuj-Reŝargo de Valoraĵoj</a></li></ol></li><li class="chapter-item expanded "><a href="input.html"><strong aria-hidden="true">5.</strong> Eniga Priskribilo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input/keyboard.html"><strong aria-hidden="true">5.1.</strong> Klavaro</a></li><li class="chapter-item expanded "><a href="input/mouse.html"><strong aria-hidden="true">5.2.</strong> Muso</a></li><li class="chapter-item expanded "><a href="input/char.html"><strong aria-hidden="true">5.3.</strong> Teksto / Simbolo</a></li><li class="chapter-item expanded "><a href="input/gamepad.html"><strong aria-hidden="true">5.4.</strong> Ludstirilo (Kontrolilo, Stirstango)</a></li><li class="chapter-item expanded "><a href="input/touch.html"><strong aria-hidden="true">5.5.</strong> Tuŝekrano</a></li><li class="chapter-item expanded "><a href="input/dnd.html"><strong aria-hidden="true">5.6.</strong> Treni-k-faligi (Dosierojn)</a></li><li class="chapter-item expanded "><a href="input/midi.html"><strong aria-hidden="true">5.7.</strong> MIDI (Muzikilo)</a></li></ol></li><li class="chapter-item expanded "><a href="window.html"><strong aria-hidden="true">6.</strong> Administrado de Fenestroj</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="window/props.html"><strong aria-hidden="true">6.1.</strong> [Nefinita] Fenestraj Ecoj</a></li><li class="chapter-item expanded "><a href="window/clear-color.html"><strong aria-hidden="true">6.2.</strong> Ŝanĝo la Fonkoloron</a></li><li class="chapter-item expanded "><a href="window/mouse-grab.html"><strong aria-hidden="true">6.3.</strong> Kapti la Muskursoron</a></li><li class="chapter-item expanded "><a href="window/icon.html"><strong aria-hidden="true">6.4.</strong> Difini la Fenestran Ikoneton</a></li></ol></li><li class="chapter-item expanded "><a href="2d.html"><strong aria-hidden="true">7.</strong> Bevy 2D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2d/camera.html"><strong aria-hidden="true">7.1.</strong> [Nefinita] 2D Kamerao-instalado</a></li><li class="chapter-item expanded "><a href="2d/sprites.html"><strong aria-hidden="true">7.2.</strong> [Nefinita] Sprajtoj kaj Atlasoj</a></li></ol></li><li class="chapter-item expanded "><a href="3d.html"><strong aria-hidden="true">8.</strong> Bevy 3D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3d/camera.html"><strong aria-hidden="true">8.1.</strong> [Nefinita] 3D Kamerao-instalado</a></li><li class="chapter-item expanded "><a href="3d/gltf.html"><strong aria-hidden="true">8.2.</strong> 3D Modeloj kaj Scenejoj (GLTF)</a></li></ol></li><li class="chapter-item expanded "><a href="programming.html"><strong aria-hidden="true">9.</strong> Bevy Programada Enkadraĵo (Framework)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/ecs-intro.html"><strong aria-hidden="true">9.1.</strong> Enkonduko al EKS</a></li><li class="chapter-item expanded "><a href="programming/ec.html"><strong aria-hidden="true">9.2.</strong> Entoj kaj Komponantoj</a></li><li class="chapter-item expanded "><a href="programming/res.html"><strong aria-hidden="true">9.3.</strong> Risurcoj</a></li><li class="chapter-item expanded "><a href="programming/systems.html"><strong aria-hidden="true">9.4.</strong> Sistemoj</a></li><li class="chapter-item expanded "><a href="programming/queries.html"><strong aria-hidden="true">9.5.</strong> Informpetoj</a></li><li class="chapter-item expanded "><a href="programming/commands.html"><strong aria-hidden="true">9.6.</strong> Komandoj</a></li><li class="chapter-item expanded "><a href="programming/events.html"><strong aria-hidden="true">9.7.</strong> Eventoj</a></li><li class="chapter-item expanded "><a href="programming/app-builder.html"><strong aria-hidden="true">9.8.</strong> Aplikaĵa Konstruilo (fn main)</a></li><li class="chapter-item expanded "><a href="programming/quit.html"><strong aria-hidden="true">9.9.</strong> Ĉesi la Aplikaĵon</a></li><li class="chapter-item expanded "><a href="programming/local.html"><strong aria-hidden="true">9.10.</strong> Lokaj Risurcoj</a></li><li class="chapter-item expanded "><a href="programming/plugins.html"><strong aria-hidden="true">9.11.</strong> Kromaĵoj</a></li><li class="chapter-item expanded "><a href="programming/system-order.html"><strong aria-hidden="true">9.12.</strong> Sistema Ordo de Plenumado</a></li><li class="chapter-item expanded "><a href="programming/system-sets.html"><strong aria-hidden="true">9.13.</strong> Sistemaj Aroj</a></li><li class="chapter-item expanded "><a href="programming/change-detection.html"><strong aria-hidden="true">9.14.</strong> Detekto de Ŝanĝo</a></li><li class="chapter-item expanded "><a href="programming/states.html"><strong aria-hidden="true">9.15.</strong> Statoj</a></li><li class="chapter-item expanded "><a href="programming/run-criteria.html"><strong aria-hidden="true">9.16.</strong> Lanĉaj Kriterioj</a></li><li class="chapter-item expanded "><a href="programming/labels.html"><strong aria-hidden="true">9.17.</strong> Titoloj</a></li><li class="chapter-item expanded "><a href="programming/stages.html"><strong aria-hidden="true">9.18.</strong> Etapoj</a></li><li class="chapter-item expanded "><a href="programming/removal-detection.html"><strong aria-hidden="true">9.19.</strong> Detekto de Forigo</a></li><li class="chapter-item expanded "><a href="programming/paramset.html"><strong aria-hidden="true">9.20.</strong> Parametraj Aroj</a></li><li class="chapter-item expanded "><a href="programming/system-chaining.html"><strong aria-hidden="true">9.21.</strong> Sistema Ligado</a></li><li class="chapter-item expanded "><a href="programming/world.html"><strong aria-hidden="true">9.22.</strong> Direkta Atingo al EKS-Mondo</a></li><li class="chapter-item expanded "><a href="programming/exclusive.html"><strong aria-hidden="true">9.23.</strong> Ekskluzivaj Sistemoj</a></li><li class="chapter-item expanded "><a href="programming/sub-apps.html"><strong aria-hidden="true">9.24.</strong> [Nefinita] Sub-Aplikaĵoj</a></li><li class="chapter-item expanded "><a href="programming/non-send.html"><strong aria-hidden="true">9.25.</strong> Nesendaj Risurcoj</a></li><li class="chapter-item expanded "><a href="programming/system-tests.html"><strong aria-hidden="true">9.26.</strong> Kreado de Testoj por Sistemoj</a></li></ol></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">10.</strong> Programadaj Ŝablonoj</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/generic-systems.html"><strong aria-hidden="true">10.1.</strong> Generaj Sistemoj</a></li><li class="chapter-item expanded "><a href="patterns/component-storage.html"><strong aria-hidden="true">10.2.</strong> Komponanta Stokaĵo (Tabelo/SparseSet)</a></li><li class="chapter-item expanded "><a href="patterns/manual-event-clear.html"><strong aria-hidden="true">10.3.</strong> Permana Event-Malplenigo</a></li></ol></li><li class="chapter-item expanded "><a href="gpu.html"><strong aria-hidden="true">11.</strong> [Nefinita] Bevy Bildiga (GPU) Enkadraĵo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gpu/intro.html"><strong aria-hidden="true">11.1.</strong> Superrigardo de Bildiga Arĥitekturo</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook.html"><strong aria-hidden="true">12.</strong> Bevy Kuirlibro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/print-framerate.html"><strong aria-hidden="true">12.1.</strong> Montri Kadrofrekvencon in Terminalo</a></li><li class="chapter-item expanded "><a href="cookbook/cursor2world.html"><strong aria-hidden="true">12.2.</strong> Konverti kursoron en mondajn koordinatojn</a></li><li class="chapter-item expanded "><a href="cookbook/custom-projection.html"><strong aria-hidden="true">12.3.</strong> Propra Kamera-Projekcio</a></li><li class="chapter-item expanded "><a href="cookbook/pan-orbit-camera.html"><strong aria-hidden="true">12.4.</strong> Panorama + Orbita Kamerao</a></li><li class="chapter-item expanded "><a href="cookbook/print-resources.html"><strong aria-hidden="true">12.5.</strong> Listo de Ĉiuj Risurcaj Tipoj</a></li></ol></li><li class="chapter-item expanded "><a href="platforms.html"><strong aria-hidden="true">13.</strong> Bevy en Diversaj Platformoj</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/linux.html"><strong aria-hidden="true">13.1.</strong> Linuks-Labortablo</a></li><li class="chapter-item expanded "><a href="platforms/macos.html"><strong aria-hidden="true">13.2.</strong> MakOS-Labortablo</a></li><li class="chapter-item expanded "><a href="platforms/windows.html"><strong aria-hidden="true">13.3.</strong> Vindoz-Labortablo</a></li><li class="chapter-item expanded "><a href="setup/cross.html"><strong aria-hidden="true">13.4.</strong> Transkompilado</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/cross/linux-windows.html"><strong aria-hidden="true">13.4.1.</strong> El Linukso al Vindozo</a></li></ol></li><li class="chapter-item expanded "><a href="platforms/wasm.html"><strong aria-hidden="true">13.5.</strong> Retumilo (WebAssembly)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/wasm/panic-console.html"><strong aria-hidden="true">13.5.1.</strong> Panikaj Mesaĝoj</a></li><li class="chapter-item expanded "><a href="platforms/wasm/size-opt.html"><strong aria-hidden="true">13.5.2.</strong> Grandeca Optimumigo</a></li><li class="chapter-item expanded "><a href="platforms/wasm/gh-pages.html"><strong aria-hidden="true">13.5.3.</strong> Gastigado en GitHub-Pages</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="credits.html">Aŭtoroj</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contact.html">Kontakti kun la aŭtoro</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing-bevy.html">Kontribui al Bevy</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Kontribui al la Origina Libro</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neoficiala Bevy Tromplibro</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="neoficiala-bevy-tromplibro-de-ida-iyes"><a class="header" href="#neoficiala-bevy-tromplibro-de-ida-iyes">Neoficiala Bevy Tromplibro (de Ida Iyes)</a></h1>
<h2 id="atento-la-traduko-estas-plenumigata-laŭ-ordo-de-la-gvidita-instrukcio"><a class="header" href="#atento-la-traduko-estas-plenumigata-laŭ-ordo-de-la-gvidita-instrukcio">ATENTO: La traduko estas plenumigata laŭ ordo de la <a href="/tutorial.html">gvidita instrukcio</a></a></h2>
<p>Ĉi tio estas referenc-stila libro por <a href="https://bevyengine.org">Bevy ludmotoro</a>(<a href="https://github.com/bevyengine/bevy">GitHub</a>).</p>
<p>Ĝi celas instrui Bevy konceptojn en konciza maniero, helpi vin esti produktiva, kaj malkovru la scion, kiun vi bezonas.</p>
<p>Ĉi tiu libro kunigas multe da komunuma saĝeco, kiu ofte ne estas kovrita per oficiala dokumentado, ŝparante al vi la bezonon lukti kun aferoj kiuj aliaj jam komprenis!</p>
<p>Kvankam ĝi celas esti ĝisfunda, dokumentado de tuta ludmotoro estas monumenta tasko. Mi enfokusigas mian tempon por io ajn mi kredas la komunumo plej bezonas.</p>
<p>Tial, estas ankoraŭ multaj preterlasoj, ambaŭ por bazaj kaj progresintaj temoj. Tamen, mi certas, ke ĉi tiu libro pruvos esti valora risurco al vi!</p>
<p><em><strong>Bonvenon! Ke ĉi tiu libro servu al vi bone!</strong></em></p>
<ul>
<li><a href="https://github.com/bevy-cheatbook/bevy-cheatbook">Cheatbook EN GitHub</a></li>
<li><a href="https://github.com/andezitgq/bevy-cheatbook-eo/">Tromplibro EO GitHub</a></li>
<li><a href="https://github.com/sponsors/inodentry">Patronado de Cheatbook aŭtoro</a></li>
<li><a href="https://github.com/andezitgq">Retejo de la tradukinto</a></li>
</ul>
<h2 id="kiel-uzi-la-libron"><a class="header" href="#kiel-uzi-la-libron">Kiel uzi la libron</a></h2>
<p>La paĝoj en ĉi tiu libro ne estas kreitaj por esti legitaj laŭvice. Ĉiu 
paĝo kovras memstaran temon. Sentu liberecon por translokiĝi al io, pri kio
vi interesiĝas.</p>
<p>Se vi havas specialan temon en menso, pri kiu vi ŝatus lerni, vi
povas trovi ĝin el la enhavtabelo (la flankpanelo) aŭ uzante la serĉfunkcion
(en la supra panelo).</p>
<p>La <a href="/overview.html">Superrigardo de Ĉapitroj</a> paĝo donos al vi ĝeneralan ideon
pri kiel la libro estas strukturita.</p>
<p>Se vi estas komencanto en Bevy, aŭ dezirus pli gviditan sperton, provu la <a href="/tutorial.html">instruckio paĝon</a>. Ĉi tio helpos vin navigi la libron en ordo, kiu havas sencon por lernado, de elementaj ĝis progresintaj temoj.</p>
<p>La <a href="/builtins.html">Bevy Enkonstruaĵoj</a> paĝo estas konciza kaŝslipeto de utila informaĵo pri tipoj kaj trajtoj, provizitaj de Bevy</p>
<h2 id="rekomenditaj-aldonaj-risurcoj"><a class="header" href="#rekomenditaj-aldonaj-risurcoj">Rekomenditaj Aldonaj Risurcoj</a></h2>
<p>Bevy havas riĉan kolekton de <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">oficialaj kod-ekzemploj</a>.</p>
<p>Vizitu <a href="https://bevyengine.org/assets">bevy-valoraĵojn</a>, por komunume kreitaj risurcoj.</p>
<p>Nia komunumo estas tre amikema kaj utila. Bonvolu aliĝi al la <a href="https://discord.gg/bevy">Bevy
Diskordo</a> por babili, demandi aŭ partopreni en la projekto!</p>
<p>Se vi volas vidi kelkajn ludojn, kreitajn per Bevy, vd. <a href="https://itch.io/games/tag-bevy">itch.io</a>
aŭ <a href="https://bevyengine.org/assets/#input">Bevy Valoraĵojn</a>.</p>
<h2 id="prizorgado"><a class="header" href="#prizorgado">Prizorgado</a></h2>
<p>Ĉi tiu versio de la libro estas por Bevy-eldono 0.7.</p>
<p>Mi intencas teni ĉi tiun libron ĝisdatigita kaj grava kun ĉiu nova eldono de Bevy.
Mi ankaŭ provas regule fari plibonigojn al ĝi, kiam mi povas administri ĝin.</p>
<h2 id="subtenu-la-libraŭtoron"><a class="header" href="#subtenu-la-libraŭtoron">Subtenu la libraŭtoron</a></h2>
<p><a class="github-button" href="https://github.com/sponsors/inodentry" data-icon="octicon-heart" data-size="grande" aria-label="Sponsoru @inodentry en GitHub ">GitHub-Sponsoroj | Ida Iyes</a></p>
<p>Via oferdonaĵo helpas labori pri tia libere disponebla enhavo. Dankon! ❤️</p>
<h2 id="subtenu-bevy"><a class="header" href="#subtenu-bevy">Subtenu Bevy</a></h2>
<p><a class="github-button" href="https://github.com/sponsors/cart" data-icon="octicon-heart" data-size="grande" aria-label="Sponsoru @cart sur GitHub ">GitHub-Sponsoroj | Bevy</a></p>
<p>Se vi ŝatas na la Bevy Ludmotoro, vi devus konsideri oferdoni al la
oficiala projekto.</p>
<h2 id="permesilo"><a class="header" href="#permesilo">Permesilo</a></h2>
<p>Kopirajto © 2021-2022 Ida Iyes.</p>
<p>La tuta kodo de la libro estas provizita sub la
<a href="https://github.com/bevy-cheatbook/mit-0">Licenco MIT-0</a>.
Laŭ via elekto, vi ankaŭ povas uzi ĝin laŭ la regula MIT-permesilo.</p>
<p>La teksto de la libro estas provizita sub la
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</p>
<p>Escepto: Se uzata por la celo de kontribuo al la &quot;Oficiala Bevy
Projekto&quot;, la tuta enhavo de la libro povas esti uzata sub la <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0
Licenco</a>.</p>
<p>&quot;Oficiala Bevy Projekto&quot; estas difinita kiel:</p>
<ul>
<li>Ajnaj dosieroj enhavitaj en la Git-deponejo estas gastigita ĉe <a href="https://github.com/bevyengine/bevy">https://github.com/bevyengine/bevy</a></li>
<li>Ajnaj dosieroj enhavitaj en la Git-deponejo estas gastigita ĉe <a href="https://github.com/bevyengine/bevy-website">https://github.com/bevyengine/bevy-website</a></li>
<li>Io ajn publike videbla en la retejo <a href="https://bevyengine.org">bevyengine.org</a></li>
</ul>
<h2 id="kontribuoj"><a class="header" href="#kontribuoj">Kontribuoj</a></h2>
<p>Disvolviĝo de ĉi tiu libro estas gastigita en <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<p>Bonvolu registri GitHub-Problemojn por ajna malĝusta/konfuza/misgvida informo,
kaj ankaŭ sugestojn pri nova enhavo, kiun vi ŝatus aldoniĝi al la libro.</p>
<p>Kontribuoj estas akceptitaj, kun kelkaj limigoj.</p>
<p>Vd. la sekcion <a href="/contributing.html">Kontribuo</a> por ĉiuj detaloj.</p>
<h2 id="averto-pri-stabileco"><a class="header" href="#averto-pri-stabileco">Averto pri Stabileco</a></h2>
<p>Bevy estas ankoraŭ tre nova kaj eksperimenta ludmotoro! Ĝi nur estis
publika ekde aŭgusto 2020!</p>
<p>Dum plibonigoj okazas kun nekredebla ritmo, kaj disvolviĝo
estas aktiva, Bevy simple ankoraŭ ne havis la tempon maturiĝi.</p>
<p><em>Ne ekzistas garantioj de la stabilecщ kaj rompiĝaj ŝanĝoj ofte okazas!</em></p>
<p>Kutime, ne estas malfacile adaptiĝi al ŝanĝoj kun novaj eldonoj (aŭ eĉ spuri la ĉefa git-disvolva branĉo), sed vi estis avertita!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superrigardo-de-Ĉapitroj"><a class="header" href="#superrigardo-de-Ĉapitroj">Superrigardo de Ĉapitroj</a></h1>
<p>Ĉi tiu libro estas organizita en kelkajn diversajn ĉapitrojn, kovrantaj malsamajn aspektojn de laboro kun Bevy. Ĝi estas desegnita por esti utila kiel referenco kaj lerna ilo, do vi povas translokiĝi al tio, kio interesas vin kaj lerni pri ĝi.</p>
<p>Se vi deziras pli gviditan instrukcian sperton, aŭ foliumi la libron laŭ la malfacileco (de komencanto ĝis progresintulo), penu la <a href="/tutorial.html">paĝon de gvidita instrukcio</a>. Ĝi rekomendas temojn kun logika ordo por lernado.</p>
<p>La <a href="/builtins.html">Bevy Enkonstruaĵoj</a> paĝo estas konciza kaŝslipeto de utila informaĵo pri tipoj kaj apartaĵoj, provizitaj de Bevy.</p>
<p>La libro havas la sekvajn ĝeneralajn ĉapitrojn:</p>
<ul>
<li><a href="/setup.html">Konsiloj pri Bevy Instalado</a>: konsiloj pri projekt-instalado, rekomendaĵoj por iloj kaj kromaĵoj</li>
<li><a href="/pitfalls.html">Ĝeneralaj Kaptiloj</a>: solvaĵoj por generaj problemoj, kun kiuj la komunumo renkontis</li>
<li><a href="/programming.html">Bevy Programada Enkadraĵo (Framework)</a>: kiel skribi kodon en Bevy (fundamentaj scioj)</li>
<li><a href="/patterns.html">Programadaj Ŝablonoj</a>: opiniemaj konsiloj, ŝablonoj kaj idiomoj</li>
<li><a href="/gpu.html">[Nefinita] Bevy Bildiga (GPU) Enkadraĵo</a>: laborado kun la GPU kaj Bevy's bildigado (rendering)</li>
<li><a href="/cookbook.html">Bevy Kuirlibro</a>: diversaj kodekzemploj preter tiuj en Bevy oficialaj repostoj</li>
<li><a href="/platforms.html">Bevy en Diversaj Platformoj</a>: informaĵoj pri laborado kun certaj platformoj/operaciumoj</li>
</ul>
<p>La sekvaj ĉapitroj fokusiĝas sur kovrado de certaj sferoj de Bevy-apartaĵoj:</p>
<ul>
<li><a href="/features.html">Kerno de Bevy Ludmotoro</a>: gravaj apartaĵoj, kiuj ne estas malkovritaj en ajn alia ĉapitro</li>
<li><a href="/assets.html">Administrado de Valoraĵoj</a>: laboro kun datumaj valoraĵoj</li>
<li><a href="/input.html">Eniga Priskribilo</a>: laboro kun diversaj enig-aparatoj</li>
<li><a href="/window.html">Administrado de Fenestroj</a>: laboro kun la operaciuma fenestro</li>
<li><a href="/2d.html">Bevy 2D</a>: Bevy apartaĵoj por 2D ludoj</li>
<li><a href="/3d.html">Bevy 3D</a>: Bevy apartaĵoj por 3D ludoj</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ĉu-komencanto-en-bevy-tute-gvidita-instrukcio"><a class="header" href="#Ĉu-komencanto-en-bevy-tute-gvidita-instrukcio">Ĉu komencanto en Bevy? Tute Gvidita Instrukcio!</a></h1>
<p>Bonvenon al Bevy! :) Ni ĝojas vidi vin en nia komunumo!</p>
<p>Ankaŭ vd. <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">la oficialajn Bevy ekzemplojn</a>. Se vi bezonas helpon, uzu <a href="https://github.com/bevyengine/bevy/discussions">GitHub Diskutoj</a>, aŭ ne timu
eniri babilejon kaj demandi por helpo en <a href="https://discord.gg/bevy">Diskordo</a>.</p>
<hr />
<p>Ĉi tiu paĝo estas por novaj lernantoj. Ĝi gvidos vin tra ĉi tiu libro en la ordo, kiu havas sencon studi, de la bazaĵoj ĝis la pli progresintaj temoj. Ĉi tio diferencas de la ĉefa enhavtabelo (maldekstra flanka kolumno), kiu estas celita esti uzata de Bevy-uzantoj de ĉiuj lertaj niveloj.</p>
<p>Ĉi tiu instrukcio-paĝo ne listigas ĉiujn paĝojn de la libro. Ĉi tio estas gvidilo por helpi vin akiri ampleksan ĝeneralan scion. La libro ankaŭ havas multajn paĝojn, dediĉitajn al solvoj de specifaj problemoj, kiuj ne estas listigitaj ĉi tie.</p>
<p>Sentu liberecon esplori la libron kaj legi ion ajn, kiu vin interesigas.</p>
<p>Vi faros ion mojosan kun Bevy dum mallonga tempo! ;)</p>
<hr />
<p>Se vi renkontas problemojn, vizitu la
<a href="/pitfalls.html">Ĝeneralajn Kaptilojn</a> ĉapitro por vidi, ĉu ĉi tiu libro havas ion por helpi vin. Solvaĵoj al iuj el la plej oftaj problemoj de la komunumo de Bevy-membroj estas dokumentitaj tie.</p>
<h2 id="bazaĵoj"><a class="header" href="#bazaĵoj">Bazaĵoj</a></h2>
<p>Ĉi tiuj estas la absolutaj bazaĵoj de uzado de Bevy - la nura minimumo de konceptoj por komenci. Ĉiu projekto de Bevy, eĉ simpla, postulos, ke vi konatiĝu kun ĉi tiuj konceptoj.</p>
<p>Eble vi povus fari ion kiel simplan konkurs-ludon aŭ prototipon, uzante ĝuste tiun scion. Kvankam dum via projekto altiĝos, vi verŝajne devos lerni pli rapide.</p>
<ul>
<li><a href="/setup.html">Konsiloj pri Bevy Instalado</a>: Agordado de viaj ellaboliroj kaj medio
<ul>
<li><a href="/setup/getting-started.html">Komencante</a></li>
</ul>
</li>
<li><a href="/programming.html">Bevy Programada Enkadraĵo (Framework)</a>:
Kiel skribi Bevy-kodon, strukturi viajn datumojn kaj logikon
<ul>
<li><a href="/programming/ecs-intro.html">Enkonduko al EKS</a></li>
<li><a href="/programming/ec.html">Entoj kaj Komponantoj</a></li>
<li><a href="/programming/res.html">Risurcoj</a></li>
<li><a href="/programming/systems.html">Sistemoj</a></li>
<li><a href="/programming/app-builder.html">Aplikaĵa Konstruilo</a></li>
<li><a href="/programming/queries.html">Informpetoj</a></li>
<li><a href="/programming/commands.html">Komandoj</a></li>
<li><a href="/programming/events.html">Eventoj</a></li>
</ul>
</li>
<li><a href="/features.html">Kerno de Bevy Ludmotoro</a>:
Bazaj apartaĵoj de Bevy, bezonataj por krei iun ajn ludon
<ul>
<li><a href="/features/coords.html">Koordinata Sistemo</a></li>
<li><a href="/features/transforms.html">Transformoj</a></li>
<li><a href="/features/time.html">Tempo kaj Tempigiloj</a></li>
</ul>
</li>
<li><a href="/assets.html">Administrado de Valoraĵoj</a>:
Kiel labori kun valoraĵoj (assets)
<ul>
<li><a href="/assets/handles.html">Priskribiloj (Handles)</a></li>
<li><a href="/assets/assetserver.html">Elŝuti Valoraĵojn el Dosieroj</a></li>
</ul>
</li>
<li><a href="/input.html">Eniga Priskribilo</a>:
Uzado de diversaj enigaj aparatoj</li>
<li><a href="/window.html">Administrado de Fenestroj</a>:
Instalado de la operaciuma fenestro (aŭ plenekrano) por via ludo
<ul>
<li><a href="/window/clear-color.html">Ŝanĝo la Fonkoloron</a></li>
</ul>
</li>
</ul>
<h2 id="sekvaj-paŝoj"><a class="header" href="#sekvaj-paŝoj">Sekvaj Paŝoj</a></h2>
<p>Vi verŝajne bezonos ekscii almenaŭ kelkajn el ĉi tiuj temoj por krei ne-trivialan Bevy-projekton. Post kiam vi estos komforta kun la bazaĵoj, vi povos konatiĝi kun ili por fariĝi potenca uzanto de Bevy.</p>
<ul>
<li><a href="/setup.html">Konsiloj pri Bevy Instalado</a>
<ul>
<li><a href="/setup/bevy-tools.html">Ellaboriloj kaj Redaktiloj por Bevy</a></li>
<li><a href="/setup/unofficial-plugins.html">Ekosistemo de Komunumaj Kromaĵoj</a></li>
</ul>
</li>
<li><a href="/programming.html">Bevy Programada Enkadraĵo (Framework)</a>
<ul>
<li><a href="/programming/system-order.html">Sistema Ordo de Plenumado</a></li>
<li><a href="/programming/system-sets.html">Sistemaj Aroj</a></li>
<li><a href="/programming/local.html">Lokaj Risurcoj</a></li>
<li><a href="/programming/plugins.html">Kromaĵoj</a></li>
<li><a href="/programming/labels.html">Titoloj</a></li>
<li><a href="/programming/states.html">Statoj</a></li>
<li><a href="/programming/change-detection.html">Detekto de Ŝanĝo</a></li>
<li><a href="/programming/query-sets.html">Parametraj Aroj</a></li>
<li><a href="/programming/stages.html">Etapoj</a></li>
</ul>
</li>
<li><a href="/patterns.html">Programadaj Ŝablonoj</a>
<ul>
<li><a href="/patterns/generic-systems.html">Generaj Sistemoj</a></li>
<li><a href="/patterns/component-storage.html">Komponanta Stokaĵo</a></li>
</ul>
</li>
<li><a href="/assets.html">Administrado de Valoraĵoj</a>:
<ul>
<li><a href="/assets/data.html">Atingo al la Valoraĵ-datumo</a></li>
<li><a href="/assets/assetevent.html">Reagi al Ŝanĝoj kun Valoraĵ-eventoj</a></li>
<li><a href="/assets/hot-reload.html">Tuj-Reŝargo de Valoraĵoj</a></li>
</ul>
</li>
</ul>
<h2 id="progresinta-nivelo"><a class="header" href="#progresinta-nivelo">Progresinta Nivelo</a></h2>
<p>Ĉi tiuj estas pli fakaj temoj, kiuj povas esti utilaj en kompleksaj projektoj. Plej tipaj uzantoj de Bevy ne bezonos scii ĉi tion.</p>
<ul>
<li><a href="/programming.html">Bevy Programada Enkadraĵo (Framework)</a>
<ul>
<li><a href="/programming/run-criteria.html">Lanĉaj Kriterioj</a></li>
<li><a href="/programming/removal-detection.html">Detekto de Forigo</a></li>
<li><a href="/programming/system-chaining.html">Sistema Ligado</a></li>
<li><a href="/programming/world.html">Direkta Atingo al EKS-Mondo</a></li>
<li><a href="/programming/exclusive.html">Ekskluzivaj Sistemoj</a></li>
<li><a href="/programming/non-send.html">Nesendaj Risurcoj</a></li>
</ul>
</li>
<li><a href="/patterns.html">Programadaj Ŝablonoj</a>
<ul>
<li><a href="/patterns/manual-event-clear.html">Permana Event-Malplenigo</a></li>
</ul>
</li>
</ul>
<h2 id="solvaĵoj-por-specifaj-problemoj"><a class="header" href="#solvaĵoj-por-specifaj-problemoj">Solvaĵoj por Specifaj Problemoj</a></h2>
<p>Ĉi tiuj estas paĝoj, kiuj instruas vin kiel solvi specifajn problemojn, kiujn vi eble
renkontiĝu en via projekto.</p>
<ul>
<li><a href="/cookbook/cursor2world.html">Konverti kursoron en mondajn koordinatojn</a></li>
<li><a href="/programming/system-tests.html">Kreado de Testoj por Sistemoj</a></li>
<li><a href="/assets/ready.html">Observi Elŝut-progreson</a></li>
<li><a href="/window/mouse-grab.html">Kapti la Muskursoron</a></li>
<li><a href="/window/icon.html">Difini la Fenestran Ikoneton</a></li>
<li><a href="/input/char.html">Enigo de Teksto</a></li>
<li><a href="/input/dnd.html">Treni-k-faligi dosierojn</a></li>
<li><a href="/cookbook/cursor2world.html">Propra Projekcio de Kamerao</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listo-de-bevy-enkostruĵoj"><a class="header" href="#listo-de-bevy-enkostruĵoj">Listo de Bevy Enkostruĵoj</a></h1>
<p>Ĉi tiu pago estas rapide densigita listo de ĉiuj gravaj aferoj, provizitaj per Bevy</p>
<ul>
<li><a href="builtins.html#systemparams">SistemParametroj</a></li>
<li><a href="builtins.html#assets">Valoraĵoj (Assets)</a></li>
<li><a href="builtins.html#file-formats">Dosieraj Formatoj</a></li>
<li><a href="builtins.html#wgpu-backends"><code>wgpu</code> Bibliotekoj</a></li>
<li><a href="builtins.html#bundles">Pakoj (Bundles)</a></li>
<li><a href="builtins.html#configuration-resources">Risurcoj (Agordo)</a></li>
<li><a href="builtins.html#engine-resources">Risurcoj (Motoro)</a></li>
<li><a href="builtins.html#input-handling-resources">Risurcoj (Enigo)</a></li>
<li><a href="builtins.html#input-events">Eventoj (Enigo)</a></li>
<li><a href="builtins.html#system-and-control-events">Eventoj (Sistemo/Kontrolo)</a></li>
<li><a href="builtins.html#components">Komponantoj</a></li>
<li><a href="builtins.html#gltf-asset-labels">GLTF Valoraĵaj Titoloj</a></li>
<li><a href="builtins.html#stages">Etapoj</a></li>
</ul>
<h2 id="sistemparametroj"><a class="header" href="#sistemparametroj">SistemParametroj</a></h2>
<p>Ĉi tiuj estas la specialaj tipoj, kiujn oni povas uzi kiel <a href="/programming/systems.html">sistemaj</a> parametroj.</p>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/trait.SystemParam.html#implementors">(List in API Docs)</a></p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>:
Manipulate the ECS using <a href="/programming/commands.html">commands</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>:
Shared access to a <a href="/programming/res.html">resource</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>:
Exclusive (mutable) access to a <a href="/programming/res.html">resource</a></li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code>:
Shared access to a resource that may not exist</li>
<li><code>Option&lt;ResMut&lt;T&gt;&gt;</code>:
Exclusive (mutable) access to a resource that may not exist</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Query.html"><code>Query&lt;T, F = ()&gt;</code></a> (can contain tuples of up to 15 types):
Access to <a href="/programming/ec.html">entities and components</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet</code></a> (with up to 8 params):
Resolve [conflicts between incompatible system parameters][cb::paramset]</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="/programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>:
Receive <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>:
Send <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a>:
<a href="/programming/removal-detection.html">Removal detection</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a>:
Shared access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>:
Mut access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a>:
Read-only <a href="/programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/entity/struct.Entities.html"><code>Entities</code></a>:
Low-level ECS metadata: All entities</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/component/struct.Components.html"><code>Components</code></a>:
Low-level ECS metadata: All components</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/bundle/struct.Bundles.html"><code>Bundles</code></a>:
Low-level ECS metadata: All bundles</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/archetype/struct.Archetypes.html"><code>Archetypes</code></a>:
Low-level ECS metadata: All archetypes</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.SystemChangeTick.html"><code>SystemChangeTick</code></a>:
Low-level ECS metadata: Tick used for change detection</li>
<li>tuples containing any of these types, with up to 16 members</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>These are the Asset types registered by Bevy by default.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/texture/struct.Image.html"><code>Image</code></a>:
Pixel data, used as a texture for 2D and 3D rendering;
also contains the <a href="https://docs.rs/bevy/0.7.0/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a> for texture filtering settings</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a>:
2D &quot;Sprite Sheet&quot; defining sub-images within a single larger image</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a>:
3D Mesh (geometry data), contains vertex attributes (like position, UVs, normals)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a>:
GPU shader code, in one of the supported languages (WGSL/SPIR-V/GLSL)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.ColorMaterial.html"><code>ColorMaterial</code></a>:
Basic &quot;2D material&quot;: contains color, optionally an image</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>:
&quot;3D material&quot; with support for Physically-Based Rendering</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a>:
Data for a single animation sequence, can be used with <a href="https://docs.rs/bevy/0.7.0/bevy/animation/struct.AnimationPlayer.html"><code>AnimationPlayer</code></a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/text/struct.Font.html"><code>Font</code></a>:
Font data used for text rendering</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/scene/struct.Scene.html"><code>Scene</code></a>:
Scene composed of literal ECS entities to instantiate</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/scene/struct.DynamicScene.html"><code>DynamicScene</code></a>:
Scene composed with dynamic typing and reflection</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a>:
<a href="/features/gltf.html#gltf-master-asset">GLTF Master Asset</a>: index of the entire contents of a GLTF file</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a>:
Logical GLTF object in a scene</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>:
Logical GLTF 3D model, consisting of multiple <code>GltfPrimitive</code>s</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfPrimitive.html"><code>GltfPrimitive</code></a>:
Single unit to be rendered, contains the Mesh and Material to use</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a>:
Raw audio data for <code>bevy_audio</code></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/audio/struct.AudioSink.html"><code>AudioSink</code></a>:
Audio that is currently active, can be used to control playback</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/text/struct.FontAtlasSet.html"><code>FontAtlasSet</code></a>:
(internal use for text rendering)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a>:
(internal use for skeletal animation)</li>
</ul>
<h2 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h2>
<p>These are the asset file formats (asset loaders) supported by Bevy. Support
for each one can be enabled/disabled using <a href="/setup/bevy-config.html">cargo features</a>. Some
are enabled by default, many are not.</p>
<p>Image formats (loaded as <a href="https://docs.rs/bevy/0.7.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets):</p>
<table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>PNG</td><td><code>&quot;png&quot;</code></td><td>Yes</td><td><code>.png</code></td></tr>
<tr><td>HDR</td><td><code>&quot;hdr&quot;</code></td><td>Yes</td><td><code>.hdr</code></td></tr>
<tr><td>JPEG</td><td><code>&quot;jpeg&quot;</code></td><td>No</td><td><code>.jpg</code>, <code>.jpeg</code></td></tr>
<tr><td>TGA</td><td><code>&quot;tga&quot;</code></td><td>No</td><td><code>.tga</code></td></tr>
<tr><td>BMP</td><td><code>&quot;bmp&quot;</code></td><td>No</td><td><code>.bmp</code></td></tr>
<tr><td>DDS</td><td><code>&quot;dds&quot;</code></td><td>No</td><td><code>.dds</code></td></tr>
<tr><td>KTX2</td><td><code>&quot;ktx2&quot;</code></td><td>No</td><td><code>.ktx2</code></td></tr>
<tr><td>Basis</td><td><code>&quot;basis-universal&quot;</code></td><td>No</td><td><code>.basis</code></td></tr>
</tbody></table>
<p>Audio formats (loaded as <a href="https://docs.rs/bevy/0.7.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> assets):</p>
<table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>OGG Vorbis</td><td><code>&quot;vorbis&quot;</code></td><td>Yes</td><td><code>.ogg</code></td></tr>
<tr><td>FLAC</td><td><code>&quot;flac&quot;</code></td><td>No</td><td><code>.flac</code></td></tr>
<tr><td>WAV</td><td><code>&quot;wav&quot;</code></td><td>No</td><td><code>.wav</code></td></tr>
<tr><td>MP3</td><td><code>&quot;mp3&quot;</code></td><td>No</td><td><code>.mp3</code></td></tr>
</tbody></table>
<p>3D asset (model or scene) formats:</p>
<table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>GLTF</td><td><code>&quot;bevy_gltf&quot;</code></td><td>Yes</td><td><code>.gltf</code>, <code>.glb</code></td></tr>
</tbody></table>
<p>Shader formats (loaded as <a href="https://docs.rs/bevy/0.7.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a> assets):</p>
<table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>SPIR-V</td><td>n/a</td><td>Yes</td><td><code>.spv</code></td></tr>
<tr><td>WGSL</td><td>n/a</td><td>Yes</td><td><code>.wgsl</code></td></tr>
<tr><td>GLSL</td><td>n/a</td><td>Yes</td><td><code>.vert</code>, <code>.frag</code></td></tr>
</tbody></table>
<p>Font formats (loaded as <a href="https://docs.rs/bevy/0.7.0/bevy/text/struct.Font.html"><code>Font</code></a> assets):</p>
<table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>TrueType</td><td>n/a</td><td>Yes</td><td><code>.ttf</code></td></tr>
<tr><td>OpenType</td><td>n/a</td><td>Yes</td><td><code>.otf</code></td></tr>
</tbody></table>
<p>There are <a href="/setup/unofficial-plugins.html#file-formats">unofficial plugins</a> available for adding
support for even more file formats.</p>
<h2 id="wgpu-backends"><a class="header" href="#wgpu-backends"><code>wgpu</code> Backends</a></h2>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends for each platform:</p>
<ul>
<li>Vulkan (Linux/Windows/Android)</li>
<li>DirectX 12 (Windows)</li>
<li>Metal (Apple)</li>
<li>WebGL2 (Web)</li>
<li>WebGPU (Web; experimental)</li>
<li>GLES3 (Linux/Android; legacy)</li>
<li>DirectX 11 (Windows; legacy; WIP (not yet ready for use))</li>
</ul>
<h2 id="bundles"><a class="header" href="#bundles">Bundles</a></h2>
<p>Bevy's built-in <a href="/programming/ec.html#component-bundles">bundle</a> types, for spawning different common
kinds of entities.</p>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/bundle/trait.Bundle.html#implementors">(List in API Docs)</a></p>
<p>Any tuples of up to 15 <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/component/trait.Component.html"><code>Component</code></a> types are valid bundles.</p>
<p>General:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a>:
Contains the <a href="/features/transforms.html">transform</a> types
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> and <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>
to enable using the entity in a <a href="/features/parent-child.html">parent-child hierarchy</a></li>
</ul>
<p>Bevy 3D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.PerspectiveCameraBundle.html"><code>PerspectiveCameraBundle</code></a>:
3D camera with a perspective projection</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.OrthographicCameraBundle.html"><code>OrthographicCameraBundle</code></a>:
Camera with an orthographic projection, 2D or 3D</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>:
3D Object/Primitive: a Mesh and the Material to draw it with</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/type.PbrBundle.html"><code>PbrBundle</code></a>:
3D object with the standard Physically-Based Material (<code>MaterialMeshBundle&lt;StandardMaterial&gt;</code>)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.DirectionalLightBundle.html"><code>DirectionalLightBundle</code></a>: 
3D directional light (like the sun)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.PointLightBundle.html"><code>PointLightBundle</code></a>: 
3D point light (like a lamp or candle)</li>
</ul>
<p>Bevy 2D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.OrthographicCameraBundle.html"><code>OrthographicCameraBundle</code></a>:
Camera with an orthographic projection, 2D or 3D</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.SpriteBundle.html"><code>SpriteBundle</code></a>: 
2D sprite, using a whole image (<a href="https://docs.rs/bevy/0.7.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.SpriteSheetBundle.html"><code>SpriteSheetBundle</code></a>:
2D sprite, using a sub-rectangle in a larger image (<a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a> asset)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.MaterialMesh2dBundle.html"><code>MaterialMesh2dBundle</code></a>:
2D shape, with custom Mesh and Material (similar to 3D objects)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/text/struct.Text2dBundle.html"><code>Text2dBundle</code></a>:
Text to be drawn in the 2D world (not the UI)</li>
</ul>
<p>Bevy UI:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/entity/struct.UiCameraBundle.html"><code>UiCameraBundle</code></a>:
The UI Camera</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/entity/struct.NodeBundle.html"><code>NodeBundle</code></a>:
Empty node element (like HTML <code>&lt;div&gt;</code>)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/entity/struct.ButtonBundle.html"><code>ButtonBundle</code></a>:
Button element</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/entity/struct.ImageBundle.html"><code>ImageBundle</code></a>:
Image element</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/entity/struct.TextBundle.html"><code>TextBundle</code></a>:
Text element</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<h3 id="configuration-resources"><a class="header" href="#configuration-resources">Configuration Resources</a></h3>
<p>These resources allow you to change the settings for how various parts of Bevy work.</p>
<p>Some of them affect the low-level initialization of the engine, so must be present from the
start to take effect. You need to insert these at the start of your <a href="/programming/app-builder.html">app builder</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/log/struct.LogSettings.html"><code>LogSettings</code></a>:
Configure what messages get logged to the console</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowDescriptor.html"><code>WindowDescriptor</code></a>:
Settings for the primary application window</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/settings/struct.WgpuSettings.html"><code>WgpuSettings</code></a>:
Low-level settings for the GPU API and backends</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServerSettings.html"><code>AssetServerSettings</code></a>:
Configuration of the <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.DefaultTaskPoolOptions.html"><code>DefaultTaskPoolOptions</code></a>:
Settings for the CPU task pools (multithreading)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/winit/struct.WinitSettings.html"><code>WinitSettings</code></a>:
Settings for the OS Windowing backend, including update loop / power-management settings</li>
</ul>
<p>These may be inserted at the start, but should also be fine to change at runtime (from a
<a href="/programming/systems.html">system</a>):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/core_pipeline/struct.ClearColor.html"><code>ClearColor</code></a>:
Global renderer background color to clear the window at the start of each frame</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.AmbientLight.html"><code>AmbientLight</code></a>:
Global renderer &quot;fake lighting&quot;, so that shadows don't look too dark / black</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/view/struct.Msaa.html"><code>Msaa</code></a>:
Global renderer setting for Multi-Sample Anti-Aliasing (some platforms might only support the values 1 and 4)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/enum.ClusterConfig.html"><code>ClusterConfig</code></a>:
Configuration of the light clustering algorithm, affects the performance of 3D scenes with many lights</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/wireframe/struct.WireframeConfig.html"><code>WireframeConfig</code></a>:
Global toggle to make everything be rendered as wireframe</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a>:
Gamepad input device settings, like joystick deadzones and button sensitivities</li>
</ul>
<h3 id="engine-resources"><a class="header" href="#engine-resources">Engine Resources</a></h3>
<p>These resources provide access to different features of the game engine at runtime.</p>
<p>Access them from your <a href="/programming/systems.html">systems</a>, if you need their state, or to control the respective
parts of Bevy.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.FixedTimesteps.html"><code>FixedTimesteps</code></a>:
The state of all registered <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.FixedTimestep.html"><code>FixedTimestep</code></a> drivers</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Time.html"><code>Time</code></a>:
Global time-related information (current frame delta time, time since startup, etc.)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>:
Control the asset system: Load assets, check load status, etc.</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a>:
List of IDs for all currently-detected (connected) gamepad devices</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.Windows.html"><code>Windows</code></a>:
All the open windows (the primary window + any additional windows in a multi-window gui app)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> ([non-send][cb::non-send]):
Raw state of the <code>winit</code> backend for each window</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/audio/struct.Audio.html"><code>Audio</code></a>:
Use this to play sounds via <code>bevy_audio</code></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/tasks/struct.AsyncComputeTaskPool.html"><code>AsyncComputeTaskPool</code></a>:
Task pool for running background CPU tasks</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/tasks/struct.ComputeTaskPool.html"><code>ComputeTaskPool</code></a>:
Task pool where the main app schedule (all the systems) runs</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/tasks/struct.IoTaskPool.html"><code>IoTaskPool</code></a>:
Task pool where background i/o tasks run (like asset loading)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/diagnostic/struct.Diagnostics.html"><code>Diagnostics</code></a>:
Diagnostic data collected by the engine (like frame times)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/scene/struct.SceneSpawner.html"><code>SceneSpawner</code></a>:
Direct control over spawning Scenes into the main app World</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/reflect/struct.TypeRegistryArc.html"><code>TypeRegistryArc</code></a>:
Access to the Reflection Type Registry</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/render_resource/struct.WgpuAdapterInfo.html"><code>AdapterInfo</code></a>:
Information about the GPU hardware that Bevy is running on</li>
</ul>
<h3 id="input-handling-resources"><a class="header" href="#input-handling-resources">Input Handling Resources</a></h3>
<p>These resources represent the current state of different input devices. Read them from your
<a href="/programming/systems.html">systems</a> to [handle user input][cb::input].</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/keyboard/enum.KeyCode.html"><code>Input&lt;KeyCode&gt;</code></a>:
Keyboard key state, as a binary <a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/enum.MouseButton.html"><code>Input&lt;MouseButton&gt;</code></a>:
Mouse button state, as a binary <a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Input&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, as a binary <a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadAxis.html"><code>Axis&lt;GamepadAxis&gt;</code></a>:
Analog <a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Axis.html">Axis</a> gamepad inputs (joysticks and triggers)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Axis&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, represented as an analog <a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Axis.html">Axis</a> value</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>:
The state of all fingers currently touching the touchscreen</li>
</ul>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<h3 id="input-events"><a class="header" href="#input-events">Input Events</a></h3>
<p>These <a href="/programming/events.html">events</a> fire on activity with input devices. Read them to [handle user input][cb::input].</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a>:
Changes in the state of mouse buttons</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a>:
Scrolling by a number of pixels or lines (<a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a>)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a>:
Relative movement of the mouse (pixels from previous frame), regardless of the OS pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a>:
New position of the OS mouse pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a>:
Changes in the state of keyboard keys (keypresses, not text)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.ReceivedCharacter.html"><code>ReceivedCharacter</code></a>:
Unicode text input from the OS (correct handling of the user's language and layout)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a>:
Change in the state of a finger touching the touchscreen</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadEvent.html"><code>GamepadEvent</code></a>:
Changes in the state of a gamepad or any of its buttons or axes</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadEventRaw.html"><code>GamepadEventRaw</code></a>:
Gamepad events unaffected by <a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a></li>
</ul>
<h3 id="system-and-control-events"><a class="header" href="#system-and-control-events">System and Control Events</a></h3>
<p>Events from the OS / windowing system, or to control Bevy.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.RequestRedraw.html"><code>RequestRedraw</code></a>:
In an app that does not refresh continuously, request one more update before going to sleep</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.AppExit.html"><code>AppExit</code></a>:
Tell Bevy to shut down</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CloseWindow.html"><code>CloseWindow</code></a>:
Tell Bevy to close a window</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CreateWindow.html"><code>CreateWindow</code></a>:
Tell Bevy to open a new window</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a>:
The user drag-and-dropped a file into our app</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a>:
OS mouse pointer/cursor entered one of our windows</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a>:
OS mouse pointer/cursor exited one of our windows</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowCloseRequested.html"><code>WindowCloseRequested</code></a>:
OS wants to close one of our windows</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowCreated.html"><code>WindowCreated</code></a>:
New application window opened</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowFocused.html"><code>WindowFocused</code></a>:
One of our windows is now focused</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowMoved.html"><code>WindowMoved</code></a>:
OS/user moved one of our windows</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowResized.html"><code>WindowResized</code></a>:
OS/user resized one of our windows</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowScaleFactorChanged.html"><code>WindowScaleFactorChanged</code></a>:
One of our windows has changed its DPI scaling factor</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.WindowBackendScaleFactorChanged.html"><code>WindowBackendScaleFactorChanged</code></a>:
OS reports change in DPI scaling factor for a window</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The complete list of individual component types is too specific to be useful to list here.</p>
<p>See: <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/component/trait.Component.html#implementors">(List in API Docs)</a></p>
<p>Curated/opinionated list of the most important built-in component types:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>:
Local transform (relative to parent, if any)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>:
Global transform (in the world)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a>:
Entity's parent, if in a hierarchy</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/hierarchy/struct.Children.html"><code>Children</code></a>:
Entity's children, if in a hierarchy</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.Handle.html"><code>Handle&lt;T&gt;</code></a>:
Reference to an asset of specific type</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/view/visibility/struct.Visibility.html"><code>Visibility</code></a>:
Manually control visibility, whether to display the entity (hide/show)</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/view/visibility/struct.RenderLayers.html"><code>RenderLayers</code></a>:
Group entities into &quot;layers&quot; and control which &quot;layers&quot; a camera should display</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/animation/struct.AnimationPlayer.html"><code>AnimationPlayer</code></a>:
Make the entity capable of playing animations; used to control animations</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a>:
Camera used for rendering</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/entity/struct.CameraUi.html"><code>CameraUi</code></a>:
Marker to identify the camera used for the UI render pass</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.Camera2d.html"><code>Camera2d</code></a>:
Marker to identify the camera used for the main 2D render pass</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.Camera3d.html"><code>Camera3d</code></a>:
Marker to identify the camera used for the main 3D render pass</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a>:
Orthographic projection for a camera</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>:
Perspective projection for a camera</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.Sprite.html"><code>Sprite</code></a>:
(2D) Properties of a sprite, using a whole image</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/sprite/struct.TextureAtlasSprite.html"><code>TextureAtlasSprite</code></a>:
(2D) Properties of a sprite, using a sprite sheet</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.PointLight.html"><code>PointLight</code></a>:
(3D) Properties of a point light</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.DirectionalLight.html"><code>DirectionalLight</code></a>:
(3D) Properties of a directional light</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/render/view/visibility/struct.NoFrustumCulling.html"><code>NoFrustumCulling</code></a>:
(3D) Cause this mesh to always be drawn, even when not visible by any camera</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.NotShadowCaster.html"><code>NotShadowCaster</code></a>:
(3D) Disable entity from producing dynamic shadows</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.NotShadowReceiver.html"><code>NotShadowReceiver</code></a>:
(3D) Disable entity from having dynamic shadows of other entities</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/pbr/wireframe/struct.Wireframe.html"><code>Wireframe</code></a>:
(3D) Draw object in wireframe mode</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/struct.Node.html"><code>Node</code></a>:
(UI) Mark entity as being controlled by the UI layout system</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/struct.Style.html"><code>Style</code></a>:
(UI) Layout properties of the node</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/enum.Interaction.html"><code>Interaction</code></a>:
(UI) Track interaction/selection state: if the node is clicked or hovered over</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/struct.UiImage.html"><code>UiImage</code></a>:
(UI) Image to be displayed as part of a UI node</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/struct.UiColor.html"><code>UiColor</code></a>:
(UI) Color to use for a UI node</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ui/widget/struct.Button.html"><code>Button</code></a>:
(UI) Marker for a pressable button</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/text/struct.Text.html"><code>Text</code></a>:
Text to be displayed</li>
</ul>
<h2 id="gltf-asset-labels"><a class="header" href="#gltf-asset-labels">GLTF Asset Labels</a></h2>
<p><a href="/features/gltf.html#assetpath-with-labels">Asset path labels to refer to GLTF sub-assets.</a></p>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<h2 id="stages"><a class="header" href="#stages">Stages</a></h2>
<p>Internally, Bevy has at least these built-in <a href="/programming/stages.html">stages</a>:</p>
<ul>
<li>In the <a href="/programming/app-builder.html">main app</a> (<a href="https://docs.rs/bevy/0.7.0/bevy/app/enum.CoreStage.html"><code>CoreStage</code></a>):
<code>First</code>, <code>PreUpdate</code>, <code>Update</code>, <code>PostUpdate</code>, <code>Last</code></li>
<li>In the render <a href="/programming/sub-apps.html">sub-app</a> (<a href="https://docs.rs/bevy/0.7.0/bevy/render/enum.RenderStage.html"><code>RenderStage</code></a>):
<code>Extract</code>, <code>Prepare</code>, <code>Queue</code>, <code>PhaseSort</code>, <code>Render</code>, <code>Cleanup</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsiloj-pri-bevy-instalado"><a class="header" href="#konsiloj-pri-bevy-instalado">Konsiloj pri Bevy Instalado</a></h1>
<p>Ĉi tiu ĉapitro estas kolekto de aldonaj konsiletoj por agordi vian projekton aŭ disvolvilojn, kolektitajn de la Bevy-komunumo, krom tiuj, kiuj estas kovritaj en Bevy <a href="https://bevyengine.org/learn/book/getting-started/setup/">oficialan instal-dokumentaĵo</a>.</p>
<p>Ne timu sugesti aldoni aferojn sub ĉi tiu ĉapitro.</p>
<hr />
<p>Ankaŭ vd. la sekvan alian oportunan enhavon el ĉi tiu libro:</p>
<ul>
<li><a href="/platforms.html">Bevy en Diversaj Platformoj</a></li>
<li><a href="/pitfalls/performance.html">Kiel ripari malrapidan plenumecon</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="komencante"><a class="header" href="#komencante">Komencante</a></h1>
<p>Ĉi tiu paĝo kovras la bazan agordadon, bezonan por Bevy-ellaborado.</p>
<hr />
<p>Plejparte, Bevy estas sama, kiel iu ajn alia Rust-biblioteko. Vi bezonas
instali na Rust kaj agordi vian ellaborad-medion. Vi povas instali Rust, uzante <a href="https://rustup.rs">Rustup</a>. Vidu
<a href="https://www.rust-lang.org/learn/get-started">La oficialan agordan paĝon de Rust</a>.</p>
<p>En Linukso, vi bezonas la ellaborad-dosierojn por kelkaj sistemaj bibliotekoj. Vd. la
<a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">oficialan Bevy Linuks-dependaĵan paĝon</a>.</p>
<p>Ankaŭ vd. la <a href="https://bevyengine.org/learn/book/getting-started/setup/">Agordan paĝon en la oficiala Bevy Libro</a> kaj la <a href="https://bevyengine.org/learn/book/getting-started/setup/">oficialan Bevy Readme (Leguminaĵon)</a></p>
<h2 id="gpu-peliloj"><a class="header" href="#gpu-peliloj">GPU Peliloj</a></h2>
<p>En Linukso, Bevy nuntempe postulas na Vulkan por grafikaĵoj.</p>
<p>En Vindozo, kaj Vulkan kaj DirectX 12 povas esti uzataj.</p>
<p>Certigu, ke vi havas kongruajn aparataron kaj pelilojn, instalitajn en via sistemo.
Viaj uzantoj ankaŭ devos kontentigi ĉi tiun postulon.</p>
<p>Se Bevy ne funkcias, instalu la plej novajn pelilojn aŭ kontrolu, ĉu Vulkan en via Linuksa
distribuo bezonas pliajn pakaĵojn.</p>
<p>Subteno De OpenGL kaj DirectX 11 por heredaj sistemoj estas planita, sed ankoraŭ ne havebla.</p>
<p>macOS devus funkcii sen speciala pelil-agordo, uzante na Metal.</p>
<p>Retaj ludoj estas subtenataj kaj devus funkcii en iu ajn moderna retumilo, uzante WebGL2.</p>
<h2 id="kreado-de-nova-projekto"><a class="header" href="#kreado-de-nova-projekto">Kreado de Nova Projekto</a></h2>
<p>Vi povas simple krei novan Rust-projekton aŭ pre via Redaktilo, aŭ per la Terminalo:</p>
<pre><code class="language-sh">cargo new --bin mia_ludo
</code></pre>
<p>(ĝi kreas projekton, nomita <code>mia_ludo</code>)</p>
<p>La <code>Cargo.toml</code> dosiero enhavas ĉiu agordaĵon de via projekto. Aldonu la lastan version de <code>bevy</code> kiel dependaĵo. Via dosiero nun aspektas kiel ĉi tio:</p>
<pre><code class="language-toml">[package]
name = &quot;mia_ludo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
bevy = &quot;0.7&quot;
</code></pre>
<p>La <code>src/main.rs</code> estas via ĉefa	fontkoda dosiero. Ĉi tie vi komencas skribi vian Rust-kodon. Por minimuma Bevy-aplikaĵo vi bezonas almenaŭ sekvantan:</p>
<pre><code class="language-rust no_run noplayground">use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre>
<p>Vi povas nun kompili kaj lanĉi vian projekton. Unufoje daŭros iom da tempo, ĉar vi devas kompili tutan Bevy-motoron kaj dependaĵojn. Sekvaj kompiladoj devas esti pli rapidaj. Vi povas ankaŭ fari tion el via Redaktilo aŭ Terminalo:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<h2 id="plia-agordado"><a class="header" href="#plia-agordado">Plia Agordado</a></h2>
<p>Vi verŝajne renkontos kun maluzebla malrapida plenumeco en defaŭltaj neoptimigitaj Rust-konstruaĵoj. <a href="setup//pitfalls/performance.html">Vd. kiel ripari ĉi tion</a></p>
<p>Ankaŭ, ripeta rekompila rapideco estas grava por teni vin produktiva,
tial vi ne devas atendi longe, ke la Rust-kompililo rekompilu vian
projekton ĉiufoje, kiam vi deziras testi vian ludon. <a href="https://bevyengine.org/learn/book/getting-started/setup/">Bevy komencant-paĝo</a> havas konsilon pri kiel plirapidigi kompiltempon.</p>
<p>Ankaŭ vd. <a href="setup//setup/bevy-tools.html">Ellaboriloj kaj Redaktiloj</a> paĝon por sugestoj pri pliaj eksteraj ellaboriloj, kiuj povus esti utilaj.</p>
<h2 id="kio-estas-plu"><a class="header" href="#kio-estas-plu">Kio estas plu?</a></h2>
<p>Vidu <a href="setup//tutorial.html">gviditan instrukcion</a> de ĉi tiu libro kaj <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">oficialajn ekzemplojn</a> de Bevy.</p>
<p>Vizitu la <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.Assets.html">Bevy Valoraĵ-retejon</a> por trovi aliajn lernilojn kaj lern-risurcojn de la komunumo, ankaŭ kromaĵojn por uzi en via projekto.</p>
<p>Aliĝu al la komunumo en <a href="https://discord.gg/bevy">Diskordo</a> por babili kun ni!</p>
<h2 id="Ĉu-vi-havas-problemojn"><a class="header" href="#Ĉu-vi-havas-problemojn">Ĉu vi havas problemojn?</a></h2>
<p>Se io ne funkcias, vizitu <a href="setup//pitfalls.html">Ĝeneralajn Kaptilojn</a> por vidi, ĉu la libro havas ion por helpi vin. Ĝi dokumentas solvadojn al kelkaj el la plej oftaj problemoj, kiujn renkontis membroj de la Bevy-komunumo.</p>
<p>Se vi bezonas helpon, uzu <a href="https://github.com/bevyengine/bevy/discussions">GitHub-diskutojn</a> aŭ vizitu la babilejon kaj demandi por helpo en <a href="https://discord.gg/bevy">Diskordo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-bleeding-edge-bevy-bevy-main"><a class="header" href="#using-bleeding-edge-bevy-bevy-main">Using bleeding-edge Bevy (bevy main)</a></h1>
<p>Bevy development moves very fast, and there are often exciting new things that
are yet unreleased. This page will give you advice about using development
versions of bevy.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>If you are <em>not</em> using any 3rd-party plugins and just want to use the bevy
main development branch:</p>
<pre><code class="language-toml">[dependencies]
bevy = { git = &quot;https://github.com/bevyengine/bevy&quot; }
</code></pre>
<p>However, if you <em>are</em> working with external plugins, you should read the rest
of this page. You will likely need to do more to make everything compatible.</p>
<h2 id="should-you-use-bleeding-edge-bevy"><a class="header" href="#should-you-use-bleeding-edge-bevy">Should you use bleeding-edge Bevy?</a></h2>
<p>Currently, Bevy does not make patch releases (with rare exceptions for
critical bugs), only major releases. The latest release is often missing the
latest bug fixes, usability improvements, and features. It may be compelling
to join in on the action!</p>
<p>If you are new to Bevy, this might not be for you; you might be more
comfortable using the released version. It will have the best compatibility
with community plugins and documentation.</p>
<p>The biggest downside to using unreleased versions of Bevy is 3rd-party plugin
compatibility. Bevy is unstable and breaking changes happen often. However,
many actively-maintained community plugins have branches for tracking the
latest Bevy main branch, although they might not be fully up-to-date. It's
possible that a plugin you want to use does not work with the latest changes
in Bevy main, and you may have to fix it yourself.</p>
<p>The frequent breaking changes might not be a problem for you, though. Thanks
to cargo, you can update bevy at your convenience, whenever you feel ready
to handle any possible breaking changes.</p>
<p>If you choose to use Bevy main, you are highly encouraged to interact with
the Bevy community on <a href="https://discord.gg/bevy">Discord</a> and <a href="https://github.com/bevyengine/bevy">GitHub</a>, so
you can keep track of what's going on, get help, or participate in discussions.</p>
<h2 id="common-pitfall-mysterious-compile-errors"><a class="header" href="#common-pitfall-mysterious-compile-errors">Common pitfall: mysterious compile errors</a></h2>
<p>When changing between different versions of Bevy (say, transitioning an existing
project from the released version to the git version), you might get lots of
strange unexpected build errors.</p>
<p>You can typically fix them by removing <code>Cargo.lock</code> and the <code>target</code> directory:</p>
<pre><code class="language-sh">rm -rf Cargo.lock target
</code></pre>
<p>See <a href="setup//pitfalls/build-errors.html">this page</a> for more info. See this <a href="https://github.com/rust-lang/cargo/issues/9994">cargo
issue</a> about this bug.</p>
<p>If you are still getting errors, it is probably because cargo is trying
to use multiple different versions of bevy in your dependency tree
simultaneously. This can happen if some of the plugins you use have specified
a different Bevy version/commit from your project.</p>
<p>Make sure you use the correct branch of each plugin you depend on, with
support for Bevy main.</p>
<p>If you have issues, they might still be fixable. Read the next section
below for advice on how to configure your project in a way that minimizes
the chances of this happening.</p>
<h2 id="how-to-use-bleeding-edge-bevy"><a class="header" href="#how-to-use-bleeding-edge-bevy">How to use bleeding-edge bevy?</a></h2>
<pre><code class="language-toml">[dependencies]
# recommended: specify a known-working commit hash to pin to
# (specify it in the URL, to make the patch tricks below work)
bevy = { git = &quot;https://github.com/bevyengine/bevy?rev=a420beb0&quot; }

# add any 3rd-party plugins you use, and make sure to use the correct branch
# (alternatively, you could also specify a commit hash, with &quot;rev&quot;)
bevy_thing = { git = &quot;https://github.com/author/bevy_thing?branch=bevy_main&quot; }

# For each plugin we use, patch them to use the same bevy commit as us:

# If they have specified a different commit:
# (you need to figure this out)
[patch.&quot;https://github.com/bevyengine/bevy?rev=146123ea&quot;]
bevy = { git = &quot;https://github.com/bevyengine/bevy?rev=a420beb0&quot; }

# For those that have not specified anything:
[patch.&quot;https://github.com/bevyengine/bevy&quot;]
bevy = { git = &quot;https://github.com/bevyengine/bevy?rev=a420beb0&quot; }
</code></pre>
<p>Some 3rd-party plugins depend on specific bevy sub-crates, rather than the
full bevy. You may additionally have to patch those individually:</p>
<pre><code class="language-toml">[patch.&quot;https://github.com/bevyengine/bevy&quot;]
# specific crates as needed by the plugins you use (check their `Cargo.toml`)
bevy_ecs = { git = &quot;https://github.com/bevyengine/bevy?rev=a420beb0&quot; }
bevy_math = { git = &quot;https://github.com/bevyengine/bevy?rev=a420beb0&quot; }
# ... and so on
</code></pre>
<p>To collect all the information you need, in order to fully patch all your
dependencies, you can either look at their <code>Cargo.toml</code>, or figure it out
by running <code>cargo tree</code> or searching inside your <code>Cargo.lock</code> file for
duplicate entries (multiple copies of bevy crates).</p>
<p>Make sure to delete <code>Cargo.lock</code> every time you make a change to your
dependencies configuration, to force cargo to resolve everything again.</p>
<h2 id="updating-bevy"><a class="header" href="#updating-bevy">Updating Bevy</a></h2>
<p>It is recommended that you specify a known-good Bevy commit in your
<code>Cargo.toml</code>, so that you can be sure that you only update it when you
actually want to do so, avoiding unwanted breakage.</p>
<pre><code class="language-toml">bevy = { git = &quot;https://github.com/bevyengine/bevy?rev=7a1bd34e&quot; }
</code></pre>
<p>Even if you do not, the <code>Cargo.lock</code> file always keeps track of the exact
version (including the git commit) you are working with. You will not be
affected by new changes in upstream bevy or plugins, until you update it.</p>
<p>To update, run:</p>
<pre><code class="language-sh">cargo update
</code></pre>
<p>or delete <code>Cargo.lock</code>.</p>
<p>Make sure you do this every time you change the configuration in your
<code>Cargo.toml</code>. Otherwise you risk errors from cargo not resolving dependencies
correctly.</p>
<h2 id="advice-for-plugin-authors"><a class="header" href="#advice-for-plugin-authors">Advice for plugin authors</a></h2>
<p>If you are publishing a plugin crate, here are some recommendations:</p>
<ul>
<li>Have a separate branch in your repository, to keep support for bevy main
separate from your main version for the released version of bevy</li>
<li>Put information in your README to tell people how to find it</li>
<li>Set up CI to notify you if your plugin is broken by new changes in bevy</li>
</ul>
<p>Feel free to follow all the advice from this page, including cargo patches
as needed. They only apply when you build your project directly, not as a
dependency, so they do not affect your users.</p>
<h3 id="ci-setup"><a class="header" href="#ci-setup">CI Setup</a></h3>
<p>Here is an example for GitHub Actions. This will run at 8:00 AM (UTC) every day
to verify that your code still compiles. GitHub will notify you when it fails.</p>
<pre><code class="language-yaml">name: check if code still compiles

on:
  schedule:
    - cron: '0 8 * * *'

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Install Dependencies
        run: sudo apt-get update &amp;&amp; sudo apt-get install --no-install-recommends pkg-config libx11-dev libasound2-dev libudev-dev

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Check code
        run: cargo update &amp;&amp; cargo check --lib --examples
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-editor--ide"><a class="header" href="#text-editor--ide">Text Editor / IDE</a></h1>
<p>This page contains tips for different text editors and IDEs.</p>
<p>Bevy is, for the most part, like any other Rust project. If your editor/IDE
is set up for Rust, that might be all you need. This page contains additional
information that may be useful for Bevy specifically.</p>
<p>Please help improve this page by providing suggestions for things to add.</p>
<h2 id="cargo_manifest_dir"><a class="header" href="#cargo_manifest_dir"><code>CARGO_MANIFEST_DIR</code></a></h2>
<p>When running your app/game, Bevy will search for the <code>assets</code> folder in
the path specified in the <code>CARGO_MANIFEST_DIR</code> environment variable. This
allows <code>cargo run</code> to work correctly from the terminal.</p>
<p>If you are using your editor/IDE to run your project in a non-standard way
(say, inside a debugger), you have to be sure to set that correctly.</p>
<h2 id="vscode"><a class="header" href="#vscode">VSCode</a></h2>
<p>Here is a snippet showing how to create a run configuration for debugging Bevy
(with lldb):</p>
<p>(this is for development on Bevy itself, and testing with the <code>breakout</code> example)</p>
<p>(adapt to your needs if using for your project)</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;lldb&quot;,
    &quot;request&quot;: &quot;launch&quot;,
    &quot;name&quot;: &quot;Debug example 'breakout'&quot;,
    &quot;cargo&quot;: {
        &quot;args&quot;: [
            &quot;build&quot;,
            &quot;--example=breakout&quot;,
            &quot;--package=bevy&quot;
        ],
        &quot;filter&quot;: {
            &quot;name&quot;: &quot;breakout&quot;,
            &quot;kind&quot;: &quot;example&quot;
        }
    },
    &quot;args&quot;: [],
    &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
    &quot;env&quot;: {
        &quot;CARGO_MANIFEST_DIR&quot;: &quot;${workspaceFolder}&quot;,
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dev-tools-and-editors-for-bevy"><a class="header" href="#dev-tools-and-editors-for-bevy">Dev Tools and Editors for Bevy</a></h1>
<p>Bevy does not yet have an official editor or other such tools. An official
editor is planned as a long-term future goal. In the meantime, here are
some community-made tools to help you.</p>
<hr />
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy-inspector-egui"><code>bevy_inspector_egui</code></a>
gives you a simple editor-like property inspector window in-game. It lets
you modify the values of your components and resources in real-time as the
game is running.</p>
<p><a href="https://github.com/jakobhellermann/bevy_editor_pls"><code>bevy_editor_pls</code></a>
is an editor-like interface that you can embed into your game. It has even
more features, like switching app states, fly camera, performance diagnostics,
and inspector panels.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy_mod_debugdump"><code>bevy_mod_debugdump</code></a>
is a tool to help visualize your <a href="setup/../programming/app-builder.html">App Schedule</a>
(all of the registered <a href="setup/../programming/systems.html">systems</a> with
their <a href="setup/../programming/system-order.html">ordering dependencies</a> and
<a href="setup/../programming/stages.html">stages</a>), and the Bevy Render Graph.</p>
<p><a href="https://github.com/MinerSebas/bevy_lint"><code>bevy_lint</code></a> is a linter (based on
<code>dylint</code>) that can automatically check your Bevy code for some common issues.</p>
<p>If you are getting confusing/cryptic compiler error messages (like
<a href="setup/../pitfalls/into-system.html">these</a>) and you cannot figure them out,
<a href="https://github.com/jakobhellermann/bevycheck"><code>bevycheck</code></a> is a tool you
could use to help diagnose them. It tries to provide more user-friendly
Bevy-specific error messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community-plugins-ecosystem"><a class="header" href="#community-plugins-ecosystem">Community Plugins Ecosystem</a></h1>
<p>There is a growing ecosystem of unofficial community-made plugins for Bevy.
They provide a lot of functionality that is not officially included with the
engine. You might greatly benefit from using some of these in your projects.</p>
<p>To find such plugins, you should search the <a href="https://bevyengine.org/assets">Bevy Assets</a>
page on the official Bevy website. This is the official registry of known
community-made things for Bevy. If you publish your own plugins for Bevy,
you should <a href="https://github.com/bevyengine/bevy-assets">contribute a link to be added to that page</a>.</p>
<p>Please beware that some 3rd-party plugins may use unusual licenses. Be sure
to check the license before using a plugin in your project.</p>
<hr />
<p>Other pages in this book with valuable information when using 3rd-party plugins:</p>
<ul>
<li>Some plugins may require you to <a href="setup//setup/bevy-config.html">configure Bevy in some specific way</a>.</li>
<li>If you are <a href="setup//setup/bevy-git.html">using bleeding-edge unreleased Bevy (main)</a>, you may encounter difficulties with plugin compatibility.</li>
</ul>
<h2 id="plugin-recommendations"><a class="header" href="#plugin-recommendations">Plugin Recommendations</a></h2>
<p>This here is my personal, curated, opinionated list of recommendations,
featuring the most important plugins (in my opinion) in the Bevy ecosystem.</p>
<p>My goal here is to help direct new Bevy users to some known-good resources,
so you can start working on the kinds of games you want to make. :)</p>
<p>The plugins listed here are compatible with the current Bevy release and use
permissive licenses (like Bevy itself).</p>
<p>This page is limited. I can only recommend plugins I know enough about. Please
also check the <a href="https://bevyengine.org/assets">Bevy Assets</a> page to find even more things. :)</p>
<h3 id="development-tools-and-editors"><a class="header" href="#development-tools-and-editors">Development Tools and Editors</a></h3>
<p><a href="setup//setup/bevy-tools.html">These are listed on a separate page.</a></p>
<h3 id="code-helpers"><a class="header" href="#code-helpers">Code Helpers</a></h3>
<p><a href="https://github.com/NiklasEi/bevy_asset_loader"><code>bevy_asset_loader</code></a> is a more flexible and
opinionated helper for managing and loading [assets][cb::assets]. Uses custom
syntax to let you declare your assets more conveniently.</p>
<p><a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a> provides alternative improved
implementations of <a href="setup//programming/states.html">states</a>, <a href="setup//programming/run-criteria.html">run criteria</a>,
and <a href="setup//features/fixed-timestep.html">fixed timestep</a>, that do not suffer from the major
usability limitations of the ones provided with Bevy.</p>
<h3 id="input-mappings"><a class="header" href="#input-mappings">Input Mappings</a></h3>
<p>To help with your game's <a href="setup//input.html">input handling</a> needs, try the
<a href="https://github.com/leafwing-studios/leafwing-input-manager">Input Manager plugin by Leafwing Studios</a>. It is a very
flexible way to handle your game's bindings / mappings.</p>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<p>Use <a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a> instead of the built-in <code>bevy_audio</code>.</p>
<p>The built-in audio is very limited in features, and you are likely going to
need this plugin for pretty much any game with audio.</p>
<p>See <a href="setup//features/audio.html">this page</a> for help on how to set it up.</p>
<h3 id="camera"><a class="header" href="#camera">Camera</a></h3>
<p><a href="https://github.com/BlackPhlox/bevy_config_cam"><code>bevy_config_cam</code></a> is a nice plugin for easily
adding camera controls to your Bevy 3D project. It gives you a a choice
of various common camera behaviors (like follow, top-view, FPS-style,
free-roaming).</p>
<p>Cameras are something that can be very game-specific. As you progress with
your project, you would probably want to implement your own custom camera
control logic for your game. However, this plugin is amazing when you are
starting out on a new project.</p>
<h3 id="tilemap"><a class="header" href="#tilemap">Tilemap</a></h3>
<p>If you are making a 2D game based on a tile-map, there are plugins to
help do it efficiently with high performance. It is better to use one
of these plugins, instead of just spawning lots of individual Bevy
sprites for each tile.</p>
<p><a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>:</p>
<ul>
<li>Uses one ECS Entity per tile, lets you work with the tilemap in an ECS-idiomatic way.</li>
<li>Very efficient rendering, using techniques like texture arrays, chunks, morton encoding, …</li>
<li>Lots of features: Square/Hexagon/Isometric grids, animation, layers, chunks, …</li>
</ul>
<p>[<code>bevy_ecs_ldtk</code>][project::bevy_ecs_ldtk] implements loading of
entire maps/levels created with the LDTK editor, into Bevy. Based on
<code>bevy_ecs_tilemap</code> internally, for efficient performance.</p>
<h3 id="shapes--vector-graphics--canvas"><a class="header" href="#shapes--vector-graphics--canvas">Shapes / Vector Graphics / Canvas</a></h3>
<p>If you want to draw 2D shapes, use the <a href="https://github.com/Nilirad/bevy_prototype_lyon"><code>bevy_prototype_lyon</code></a> plugin.</p>
<h3 id="game-ai"><a class="header" href="#game-ai">Game AI</a></h3>
<p><a href="https://github.com/zkat/big-brain"><code>big-brain</code></a> is a plugin for game AI behaviors (Utility AI).</p>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<p>There are a few alternatives to Bevy UI available.</p>
<p><a href="https://github.com/mvlabat/bevy_egui"><code>bevy_egui</code></a> integrates the <a href="https://github.com/emilk/egui"><code>egui</code>
toolkit</a> into Bevy. It is a mature immediate-mode GUI library
(like the popular Dear Imgui, but in Rust). It is very feature-rich and
provides lots of widgets. It was not really designed for making flashy
gamey UIs (though it may very well be fine for your game). It's great for
editor-like UIs, debug UIs, or non-game applications.</p>
<p><a href="https://github.com/StarArawn/kayak_ui"><code>kayak_ui</code></a> is a new experimental game-centric UI library
for Bevy, which uses a XML-like declarative syntax for constructing UIs.</p>
<p><a href="https://github.com/TheRawMeatball/ui4"><code>ui4</code></a> is another notable experimental UI library for Bevy.</p>
<h4 id="ui-navigation"><a class="header" href="#ui-navigation">UI Navigation</a></h4>
<p>If you are using the builtin Bevy UI, there is a nice plugin available
for navigation (moving between buttons and other focusable UI elements):
<a href="https://github.com/nicopap/ui-navigation"><code>bevy-ui-navigation</code></a>.</p>
<h3 id="physics"><a class="header" href="#physics">Physics</a></h3>
<p>Bevy can integrate with the <a href="https://rapier.rs/">Rapier physics engine</a>.</p>
<p>There are two plugins you can choose from:</p>
<ul>
<li><a href="https://github.com/jcornaz/heron"><code>heron</code></a>
<ul>
<li>Idiomatic to Bevy. Nice user-friendly integration and workflow.</li>
<li>Likely to be easier to use and more intuitive than <code>bevy_rapier</code>.</li>
<li>May have more limited functionality.</li>
</ul>
</li>
<li><a href="https://github.com/dimforge/bevy_rapier"><code>bevy_rapier</code></a>
<ul>
<li>This is a &quot;raw&quot; plugin that gives you direct access to Rapier.</li>
<li>Gives you the most control, but may be hard to use and not idiomatic-Bevy.</li>
<li>You will probably need to read a lot of documentation, harder to learn.</li>
</ul>
</li>
</ul>
<h3 id="animation"><a class="header" href="#animation">Animation</a></h3>
<p>Starting from Bevy 0.7, there is built-in support for playing predefined
asset-driven animations, including 3D skeletal animation.</p>
<p>However, for &quot;programmatic&quot; / code-driven animation, you may need something
else. Try <a href="https://github.com/djeedai/bevy_tweening"><code>bevy_tweening</code></a>. This might be good
enough for moving objects around, moving the camera, smoothly changing colors,
or other such transitions.</p>
<p>For animated 2D sprites, try <a href="https://github.com/jcornaz/benimator"><code>benimator</code></a>. This is
for using sprite-sheet assets with many frames of animation.</p>
<h3 id="file-formats-1"><a class="header" href="#file-formats-1">File Formats</a></h3>
<p>Additional asset loaders, for loading assets from file formats other than
<a href="setup//builtins.html#file-formats">those that Bevy officially supports</a>.</p>
<ul>
<li>Wavefront OBJ 3D models: <a href="https://github.com/AmionSky/bevy_obj"><code>bevy_obj</code></a></li>
<li>STL 3D models: <a href="https://github.com/nilclass/bevy_stl"><code>bevy_stl</code></a></li>
<li>MagicaVoxel VOX: <a href="https://github.com/erasin/bevy_vox"><code>bevy_vox</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-bevy"><a class="header" href="#configuring-bevy">Configuring Bevy</a></h1>
<p>Bevy is very modular and configurable. It is implemented as many separate
cargo crates, allowing you to remove the parts you don't need. Higher-level
functionality is built on top of lower-level foundational crates, and can
be disabled or replaced with alternatives.</p>
<p>The lower-level core crates (like the Bevy ECS) can also be used completely
standalone, or integrated into otherwise non-Bevy projects.</p>
<h2 id="bevy-cargo-features"><a class="header" href="#bevy-cargo-features">Bevy Cargo Features</a></h2>
<p>In Bevy projects, you can enable/disable various parts of Bevy using cargo features.</p>
<p>Many common features are enabled by default. If you want to disable some of
them, note that, unfortunately, Cargo does not let you disable individual
default features, so you need to disable all default bevy features and
re-enable the ones you need.</p>
<p>Here is how you might configure your Bevy:</p>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.7&quot;
# Disable the default features if there are any that you do not want
default-features = false
features = [
  # These are the default features:
  # (re-enable whichever you like)

  # Bevy functionality:
  &quot;animation&quot;,          # Animation support
  &quot;bevy_gilrs&quot;,         # Gamepad input support
  &quot;bevy_audio&quot;,         # Builtin audio
  &quot;bevy_winit&quot;,         # Window management
  &quot;x11&quot;,                # Linux: Support X11 windowing system
  &quot;filesystem_watcher&quot;, # Asset hot-reloading
  &quot;render&quot;,             # Graphics Rendering

  ## &quot;render&quot; actually just includes:
  ## (feel free to use just a subset of these, instead of &quot;render&quot;)
  &quot;bevy_render&quot;,        # Rendering framework core
  &quot;bevy_core_pipeline&quot;, # Higher-level rendering abstractions
  &quot;bevy_sprite&quot;,        # 2D (sprites) rendering
  &quot;bevy_pbr&quot;,           # 3D (physically-based) rendering
  &quot;bevy_gltf&quot;,          # GLTF 3D assets format support
  &quot;bevy_text&quot;,          # Text/font rendering
  &quot;bevy_ui&quot;,            # UI toolkit

  # File formats:
  &quot;png&quot;,
  &quot;hdr&quot;,
  &quot;vorbis&quot;,

  # These are other features that may be of interest:
  # (add any of these that you need)

  # Bevy functionality:
  &quot;wayland&quot;,              # Linux: Support Wayland windowing system
  &quot;subpixel_glyph_atlas&quot;, # Subpixel antialiasing for text/fonts
  &quot;serialize&quot;,            # Support for `serde` Serialize/Deserialize

  # File formats:
  &quot;ktx2&quot;, # preferred format for GPU textures
  &quot;dds&quot;,
  &quot;jpeg&quot;,
  &quot;bmp&quot;,
  &quot;tga&quot;,
  &quot;basis-universal&quot;,
  &quot;zstd&quot;, # needed if using zstd in KTX2 files
  &quot;flac&quot;,
  &quot;mp3&quot;,
  &quot;wav&quot;,

  # Development/Debug features:
  &quot;dynamic&quot;,      # Dynamic linking for faster compile-times
  &quot;trace&quot;,        # Enable tracing for performance measurement
  &quot;trace_tracy&quot;,  # Tracing using `tracy`
  &quot;trace_chrome&quot;, # Tracing using the Chrome format
  &quot;wgpu_trace&quot;,   # WGPU/rendering tracing
]
</code></pre>
<p>(See <a href="https://docs.rs/crate/bevy/0.7.0/features">here</a> for a full list of Bevy's cargo features.)</p>
<h3 id="graphics--rendering"><a class="header" href="#graphics--rendering">Graphics / Rendering</a></h3>
<p>For a graphical application or game (most Bevy projects), you can include
<code>render</code> and <code>bevy_winit</code>. For <a href="setup//platforms/linux.html">Linux</a> support, you need
at least one of <code>x11</code> or <code>wayland</code>.</p>
<p>However, <code>render</code> is a meta-feature; it simply enables all the graphics-related
features of Bevy. If you want, you can strip it down and include only what
you need.</p>
<p><code>bevy_render</code> and <code>bevy_core_pipeline</code> are required for any application using
Bevy rendering.</p>
<p>If you only need 2D and no 3D, add <code>bevy_sprite</code>.</p>
<p>If you only need 3D and no 2D, add <code>bevy_pbr</code>. If you are <a href="setup//features/gltf.html">loading 3D models
from GLTF files</a>, add <code>bevy_gltf</code>.</p>
<p>If you are using Bevy UI, you need <code>bevy_text</code> and <code>bevy_ui</code>.</p>
<p>If you don't need any graphics (like for a dedicated game server, scientific
simulation, etc.), you may remove all of these features.</p>
<h3 id="audio-1"><a class="header" href="#audio-1">Audio</a></h3>
<p>Bevy's audio is very limited in functionality. It is recommended that you
use the <a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a> plugin instead. Disable
<code>bevy_audio</code> and <code>vorbis</code>.</p>
<p>See <a href="setup//features/audio.html">this page</a> for more information.</p>
<h3 id="file-formats-2"><a class="header" href="#file-formats-2">File Formats</a></h3>
<p>You can use the relevant cargo features to enable/disable support for loading
assets with various different file formats.</p>
<p>See <a href="setup//builtins.html#file-formats">here</a> for more information.</p>
<h3 id="input-devices"><a class="header" href="#input-devices">Input Devices</a></h3>
<p>If you do not care about <a href="setup//input/gamepad.html">gamepad (controller/joystick)</a>
support, you can disable <code>bevy_gilrs</code>.</p>
<h3 id="linux-windowing-backend"><a class="header" href="#linux-windowing-backend">Linux Windowing Backend</a></h3>
<p>On <a href="setup//platforms/linux.html">Linux</a>, you can choose to support X11, Wayland,
or both. Only <code>x11</code> is enabled by default, as it is the legacy system
that should be compatible with most/all distributions, to make your builds
smaller and compile faster. You might want to additionally enable <code>wayland</code>,
to fully and natively support modern Linux environments. This will add a few
extra transitive dependencies to your project.</p>
<h3 id="asset-hot-reloading"><a class="header" href="#asset-hot-reloading">Asset hot-reloading</a></h3>
<p>The <code>filesystem_watcher</code> feature controls support for <a href="setup//assets/hot-reload.html">hot-reloading of
assets</a>, supported on desktop platforms.</p>
<h3 id="development-features"><a class="header" href="#development-features">Development Features</a></h3>
<p>While you are developing your project, these features might be useful:</p>
<h4 id="dynamic-linking"><a class="header" href="#dynamic-linking">Dynamic Linking</a></h4>
<p><code>dynamic</code> causes Bevy to be built and linked as a shared/dynamic library.
This will make incremental builds <em>much</em> faster.</p>
<p>This is only supported on desktop platforms. Known to work very well on Linux,
Windows/macOS should work, but might have issues.</p>
<p>Do not enable this for release builds you intend to publish to other people;
it introduces unneeded complexity (you need to bundle extra files) and
potential for things to not work correctly. Use this only during development.</p>
<p>For this reason, it may be convenient to specify the feature as a commandline
option to cargo, instead of putting it in your <code>Cargo.toml</code>. Simply run your
project like this:</p>
<pre><code class="language-sh">cargo run --features bevy/dynamic
</code></pre>
<h4 id="tracing"><a class="header" href="#tracing">Tracing</a></h4>
<p>The features <code>trace</code> and <code>wgpu_trace</code> may be useful for profiling and
diagnosing performance issues.</p>
<p><code>trace_chrome</code> and <code>trace_tracy</code> choose the backend you want to use to
visualize the traces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h1>
<p>This chapter covers some common issues or surprises that you might be
likely to encounter when working with Bevy, with specific advice about how
to address them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strange-build-errors"><a class="header" href="#strange-build-errors">Strange Build Errors</a></h1>
<p>Sometimes, you can get strange and confusing build errors when trying to
compile your project.</p>
<h2 id="update-your-rust"><a class="header" href="#update-your-rust">Update your Rust</a></h2>
<p>First, make sure your Rust is up-to-date. When using Bevy, you must use at
least the latest stable version of Rust (or nightly).</p>
<p>If you are using <a href="https://rustup.rs"><code>rustup</code></a> to manage your Rust installation, you
can run:</p>
<pre><code class="language-shell">rustup update
</code></pre>
<h2 id="clear-the-cargo-state"><a class="header" href="#clear-the-cargo-state">Clear the cargo state</a></h2>
<p>Many kinds of build errors can often be fixed by forcing <code>cargo</code> to regenerate
its internal state (recompute dependencies, etc.). You can do this by deleting
the <code>Cargo.lock</code> file and the <code>target</code> directory.</p>
<pre><code class="language-shell">rm -rf target Cargo.lock
</code></pre>
<p>Try building your project again after doing this. It is likely that the
mysterious errors will go away.</p>
<p>This trick often fixes the broken build, but if it doesn't help you,
your issue might require further investigation. Reach out to the Bevy
community via GitHub or <a href="https://discord.gg/bevy">Discord</a>, and ask for help.</p>
<p>If you are using bleeding-edge Bevy (&quot;main&quot;), and the above does not solve
the problem, your errors might be caused by 3rd-party plugins. See <a href="pitfalls/../setup/bevy-git.html#how-to-use-bleeding-edge-bevy">this
page</a> for solutions.</p>
<h2 id="new-cargo-resolver"><a class="header" href="#new-cargo-resolver">New Cargo Resolver</a></h2>
<p>Cargo recently added a new dependency resolver algorithm, that is incompatible
with the old one. Bevy <em>requires</em> the new resolver.</p>
<p>If you are just creating a new blank Cargo project, don't worry. This should
already be setup correctly by <code>cargo new</code>.</p>
<p>If you are getting weird compiler errors from Bevy dependencies, read on. Make sure
you have the correct configuration, and then <a href="pitfalls//pitfalls/build-errors.html#clear-the-cargo-state">clear the cargo state</a>.</p>
<h3 id="single-crate-projects"><a class="header" href="#single-crate-projects">Single-Crate Projects</a></h3>
<p>In a single-crate project (if you only have one <code>Cargo.toml</code> file in your project),
if you are using the latest Rust2021 Edition, the new resolver is automatically
enabled.</p>
<p>So, you need either one of these settings in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
edition = &quot;2021&quot;
</code></pre>
<p>or</p>
<pre><code class="language-toml">[package]
resolver = &quot;2&quot;
</code></pre>
<h3 id="multi-crate-workspaces"><a class="header" href="#multi-crate-workspaces">Multi-Crate Workspaces</a></h3>
<p>In a multi-crate Cargo workspace, the resolver is a global setting for the
whole workspace. It will <em>not</em> be enabled by default.</p>
<p>This can bite you if you are transitioning a single-crate project into a workspace.</p>
<p>You <em>must</em> add it manually to the top-level <code>Cargo.toml</code> for your Cargo Workspace:</p>
<pre><code class="language-toml">[workspace]
resolver = &quot;2&quot;
</code></pre>
<hr />
<h2 id="what-errors"><a class="header" href="#what-errors">What errors?</a></h2>
<p>One common example is the &quot;failed to select a version&quot; error, which can
look something like this:</p>
<pre><code>error: failed to select a version for `web-sys`.
    ... required by package `wgpu v0.9.0`
    ... which is depended on by `bevy_wgpu v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_internal v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy-scratchpad v0.1.0 (C:\Users\Alice\Documents\bevy-scratchpad)`
versions that meet the requirements `=0.3.50` are: 0.3.50

all possible versions conflict with previously selected packages.

  previously selected package `web-sys v0.3.46`
    ... which is depended on by `bevy_app v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_asset v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_audio v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_internal v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy-scratchpad v0.1.0 (C:\Users\Alice\Documents\bevy-scratchpad)`

failed to select a version for `web-sys` which could resolve this conflict
</code></pre>
<p>(there are many variations, yours might not be identical to the example above)</p>
<p>Another related error are seemingly-nonsensical compiler messages about
conflicts with Bevy's internal types (like &quot;expected type <code>Transform</code>,
found type <code>Transform</code>&quot;).</p>
<h2 id="why-does-this-happen"><a class="header" href="#why-does-this-happen">Why does this happen?</a></h2>
<p>Such errors are often caused by <code>cargo</code>'s internal state being broken. Usually,
it is because of dependencies not being resolved properly, causing cargo to
try to link multiple versions of Bevy into your project. This often occurs when
transitioning your project between the release and the git version of Bevy. Cargo
remembers the versions it was previously using, and gets confused.</p>
<p>See this <a href="https://github.com/rust-lang/cargo/issues/9994">cargo issue</a> about this bug. If you have any interesting
information to add, you can help by contributing to that issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<h2 id="unoptimized-debug-builds"><a class="header" href="#unoptimized-debug-builds">Unoptimized debug builds</a></h2>
<p>You can enable compiler optimizations in debug/dev mode!</p>
<p>Even <code>opt-level=1</code> is enough to make Bevy not painfully slow! You can also
enable higher optimizations for dependencies, but not your own code, to keep
recompilations fast!</p>
<pre><code class="language-toml"># in `Cargo.toml` or `.cargo/config.toml`

# Enable only a small amount of optimization in debug mode
[profile.dev]
opt-level = 1

# Enable high optimizations for dependencies (incl. Bevy), but not for our code:
[profile.dev.package.&quot;*&quot;]
opt-level = 3

</code></pre>
<h3 id="why-is-this-necessary"><a class="header" href="#why-is-this-necessary">Why is this necessary?</a></h3>
<p>Rust without compiler optimizations is <em>very slow</em>. With Bevy in
particular, the default cargo build debug settings will lead to <em>awful</em> runtime
performance. Assets are slow to load and FPS is low.</p>
<p>Common symptoms:</p>
<ul>
<li>Loading high-res 3D models with a lot of large textures, from GLTF
files, can take minutes! This can trick you into thinking
that your code is not working, because you will not see anything on
the screen until it is ready.</li>
<li>After spawning even a few 2D sprites or 3D models, framerate may drop
to unplayable levels.</li>
</ul>
<h3 id="why-not-use---release"><a class="header" href="#why-not-use---release">Why not use <code>--release</code>?</a></h3>
<p>You may have heard the advice: just run with <code>--release</code>! However, this is
bad advice. Don't do it.</p>
<p>Release mode also disables &quot;debug assertions&quot;: extra checks useful during
development. Many libraries also include additional stuff under that
setting. In Bevy and WGPU that includes validation for shaders and GPU API
usage. Release mode disables these checks, causing less-informative crashes,
issues with hot-reloading, or potentially buggy/invalid logic going unnoticed.</p>
<p>Release mode also makes incremental recompilation slow. That negates
Bevy's fast compile times, and can be very annoying while you develop.</p>
<hr />
<p>With the advice at the top of this page, you don't need to build with
<code>--release</code>, just to test your game with adequate performance. You can use
it for <em>actual</em> release builds that you send to your users.</p>
<p>If you want, you can also enable LTO (Link-Time-Optimization) for the actual
release builds, to squeeze out even more performance at the cost of very
slow compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = &quot;thin&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-adding-function-as-system"><a class="header" href="#error-adding-function-as-system">Error adding function as system</a></h1>
<p>You can sometimes get confusing arcane compiler errors when you try to add
systems to your Bevy app.</p>
<p>The errors can look like this:</p>
<pre><code>the trait bound `for&lt;'r, 's, 't0&gt; fn(bevy::prelude::Query&lt;'r, 's, (&amp;'t0 Param)) {my_system}: IntoSystem&lt;(), (), _&gt;` is not satisfied
</code></pre>
<p>This is caused by your function having incompatible parameters. Bevy can
only accept special types as system parameters.</p>
<p>You might also errors that look like this:</p>
<pre><code>the trait bound `Component: WorldQuery` is not satisfied
the trait `WorldQuery` is not implemented for `Component`
</code></pre>
<pre><code>this struct takes at most 2 type arguments but 3 type arguments were supplied
</code></pre>
<p>These errors are caused by a malformed query.</p>
<h2 id="common-beginner-mistakes"><a class="header" href="#common-beginner-mistakes">Common beginner mistakes</a></h2>
<ul>
<li>Using <code>&amp;mut Commands</code> (bevy 0.4 syntax) instead of <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>.</li>
<li>Using <code>Query&lt;MyStuff&gt;</code> instead of <code>Query&lt;&amp;MyStuff&gt;</code> or <code>Query&lt;&amp;mut MyStuff&gt;</code>.</li>
<li>Using <code>Query&lt;&amp;ComponentA, &amp;ComponentB&gt;</code> instead of <code>Query&lt;(&amp;ComponentA, &amp;ComponentB)&gt;</code>
(forgetting the tuple)</li>
<li>Using your resource types directly without <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res</code></a> or <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>.</li>
<li>Using your component types directly without putting them in a <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a>.</li>
<li>Using other arbitrary types in your function.</li>
</ul>
<p>Note that <code>Query&lt;Entity&gt;</code> is correct, because the Entity ID is special;
it is not a component.</p>
<h2 id="supported-types"><a class="header" href="#supported-types">Supported types</a></h2>
<p>Only the following types are supported as system parameters:</p>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/trait.SystemParam.html#implementors">(List in API Docs)</a></p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>:
Manipulate the ECS using <a href="pitfalls//programming/commands.html">commands</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>:
Shared access to a <a href="pitfalls//programming/res.html">resource</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>:
Exclusive (mutable) access to a <a href="pitfalls//programming/res.html">resource</a></li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code>:
Shared access to a resource that may not exist</li>
<li><code>Option&lt;ResMut&lt;T&gt;&gt;</code>:
Exclusive (mutable) access to a resource that may not exist</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Query.html"><code>Query&lt;T, F = ()&gt;</code></a> (can contain tuples of up to 15 types):
Access to <a href="pitfalls//programming/ec.html">entities and components</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet</code></a> (with up to 8 params):
Resolve [conflicts between incompatible system parameters][cb::paramset]</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="pitfalls//programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>:
Receive <a href="pitfalls//programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>:
Send <a href="pitfalls//programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a>:
<a href="pitfalls//programming/removal-detection.html">Removal detection</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a>:
Shared access to <a href="pitfalls//programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>:
Mut access to <a href="pitfalls//programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a>:
Read-only <a href="pitfalls//programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/entity/struct.Entities.html"><code>Entities</code></a>:
Low-level ECS metadata: All entities</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/component/struct.Components.html"><code>Components</code></a>:
Low-level ECS metadata: All components</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/bundle/struct.Bundles.html"><code>Bundles</code></a>:
Low-level ECS metadata: All bundles</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/archetype/struct.Archetypes.html"><code>Archetypes</code></a>:
Low-level ECS metadata: All archetypes</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.SystemChangeTick.html"><code>SystemChangeTick</code></a>:
Low-level ECS metadata: Tick used for change detection</li>
<li>tuples containing any of these types, with up to 16 members</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-cant-see-my-ui"><a class="header" href="#i-cant-see-my-ui">I can't see my UI!</a></h1>
<p>If you are trying to build a UI, but it is not showing on the screen, you
probably forgot to spawn a UI Camera. The UI Camera is required for Bevy to
render UI.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn_bundle(UiCameraBundle::default());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d-objects-not-displaying"><a class="header" href="#2d-objects-not-displaying">2D objects not displaying</a></h1>
<p>Bevy's 2D <a href="pitfalls//features/coords.html">coordinate space</a> is set up so that your background
can be at Z=0.0, and other sprite layers can be at positive +Z coordinates
above that.</p>
<p>Therefore, to see your scene, the camera needs to be placed far away, at a
large +Z coordinate, looking towards -Z.</p>
<p>If you are overriding the camera <a href="pitfalls//features/transforms.html">transform</a> / creating your
own transform, <em>you need to do this!</em> The default transform (with Z=0.0)
will place the camera so that your sprites (at positive +Z coordinates)
would be behind the camera, and you wouldn't see them! You need to
either set a large Z coordinate, or preserve/copy the Z value from the
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> that is generated by Bevy's builtin Bundle
constructor (<code>OrthographicCameraBundle::new_2d()</code>).</p>
<p>By default, when you create a 2D camera using Bevy's built-in Bundle
constructor (<code>OrthographicCameraBundle::new_2d()</code>), Bevy sets the camera
<code>Transform</code> to have Z=999.9. This is close to the default clipping plane
(visible range of Z axis), which is set to 1000.0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3d-objects-not-displaying"><a class="header" href="#3d-objects-not-displaying">3D objects not displaying</a></h1>
<p>This page will list some common issues that you may encounter, if you are
trying to spawn a 3D object, but cannot see it on the screen.</p>
<h2 id="missing-vertex-attributes"><a class="header" href="#missing-vertex-attributes">Missing Vertex Attributes</a></h2>
<p>Make sure your <a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> includes all vertex attributes required
by your shader/material.</p>
<p>Bevy's default PBR <a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
requires all meshes to have:</p>
<ul>
<li>Positions</li>
<li>Normals</li>
<li>UVs (even if there are no textures / just a solid color)</li>
<li>Tangents (if using normal maps, otherwise not required)</li>
</ul>
<p>If you are generating your own mesh data, make sure to include all of the
above.</p>
<p>If you are loading it from asset files, make sure they include everything
that is needed. In particular, if you are using normal maps, make sure
to include Tangents when creating your GLTF files.</p>
<h2 id="incorrect-usage-of-bevy-gltf-assets"><a class="header" href="#incorrect-usage-of-bevy-gltf-assets">Incorrect usage of Bevy GLTF assets</a></h2>
<p>Refer to the <a href="pitfalls//features/gltf.html">GLTF page</a> to learn how to correctly
use GLTF with Bevy.</p>
<p>GLTF files are complex. They contain many sub-assets, represented by
different Bevy types. Make sure you are using the correct thing.</p>
<p>Make sure you are spawning a GLTF Scene, or using the correct
<a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
associated with the correct GLTF Primitive.</p>
<p>If you are using an asset path, be sure to include a label for the sub-asset you want:</p>
<pre><code class="language-rust no_run noplayground">asset_server.load(&quot;my.gltf#Scene0&quot;);
</code></pre>
<p>If you are spawning the top-level <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="pitfalls//features/gltf.html#gltf-master-asset">master asset</a>, it won't work.</p>
<p>If you are spawning a GLTF Mesh, it won't work.</p>
<h2 id="unsupported-gltf"><a class="header" href="#unsupported-gltf">Unsupported GLTF</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
<li>Bevy's renderer requires all meshes/primitives to have per-vertex positions,
UVs, and normals. Make sure all of this data is included.</li>
<li>Meshes/primitives without textures (if the material is just a solid color)
must still include UVs regardless. Bevy will not render meshes without UVs.</li>
<li>When using normal maps in your material, tangents must also be included in the mesh.
Assets with normal maps but without tangents are valid; other software would
typically autogenerate the tangents if they are missing, but Bevy does not support
this yet. Be sure to tick the checkbox for including tangents when exporting.</li>
<li>Spot lights are not supported. Bevy currently only has Point lights and Directional lights.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<h2 id="unoptimized--debug-builds"><a class="header" href="#unoptimized--debug-builds">Unoptimized / Debug builds</a></h2>
<p>Maybe your asset just takes a while to load? Bevy is very slow without
compiler optimizations. It's actually possible that complex GLTF files with
big textures can take over a minute to load and show up on the screen. It
would be almost instant in optimized builds. <a href="pitfalls//pitfalls/performance.html">See here</a>.</p>
<h2 id="vertex-order-and-culling"><a class="header" href="#vertex-order-and-culling">Vertex Order and Culling</a></h2>
<p>By default, the Bevy renderer assumes Counter-Clockwise vertex order and has
back-face culling enabled.</p>
<p>If you are generating your <a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> from code, make sure your
vertices are in the correct order.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrow-multiple-fields-from-struct"><a class="header" href="#borrow-multiple-fields-from-struct">Borrow multiple fields from struct</a></h1>
<p>When you have a <a href="pitfalls//programming/ec.html#components">component</a> or <a href="pitfalls//programming/res.html">resource</a>, that is
larger struct with multiple fields, sometimes you want to borrow several of
the fields at the same time, possibly mutably.</p>
<pre><code class="language-rust no_run noplayground">struct MyThing {
    a: Foo,
    b: Bar,
}

fn my_system(mut q: Query&lt;&amp;mut MyThing&gt;) {
    for thing in q.iter_mut() {
        helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    }
}

fn helper_func(foo: &amp;Foo, bar: &amp;mut Bar) {
    // do something
}
</code></pre>
<p>This can result in a compiler error about conflicting borrows:</p>
<pre><code>error[E0502]: cannot borrow `thing` as mutable because it is also borrowed as immutable
    |
    |         helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    |         -----------  -----         ^^^^^ mutable borrow occurs here
    |         |            |
    |         |            immutable borrow occurs here
    |         immutable borrow later used by call
</code></pre>
<p>The solution is to use the &quot;reborrow&quot; idiom, a common but non-obvious trick in Rust programming:</p>
<pre><code class="language-rust no_run noplayground">        // add this at the start of the for loop, before using `thing`:
        let thing = &amp;mut *thing;
</code></pre>
<p>Note that this line triggers <a href="pitfalls//programming/change-detection.html">change detection</a>. Even if
you don't modify the data afterwards, the component gets marked as changed.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>Bevy typically gives you access to your data via special wrapper types (like
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>, <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, and <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.Mut.html"><code>Mut&lt;T&gt;</code></a>
(when <a href="pitfalls//programming/queries.html">querying</a> for components mutably)). This lets Bevy track
access to the data.</p>
<p>These are &quot;smart pointer&quot; types that use the Rust <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>Deref</code></a>
trait to dereference to your data. They usually work seamlessly and you
don't even notice them.</p>
<p>However, in a sense, they are opaque to the compiler. The Rust language
allows fields of a struct to be borrowed individually, when you have direct
access to the struct, but this does not work when it is wrapped in another type.</p>
<p>The &quot;reborrow&quot; trick shown above, effectively converts the wrapper
into a regular Rust reference. <code>*thing</code> dereferences the wrapper via
<a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>, and then <code>&amp;mut</code> borrows it mutably. You now have
<code>&amp;mut MyStuff</code> instead of <code>Mut&lt;MyStuff&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-time-vs-rustos-time"><a class="header" href="#bevy-time-vs-rustos-time">Bevy Time vs. Rust/OS time</a></h1>
<p>Do <em>not</em> use <a href="https://doc.rust-lang.org/stable/std/time/struct.Instant.html"><code>std::time::Instant::now()</code></a> to get the
current time. <a href="pitfalls//features/time.html">Get your timing information from Bevy</a>, using
<a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Time.html"><code>Res&lt;Time&gt;</code></a>.</p>
<p>Rust (and the OS) give you the precise time of the moment you call that
function. However, that's not what you want.</p>
<p>Your game systems are run by Bevy's parallel scheduler, which means that they
could be called at vastly different instants every frame! This will result in
inconsistent / jittery timings and make your game misbehave or look stuttery.</p>
<p>Bevy's <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Time.html"><code>Time</code></a> gives you timing information that is consistent
throughout the frame update cycle. It is intended to be used for game logic.</p>
<p>This is not Bevy-specific, but applies to game development in general. Always
get your time from your game engine, not from your programming language or
operating system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui-layout-is-inverted"><a class="header" href="#ui-layout-is-inverted">UI layout is inverted</a></h1>
<p><a href="pitfalls//features/coords.html">In bevy, the Y axis always points <em>UP</em>. When working with UI, the origin
is at the <em>bottom left</em> corner of the screen.</a></p>
<p>This means that UI is laid out from bottom to top.</p>
<p>This is the opposite of the typical behavior of web pages and other UI
toolkits, where layout works from top to bottom.</p>
<p>Bevy uses the Flexbox layout model for UI, but unlike in web pages / CSS,
the vertical axis is inverted.</p>
<p>Unintuitively, this means that to build UIs that flow from top to bottom,
you need to use <code>FlexDirection::ColumnReverse</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uv-coordinates-in-bevy"><a class="header" href="#uv-coordinates-in-bevy">UV coordinates in Bevy</a></h1>
<p>In Bevy, the vertical axis for the pixels of textures / images, and when
sampling textures in a shader, points <em>downwards</em>, from top to bottom. The
origin is at the top left.</p>
<p>This is consistent with how most image file formats store pixel data, and
with how most graphics APIs work (including DirectX, Vulkan, Metal, WebGPU,
but <em>not</em> OpenGL).</p>
<p>This is different from OpenGL (and frameworks based on it). If your prior
experience is with these, you may find that the textures on your meshes are
flipped vertically. You will have to reexport / regenerate your meshes in
the correct UV format.</p>
<p>This is also inconsistent with the <a href="pitfalls//features/coords.html">World-coordinate system used everywhere
else in Bevy</a>, where the Y axis points up.</p>
<p>If the images of your 2D sprites are flipped (for whatever reason), you can
correct that using Bevy's sprite-flipping feature:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn_bundle(SpriteBundle {
    sprite: Sprite {
        flip_y: true,
        flip_x: false,
        ..Default::default()
    },
    ..Default::default()
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-game-engine-core"><a class="header" href="#bevy-game-engine-core">Bevy Game Engine Core</a></h1>
<p>This chapter covers the foundational information about the game engine aspects of Bevy.
It serves as an addition to the <a href="/programming.html">Bevy Programming Framework</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h1>
<p>Bevy uses a right-handed Y-up coordinate system.</p>
<p>Bevy uses the same coordinate system for 3D, 2D, and UI, for consistency.</p>
<p>It is easiest to explain in terms of 2D:</p>
<ul>
<li>The X axis goes from left to right (+X points right).</li>
<li>The Y axis goes from bottom to top (+Y points up).</li>
<li>The Z axis goes from far to near (+Z points towards you, out of the screen).</li>
<li>For 2D, the origin (X=0.0; Y=0.0) is at the <em>center of the screen</em> by default.
<ul>
<li>For UI, the origin is at the <em>bottom left</em> corner.</li>
</ul>
</li>
</ul>
<p>When you are working with 2D sprites, you can put the background on Z=0.0, and
place other sprites at increasing positive Z coordinates to layer them on top.</p>
<p>In 3D, the axes are oriented the same way.</p>
<p>This is a right-handed coordinate system. You can use the fingers of your right
hand to visualize the 3 axes: thumb=X, index=Y, middle=Z.</p>
<p>It is the same as Godot, Maya, and OpenGL. Compared to Unity, the Z axis
is inverted.</p>
<p>Note: In Bevy, the Y axis always points <em>UP</em>.</p>
<p>This may feel <a href="features//pitfalls/ui-y-up.html">unintuitive when working with UI</a>
(as it is the opposite from web pages), or if you are used to working with
2D libraries where the Y axis points down.</p>
<p>Also beware of a common pitfall when working in 2D: <a href="features//pitfalls/2d-camera-z.html">the camera must be
positioned at a far away Z coordinate (=999.9 by default), or you might not
be able to see your sprites!</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/transform.rs"><code>transform</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/translation.rs"><code>translation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/2d/rotation.rs"><code>rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/3d_rotation.rs"><code>3d_rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/scale.rs"><code>scale</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/2d/move_sprite.rs"><code>move_sprite</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/3d/parenting.rs"><code>parenting</code></a>,
anything that spawns 2D or 3D objects.</p>
<hr />
<p>First, a quick definition, if you are new to game development:</p>
<p>a Transform is what allows you to place an object in the game world. It
is a combination of the object's &quot;translation&quot; (position/coordinates),
&quot;rotation&quot;, and &quot;scale&quot; (size adjustment).</p>
<p>You move objects around by modifying the translation, rotate them by modifying
the rotation, and make them larger or smaller by modifying the scale.</p>
<h2 id="transform-components"><a class="header" href="#transform-components">Transform Components</a></h2>
<p>In Bevy, transforms are represented by <em>two</em> <a href="features//programming/ec.html#components">components</a>:
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> and <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>.
Any <a href="features//programming/ecs-intro.html">Entity</a> that represents an object in the game world
needs to have both. All of Bevy's <a href="features//builtins.html#bundles">bundle types</a>
include them.  If you are creating a custom entity, you can use
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a> to ensure you don't miss them.</p>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> is what you typically work with. It is
a <code>struct</code> containing the translation, rotation, and scale. To read or
manipulate these values, access them from your <a href="features//programming/systems.html">systems</a> using a
<a href="features//programming/queries.html">query</a>.</p>
<p>If the entity has a <a href="features//features/parent-child.html">parent</a>, the <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>
component is relative to the parent. This means that the child object will
move/rotate/scale along with the parent.</p>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> represents the absolute global
position in the world. If the entity does not have a parent, then this will
have the same value as the <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>. The value of
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> is calculated/managed internally
by Bevy. You should treat it as read-only; do not mutate it.</p>
<p>Beware: The two components are synchronized by a bevy-internal system
(the &quot;transform propagation system&quot;), which runs in the <a href="https://docs.rs/bevy/0.7.0/bevy/app/enum.CoreStage.html"><code>PostUpdate</code></a>
<a href="features//programming/stages.html">stage</a>. This is somewhat finnicky and can result in tricky pitfalls
if you are trying to do advanced things that rely on both the relative/local
and the absolute/global transforms of entities. When you mutate the
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, the <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>
is not updated immediately. They will be out-of-sync until the transform
propagation system runs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-and-timers"><a class="header" href="#time-and-timers">Time and Timers</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/timers.rs"><code>timers</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/2d/move_sprite.rs"><code>move_sprite</code></a>.</p>
<hr />
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>The <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Time.html"><code>Time</code></a> <a href="features//programming/res.html">resource</a> is your main global source
of timing information, that you can access from any <a href="features//programming/systems.html">system</a>
that does anything that needs time. <a href="features//pitfalls/time.html">You should derive all timings from
it</a>.</p>
<p>Bevy updates these values at the beginning of every frame.</p>
<h3 id="delta-time"><a class="header" href="#delta-time">Delta Time</a></h3>
<p>The most common use case is &quot;delta time&quot; – how much time passed between the
previous frame update and the current one. This tells you how fast the game
is running, so you can scale things like movement and animations, so they
can happen smoothly, regardless of the game's frame rate.</p>
<pre><code class="language-rust no_run noplayground">fn asteroids_fly(
    time: Res&lt;Time&gt;,
    mut q: Query&lt;&amp;mut Transform, With&lt;Asteroid&gt;&gt;,
) {
    for mut transform in q.iter_mut() {
        // move our asteroids along the X axis
        // at a speed of 10.0 units per second
        transform.translation.x += 10.0 * time.delta_seconds();
    }
}
</code></pre>
<h3 id="ongoing-time"><a class="header" href="#ongoing-time">Ongoing Time</a></h3>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Time.html"><code>Time</code></a> can also give you the total running time since startup.
Use this if you need a cumulative, increasing, measurement of time.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Instant;

/// Say, for whatever reason, we want to keep track
/// of when exactly some specific entities were spawned.
#[derive(Component)]
struct SpawnedTime(Instant);

fn spawn_my_stuff(
    mut commands: Commands,
    time: Res&lt;Time&gt;,
) {
    commands.spawn()
        .insert(SpawnedTime(time.startup() + time.time_since_startup()));
}
</code></pre>
<h2 id="timers-and-stopwatches"><a class="header" href="#timers-and-stopwatches">Timers and Stopwatches</a></h2>
<p>There are also facilities to help you track specific intervals or timings:
<a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Timer.html"><code>Timer</code></a> and <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Stopwatch.html"><code>Stopwatch</code></a>. You can create
many instances of these, to track whatever you want. You can use them in
your own <a href="features//programming/ec.html#components">component</a> or <a href="features//programming/res.html">resource</a> types.</p>
<p>Timers and Stopwatches need to be ticked. You need to have some system
calling <code>.tick(delta)</code>, for it to make progress, or it will be inactive.
The delta should come from the <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Time.html"><code>Time</code></a> resource.</p>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Timer.html"><code>Timer</code></a> allows you to detect when a certain interval of time
has elapsed. Timers have a set duration. They can be &quot;repeating&quot; or
&quot;non-repeating&quot;.</p>
<p>Both kinds can be manually &quot;reset&quot; (start counting the time interval from the
beginning) and &quot;paused&quot; (they will not progress even if you keep ticking them).</p>
<p>Repeating timers will automatically reset themselves after they reach their
set duration.</p>
<p>Use <code>.finished()</code> to detect when a timer has reached its set duration. For
non-repeating timers, you can also use <code>.just_finished()</code>, if you need to
respond only on the exact update when the duration was reached.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Duration;

#[derive(Component)]
struct FuseTime {
    /// track when the bomb should explode (non-repeating timer)
    timer: Timer,
}

fn explode_bombs(
    mut commands: Commands,
    mut q: Query&lt;(Entity, &amp;mut FuseTime)&gt;,
    time: Res&lt;Time&gt;,
) {
    for (entity, mut fuse_timer) in q.iter_mut() {
        // timers gotta be ticked, to work
        fuse_timer.timer.tick(time.delta());

        // if it finished, despawn the bomb
        if fuse_timer.timer.finished() {
            commands.entity(entity).despawn();
        }
    }
}

struct BombsSpawnConfig {
    /// How often to spawn a new bomb? (repeating timer)
    timer: Timer,
}

/// Spawn a new bomb in set intervals of time
fn spawn_bombs(
    mut commands: Commands,
    time: Res&lt;Time&gt;,
    mut config: ResMut&lt;BombsSpawnConfig&gt;,
) {
    // tick the timer
    config.timer.tick(time.delta());

    if config.timer.finished() {
        commands.spawn()
            .insert(FuseTime {
                // create the non-repeating fuse timer
                timer: Timer::new(Duration::from_secs(5), false),
            });
    }
}

/// Configure our bomb spawning algorithm
fn setup_bomb_spawning(
    mut commands: Commands,
) {
    commands.insert_resource(BombsSpawnConfig {
        // create the repeating timer
        timer: Timer::new(Duration::from_secs(10), true),
    })
}
</code></pre>
<p>Note that Bevy's timers do <em>not</em> work like typical real-life timers (which
count downwards toward zero). Bevy's timers start from zero and count <em>up</em>
towards their set duration. They are basically like stopwatches with extra
features: a maximum duration and optional auto-reset.</p>
<h3 id="stopwatch"><a class="header" href="#stopwatch">Stopwatch</a></h3>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.Stopwatch.html"><code>Stopwatch</code></a> allow you to track how much time has passed
since a certain point.</p>
<p>It will just keep accumulating time, which you can check with
<code>.elapsed()</code>/<code>.elapsed_secs()</code>. You can manually reset it at any time.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core::Stopwatch;

#[derive(Component)]
struct JumpDuration {
    time: Stopwatch,
}

fn jump_duration(
    time: Res&lt;Time&gt;,
    mut q_player: Query&lt;&amp;mut JumpDuration, With&lt;Player&gt;&gt;,
    kbd: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    // assume we have exactly one player that jumps with Spacebar
    let mut jump = q_player.single_mut();

    if kbd.just_pressed(KeyCode::Space) {
        jump.time.reset();
    }

    if kbd.pressed(KeyCode::Space) {
        println!(&quot;Jumping for {} seconds.&quot;, jump.time.elapsed_secs());
        // stopwatch has to be ticked to progress
        jump.time.tick(time.delta());
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchical-parentchild-entities"><a class="header" href="#hierarchical-parentchild-entities">Hierarchical (Parent/Child) Entities</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/hierarchy.rs"><code>hierarchy</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Technically, the <a href="features//programming/ec.html">Entities/Components</a> themselves cannot form a
hierarchy (the <a href="features//programming/ecs-intro.html">ECS</a> is a flat data structure). However,
logical hierarchies are a common pattern in games.</p>
<p>Bevy supports creating such a logical link between entities, to form
a virtual &quot;hierarchy&quot;, by simply adding <a href="https://docs.rs/bevy/0.7.0/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and
<a href="https://docs.rs/bevy/0.7.0/bevy/hierarchy/struct.Children.html"><code>Children</code></a> components on the respective entities.</p>
<p>When using <a href="features//programming/commands.html">Commands</a> to spawn entities,
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> has methods for adding children to entities,
which automatically add the correct components:</p>
<pre><code class="language-rust no_run noplayground">// spawn the parent and get its Entity id
let parent = commands.spawn_bundle(MyParentBundle::default())
    .id();

// do the same for the child
let child = commands.spawn_bundle(MyChildBundle::default())
    .id();

// add the child to the parent
commands.entity(parent).push_children(&amp;[child]);

// you can also use `with_children`:
commands.spawn_bundle(MyParentBundle::default())
    .with_children(|parent| {
        parent.spawn_bundle(MyChildBundle::default());
    });
</code></pre>
<p>You can despawn an entire hierarchy with a single <a href="features//programming/commands.html">command</a>:</p>
<pre><code class="language-rust no_run noplayground">fn close_menu(
    mut commands: Commands,
    query: Query&lt;Entity, With&lt;MainMenuUI&gt;&gt;,
) {
    for entity in query.iter() {
        // despawn the entity and its children
        commands.entity(entity).despawn_recursive();
    }
}
</code></pre>
<h2 id="accessing-the-parent-or-children"><a class="header" href="#accessing-the-parent-or-children">Accessing the Parent or Children</a></h2>
<p>To make a system that works with the hierarchy, you typically need two <a href="features//programming/queries.html">queries</a>:</p>
<ul>
<li>one with the components you need from the child entities</li>
<li>one with the components you need from the parent entities</li>
</ul>
<p>One of the two queries should include the appropriate component, to obtain the
entity ids to use with the other one:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> in the child query, if you want to iterate entities
and look up their parents, or</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/hierarchy/struct.Children.html"><code>Children</code></a> in the parent query, if you want to iterate entities
and look up their children</li>
</ul>
<p>For example, if we want to get the <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>
of cameras (<a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a>) that have a parent, and the
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> of their parent:</p>
<pre><code class="language-rust no_run noplayground">fn camera_with_parent(
    q_child: Query&lt;(&amp;Parent, &amp;Transform), With&lt;Camera&gt;&gt;,
    q_parent: Query&lt;&amp;GlobalTransform&gt;,
) {
    for (parent, child_transform) in q_child.iter() {
        // `parent` contains the Entity ID we can use
        // to query components from the parent:
        let parent_global_transform = q_parent.get(parent.0);

        // do something with the components
    }
}
</code></pre>
<p>As another example, say we are making a strategy game, and we have Units
that are children of a Squad. Say we need to make a system that works on
each Squad, and it needs some information about the children:</p>
<pre><code class="language-rust no_run noplayground">fn process_squad_damage(
    q_parent: Query&lt;(&amp;MySquadDamage, &amp;Children)&gt;,
    q_child: Query&lt;&amp;MyUnitHealth&gt;,
) {
    // get the properties of each squad
    for (squad_dmg, children) in q_parent.iter() {
        // `children` is a collection of Entity IDs
        for &amp;child in children.iter() {
            // get the health of each child unit
            let health = q_child.get(child);

            // do something
        }
    }
}
</code></pre>
<h2 id="relative-transforms"><a class="header" href="#relative-transforms">Relative Transforms</a></h2>
<p>If your entities represent &quot;objects in the game world&quot;, you probably expect
the child to be positioned relative to the parent and move with it.</p>
<p>All <a href="features//builtins.html#bundles">Bundles that come with Bevy</a> provide
this behavior automatically. You should at least use the basic
<a href="https://docs.rs/bevy/0.7.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a> if you don't need anything else.</p>
<p>For more info, see the <a href="features//features/transforms.html">dedicated page about transforms</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixed-timestep"><a class="header" href="#fixed-timestep">Fixed Timestep</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/fixed_timestep.rs"><code>fixed_timestep</code></a>.</p>
<p>Consider using the <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a> crate, which
provides an alternative implementation that does not suffer from the
<a href="features/fixed-timestep.html#caveats">usability issues</a> of the one in Bevy.</p>
<hr />
<p>If you need something to happen at fixed time intervals (a common use case
is Physics updates), you can add the respective <a href="features//programming/systems.html">systems</a> to
your <a href="features//programming/app-builder.html">app</a> using Bevy's <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.FixedTimestep.html"><code>FixedTimestep</code></a>
<a href="features//programming/run-criteria.html">Run Criteria</a>.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core::FixedTimestep;

// The timestep says how many times to run the SystemSet every second
// For TIMESTEP_1, it's once every second
// For TIMESTEP_2, it's twice every second

const TIMESTEP_1_PER_SECOND: f64 = 60.0 / 60.0;
const TIMESTEP_2_PER_SECOND: f64 = 30.0 / 60.0;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system_set(
            SystemSet::new()
                // This prints out &quot;hello world&quot; once every second
                .with_run_criteria(FixedTimestep::step(TIMESTEP_1_PER_SECOND))
                .with_system(slow_timestep)
        )
        .add_system_set(
            SystemSet::new()
                // This prints out &quot;goodbye world&quot; twice every second
                .with_run_criteria(FixedTimestep::step(TIMESTEP_2_PER_SECOND))
                .with_system(fast_timestep)
        )
        .run();
}

fn slow_timestep() {
    println!(&quot;hello world&quot;);
}

fn fast_timestep() {
    println!(&quot;goodbye world&quot;);
}
</code></pre>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>You can check the current state of the fixed timestep trackers, by accessing
the <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.FixedTimesteps.html"><code>FixedTimesteps</code></a> <a href="features//programming/res.html">resource</a>. This lets
you know how much time remains until the next time it triggers, or how much
it has overstepped. You need to label your fixed timesteps.</p>
<p>See the <a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/fixed_timestep.rs">official example</a>, which illustrates this.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>The major problem with Bevy's fixed timestep comes from the fact that
it is implemented using <a href="features//programming/run-criteria.html">Run Criteria</a>. It cannot be
combined with other run criteria, such as <a href="features//programming/states.html">states</a>. This makes
it unusable for most projects, which need to rely on states for things
like implementing the main menu / loading screen / etc. Consider using
<a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>, which does not have this problem.</p>
<p>Also, note that your <a href="features//programming/systems.html">systems</a> are still called as part of the
regular frame-update cycle, along with all of the normal systems. So, the
timing is not exact.</p>
<p>The <a href="https://docs.rs/bevy/0.7.0/bevy/core/struct.FixedTimestep.html"><code>FixedTimestep</code></a> run criteria simply checks how much
time passed since the last time your systems were ran, and decides whether
to run them during the current frame, or not, or run them multiple times,
as needed.</p>
<h3 id="danger-lost-events"><a class="header" href="#danger-lost-events"><strong>Danger!</strong> Lost events!</a></h3>
<p>By default, Bevy's <a href="features//programming/events.html">events</a> are <em>not reliable!</em> They only persist
for 2 frames, after which they are lost. If your fixed-timestep systems
receive events, beware that you may miss some events if the framerate is
higher than 2x the fixed timestep.</p>
<p>One way around that is to use <a href="features//patterns/manual-event-clear.html">events with manual
clearing</a>. This gives you control over how long events
persist, but can also leak / waste memory if you forget to clear them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-2"><a class="header" href="#audio-2">Audio</a></h1>
<p>Bevy's own built-in audio support is extremely barebones and limited. It
can play sounds and give some control over its volume and playback.</p>
<p><strong>TODO:</strong> show how to use Bevy audio, now that it its usability has improved.</p>
<h2 id="kira-audio"><a class="header" href="#kira-audio">Kira Audio</a></h2>
<p>Instead, you could try the <a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a>
community plugin, which integrates the Kira sound library with bevy. Kira
is much more feature-rich, including support for managing many audio tracks
(like background music and sound effects), with volume control, stereo panning,
playback rate, and streaming.</p>
<p>Using <code>bevy_kira_audio</code> in your project requires some extra configuration,
because you need to disable Bevy's own audio. Bevy's audio is a cargo feature
that is enabled by default, but must be disabled. Cargo does not let you
disable individual default features, so you need to disable all default bevy
features and re-enable the ones you need. <a href="features//setup/bevy-config.html">See here</a> for more info.</p>
<p>You must not include the <code>bevy_audio</code> feature, or any of the audio file
formats (such as the default <code>vorbis</code>). Enable the file formats you care
about on <code>bevy_kira_audio</code> instead of Bevy.</p>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.7&quot;
default-features = false
# These are the remaining default features other than `bevy_audio` and `mp3`
features = [
  &quot;render&quot;,
  &quot;animation&quot;,
  &quot;bevy_winit&quot;,
  &quot;bevy_gilrs&quot;,
  &quot;png&quot;,
  &quot;hdr&quot;,
  &quot;filesystem_watcher&quot;,
  &quot;x11&quot;
]

[dependencies.bevy_kira_audio]
version = &quot;0.9.0&quot;
# `ogg` format support is enabled by default, disable if you don't want it
default-features = false
# enable the features you care about
features = [
  &quot;wav&quot;,
  &quot;flac&quot;,
  &quot;mp3&quot;,
  &quot;ogg&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-asset-management"><a class="header" href="#bevy-asset-management">Bevy Asset Management</a></h1>
<p>Assets are the data that the game engine is working with: all of your images,
3D models, sounds, scenes, game-specific things like item descriptions,
and more!</p>
<p>Bevy has a flexible system for loading and managing your game assets
asynchronously (in the background, without causing lag spikes in your game).</p>
<p>In your code, you refer to individual assets using <a href="/assets/handles.html">handles</a>.</p>
<p>Asset data can be <a href="/assets/assetserver.html">loaded from files</a> and also <a href="/assets/data.html">accessed from
code</a>. <a href="/assets/hot-reload.html">Hot-reloading</a> is supported to
help you during development, by reloading asset files if they change while the
game is running.</p>
<p>If you want to write some code to do something when assets finish loading, get
modified, or are unloaded, you can use <a href="/assets/assetevent.html">asset events</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handles"><a class="header" href="#handles">Handles</a></h1>
<p>Handles are lightweight IDs that refer to a specific asset. You need them
to use your assets, for example to <a href="assets//programming/commands.html">spawn entities</a> like
<a href="assets//2d/sprites.html">2D sprites</a> or <a href="assets//features/gltf.html">3D models</a>, or to <a href="assets//assets/data.html">access the data
of the assets</a>.</p>
<p>Handles have the Rust type <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.Handle.html"><code>Handle&lt;T&gt;</code></a>, where <code>T</code> is the
<a href="assets//builtins.html#assets">asset type</a>.</p>
<p>You can store handles in your <a href="assets//programming/ec.html#components">entity components</a> or
<a href="assets//programming/res.html">resources</a>.</p>
<p>Handles can refer to not-yet-loaded assets, meaning you can just spawn your
entities anyway, using the handles, and the assets will just &quot;pop in&quot; when
they become ready.</p>
<h2 id="obtaining-handles"><a class="header" href="#obtaining-handles">Obtaining Handles</a></h2>
<p>If you are <a href="assets//assets/assetserver.html">loading an asset from a file</a>, the
<code>asset_server.load(…)</code> call will give you the handle. The loading of the
data happens in the background, meaning that the handle will initially refer
to an unloaded asset, and the actual data will become available later.</p>
<p>If you are <a href="assets//assets/data.html">creating your own asset data from code</a>,
the <code>assets.add(…)</code> call will give you the handle.</p>
<h2 id="reference-counting-strong-and-weak-handles"><a class="header" href="#reference-counting-strong-and-weak-handles">Reference Counting; Strong and Weak Handles</a></h2>
<p>Bevy keeps track of how many handles to a given asset exist at any time. Bevy
will automatically unload unused assets, after the last handle is dropped.</p>
<p>For this reason, creating additional handles to the same asset requires you
to call <code>handle.clone()</code>. This makes the operation explicit, to ensure you are
aware of all the places in your code where you create additional handles. The
<code>.clone()</code> operation is cheap, so don't worry about performance (in most cases).</p>
<p>There are two kinds of handles: &quot;strong&quot; and &quot;weak&quot;. Strong assets are
counted, weak handles are not. By default, handles are strong. If you want
to create a weak handle, use <code>.clone_weak()</code> (instead of <code>.clone()</code>) on an
existing handle. Bevy can unload the asset after all strong handles are gone,
even if you are still holding some weak handles.</p>
<h2 id="untyped-handles"><a class="header" href="#untyped-handles">Untyped Handles</a></h2>
<p>Bevy also has a <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.HandleUntyped.html"><code>HandleUntyped</code></a> type. Use this type
of handle if you need to be able to refer to any asset, regardless of the
asset type.</p>
<p>This allows you to store a collection (such as <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> or
<a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>HashMap</code></a>) containing assets of mixed types.</p>
<p>Just like regular handles, untyped handles can be strong or weak, and can
be used to <a href="assets//assets/data.html">access asset data</a>.</p>
<p>You can create an untyped handle using <code>.clone_untyped()</code> on an existing
handle.</p>
<p>You can convert an untyped handle into a typed handle with <code>.typed::&lt;T&gt;()</code>,
specifying the type to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load-assets-from-files-with-assetserver"><a class="header" href="#load-assets-from-files-with-assetserver">Load Assets from Files with AssetServer</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/asset/asset_loading.rs"><code>asset_loading</code></a>.</p>
<hr />
<p>To load assets from files, use the <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>
<a href="assets//programming/res.html">resource</a>.</p>
<pre><code class="language-rust no_run noplayground">struct UiFont(Handle&lt;Font&gt;);

fn load_ui_font(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;
) {
    let handle: Handle&lt;Font&gt; = server.load(&quot;font.ttf&quot;);

    // we can store the handle in a resource:
    //  - to prevent the asset from being unloaded
    //  - if we want to use it to access the asset later
    commands.insert_resource(UiFont(handle));
}
</code></pre>
<p>This queues the asset loading to happen in the background, and return a
<a href="assets//assets/handles.html">handle</a>. The asset will take some time to become available. You
cannot access the actual data immediately in the same <a href="assets//programming/systems.html">system</a>,
but you can use the handle.</p>
<p>You can spawn entities like your 2D sprites, 3D models, and UI, using the
handle, even before the asset has loaded. They will just &quot;pop in&quot; later,
when the asset becomes ready.</p>
<p>Note that it is OK to call <code>asset_server.load(…)</code> as many times as you want,
even if the asset is currently loading, or already loaded. It will just
provide you with the same handle. Every time you call it, it will just check
the status of the asset, begin loading it if needed, and give you a handle.</p>
<p>Bevy supports loading <a href="assets//builtins.html#file-formats">a variety of asset file formats</a>,
and can be extended to support more. The asset loader implementation to use
is selected based on the file extension.</p>
<h2 id="untyped-loading"><a class="header" href="#untyped-loading">Untyped Loading</a></h2>
<p>If you want an <a href="assets//assets/handles.html#untyped-handles">untyped handle</a>, you can use
<code>asset_server.load_untyped(…)</code> instead.</p>
<p>You can also load an entire folder of assets, regardless of how many
files are inside, using <code>asset_server.load_folder(…)</code>. This gives you a
<code>Vec&lt;HandleUntyped&gt;</code> with all the untyped handles.</p>
<pre><code class="language-rust no_run noplayground">struct ExtraAssets(Vec&lt;HandleUntyped&gt;);

fn load_extra_assets(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
) {
    if let Ok(handles) = server.load_folder(&quot;extra&quot;) {
        commands.insert_resource(ExtraAssets(handles));
    }
}
</code></pre>
<p>Untyped loading is possible, because Bevy always detects the file type from
the file extension anyway.</p>
<h2 id="assetpath-and-labels"><a class="header" href="#assetpath-and-labels">AssetPath and Labels</a></h2>
<p>The asset path you use to identify an asset from the filesystem is actually
a special <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetPath.html"><code>AssetPath</code></a>, which consists of the file path +
a label. Labels are used in situations where multiple assets are contained
in the same file. An example of this are <a href="assets//features/gltf.html">GLTF files</a>, which can
contain meshes, scenes, textures, materials, etc.</p>
<p>Asset paths can be created from a string, with the label (if any) attached
after a <code>#</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">fn load_gltf_things(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;
) {
    // get a specific mesh
    let my_mesh: Handle&lt;Mesh&gt; = server.load(&quot;my_scene.gltf#Mesh0/Primitive0&quot;);

    // spawn a whole scene
    let my_scene: Handle&lt;Scene&gt; = server.load(&quot;my_scene.gltf#Scene0&quot;);
    commands.spawn_scene(my_scene);
}
</code></pre>
<p>See the <a href="assets//features/gltf.html">GLTF page</a> for more info about working with 3D models.</p>
<h2 id="where-are-assets-loaded-from"><a class="header" href="#where-are-assets-loaded-from">Where are assets loaded from?</a></h2>
<p>The asset server internally relies on an implementation of the
<a href="https://docs.rs/bevy/0.7.0/bevy/asset/trait.AssetIo.html"><code>AssetIo</code></a> Rust trait, which is Bevy's way of providing
&quot;backends&quot; for fetching data from different types of storage.</p>
<p>Bevy provides its own default built-in I/O backend for desktop platforms
and for WebAssembly.</p>
<p>On desktop platforms, it treats asset paths as relative to a folder called
<code>assets</code>, that must be placed at one of the following locations:</p>
<ul>
<li>Alongside the game's executable file, for distribution</li>
<li>In your Cargo project folder, when running your game using <code>cargo</code> during development
<ul>
<li>This is identified by the <code>CARGO_MANIFEST_DIR</code> environment variable</li>
</ul>
</li>
</ul>
<p>On the web, it fetches assets using HTTP URLs pointing within an <code>assets</code>
folder located alongside the game's <code>.wasm</code> file.</p>
<p>There are <a href="assets//setup/unofficial-plugins.html">unofficial plugins</a> available that provide additional
I/O backend implementations, such as for loading assets from inside archive
files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-the-asset-data"><a class="header" href="#access-the-asset-data">Access the Asset Data</a></h1>
<p>To access the actual asset data from systems, use the
<a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> <a href="assets//programming/res.html">resource</a>.</p>
<p>You can identify your desired asset using either the <a href="assets//assets/handles.html">handle</a>
(<a href="assets//assets/handles.html#untyped-handles">untyped handles</a> can also be used) or the <a href="assets//assets/assetserver.html#assetpath-and-labels">asset
path</a>:</p>
<pre><code class="language-rust no_run noplayground">struct SpriteSheets {
    map_tiles: Handle&lt;TextureAtlas&gt;,
}

fn use_sprites(
    handles: Res&lt;SpriteSheets&gt;,
    atlases: Res&lt;Assets&lt;TextureAtlas&gt;&gt;,
    images: Res&lt;Assets&lt;Image&gt;&gt;,
) {
    // Could be `None` if the asset isn't loaded yet
    if let Some(atlas) = atlases.get(&amp;handles.map_tiles) {
        // do something with the texture atlas
    }

    // Can use a path instead of a handle
    if let Some(map_tex) = images.get(&quot;map.png&quot;) {
        // if &quot;map.png&quot; was loaded, we can use it!
    }
}
</code></pre>
<h2 id="creating-assets-from-code"><a class="header" href="#creating-assets-from-code">Creating Assets from Code</a></h2>
<p>You can also add assets to <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> manually.</p>
<p>Sometimes you need to create assets from code, rather than <a href="assets//assets/assetserver.html">loading them
from files</a>. Some common examples of such use-cases are:</p>
<ul>
<li>creating texture atlases</li>
<li>creating 3D or 2D materials</li>
<li>procedurally-generating assets like images or 3D meshes</li>
</ul>
<p>To do this, first create the data for the asset (an instance of the
<a href="assets//builtins.html#assets">asset type</a>), and then add it <code>.add(…)</code> it to the
<a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> resource, for it to be stored and tracked by
Bevy. You will get a <a href="assets//assets/handles.html">handle</a> to use to refer to it, just like
any other asset.</p>
<pre><code class="language-rust no_run noplayground">fn add_material(
    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,
) {
    let new_mat = StandardMaterial {
        base_color: Color::rgba(0.25, 0.50, 0.75, 1.0),
        unlit: true,
        ..Default::default()
    };

    let handle = materials.add(new_mat);

    // do something with the handle
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-to-changes-with-asset-events"><a class="header" href="#react-to-changes-with-asset-events">React to Changes with Asset Events</a></h1>
<p>If you need to perform specific actions when an asset is created,
modified, or removed, you can make a <a href="assets//programming/systems.html">system</a> that reacts to
<a href="https://docs.rs/bevy/0.7.0/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> <a href="assets//programming/events.html">events</a>.</p>
<pre><code class="language-rust no_run noplayground">struct MyMapImage {
    handle: Handle&lt;Image&gt;,
}

fn fixup_images(
    mut ev_asset: EventReader&lt;AssetEvent&lt;Image&gt;&gt;,
    mut assets: ResMut&lt;Assets&lt;Image&gt;&gt;,
    map_img: Res&lt;MyMapImage&gt;,
) {
    for ev in ev_asset.iter() {
        match ev {
            AssetEvent::Created { handle } |
            AssetEvent::Modified { handle } =&gt; {
                // a texture was just loaded or changed!

                let texture = assets.get_mut(handle).unwrap();
                // ^ unwrap is OK, because we know it is loaded now

                if *handle == map_img.handle {
                    // it is our special map image!
                } else {
                    // it is some other image
                }
            }
            AssetEvent::Removed { handle } =&gt; {
                // an image was unloaded
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="track-loading-progress"><a class="header" href="#track-loading-progress">Track Loading Progress</a></h1>
<p>There are good community plugins that can help with this. See <a href="assets//setup/unofficial-plugins.html#code-helpers">my
recommendations for helper crates</a>. Otherwise,
this page shows you how to do it manually.</p>
<hr />
<p>If you want to check the status of various <a href="assets//assets/assetserver.html">asset files</a>,
you can poll it from the <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>. It will tell you
whether the asset(s) are loaded, still loading, not loaded, or encountered
an error.</p>
<p>To check an individual asset, you can use <code>asset_server.get_load_state(…)</code> with
a handle or path to refer to the asset.</p>
<p>To check a group of many assets, you can add them to a single collection
(such as a <code>Vec&lt;HandleUntyped&gt;</code>; <a href="assets//assets/handles.html#untyped-handles">untyped handles</a> are very
useful for this) and use <code>asset_server.get_group_load_state(…)</code>.</p>
<hr />
<p>Here is a more complete code example:</p>
<pre><code class="language-rust no_run noplayground">struct AssetsLoading(Vec&lt;HandleUntyped&gt;);

fn setup(server: Res&lt;AssetServer&gt;, mut loading: ResMut&lt;AssetsLoading&gt;) {
    // we can have different asset types
    let font: Handle&lt;Font&gt; = server.load(&quot;my_font.ttf&quot;);
    let menu_bg: Handle&lt;Image&gt; = server.load(&quot;menu.png&quot;);
    let scene: Handle&lt;Scene&gt; = server.load(&quot;level01.gltf#Scene0&quot;);

    // add them all to our collection for tracking
    loading.0.push(font.clone_untyped());
    loading.0.push(menu_bg.clone_untyped());
    loading.0.push(scene.clone_untyped());
}

fn check_assets_ready(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
    loading: Res&lt;AssetsLoading&gt;
) {
    use bevy::asset::LoadState;

    match server.get_group_load_state(loading.0.iter().map(|h| h.id)) {
        LoadState::Failed =&gt; {
            // one of our assets had an error
        }
        LoadState::Loaded =&gt; {
            // all assets are now ready

            // this might be a good place to transition into your in-game state

            // remove the resource to drop the tracking handles
            commands.remove_resource::&lt;AssetsLoading&gt;();
            // (note: if you don't have any other handles to the assets
            // elsewhere, they will get unloaded after this)
        }
        _ =&gt; {
            // NotLoaded/Loading: not fully ready yet
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hot-reloading-assets"><a class="header" href="#hot-reloading-assets">Hot-Reloading Assets</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/asset/hot_asset_reloading.rs"><code>hot_asset_reloading</code></a>.</p>
<hr />
<p>At runtime, if you modify the file of an <a href="assets//assets.html">asset</a> that is loaded
into the game (via the <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>), Bevy can detect
that and reload the asset automatically. This is very useful for quick
iteration. You can edit your assets while the game is running and see the
changes instantly in-game.</p>
<p>Not all <a href="assets//builtins.html#file-formats">file formats</a> and use cases are supported
equally well. Typical asset types like textures / images should work without
issues, but complex GLTF or scene files, or assets involving custom logic,
might not.</p>
<p>If you need to run custom logic as part of your hot-reloading
workflow, you could implement it in a <a href="assets//programming/systems.html">system</a>, using
<a href="https://docs.rs/bevy/0.7.0/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> (<a href="assets//assets/assetevent.html">learn more</a>).</p>
<p>Hot reloading is opt-in and has to be enabled in order to work. You can do
this in a <a href="assets//programming/app-builder.html">startup system</a>:</p>
<pre><code class="language-rust no_run noplayground">    asset_server.watch_for_changes().unwrap();
</code></pre>
<p>Note that this requires the <code>filesystem_watcher</code> <a href="assets//setup/bevy-config.html">Bevy cargo
feature</a>. It is enabled by default, but if you have disabled
default features to customize Bevy, be sure to include it if you need it.</p>
<h2 id="shaders"><a class="header" href="#shaders">Shaders</a></h2>
<p>Bevy also supports hot-reloading for shaders. You can edit your
custom shader code and see the changes immediately.</p>
<p>This only works if you are loading your shaders through the bevy asset
system (via the <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>).</p>
<p>Shader code that does not come from asset files, such as if you include
it as a static string in your source code, cannot be hot-reloaded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h1>
<p><a href="/code/examples/input.rs">Click here to download example code.</a></p>
<p>This is a complete example that you can run. It will print all input activity
to the console.</p>
<hr />
<p>Bevy supports the following inputs:</p>
<ul>
<li><a href="/input/keyboard.html">Keyboard</a> (detect when keys are pressed or released)</li>
<li><a href="/input/char.html">Character</a> (for text input; keyboard layout handled by the OS)</li>
<li><a href="/input/mouse.html">Mouse</a> (relative motion, buttons, scrolling)
<ul>
<li><a href="/input/mouse.html">Motion</a> (moving the mouse, not tied to OS cursor)</li>
<li><a href="/input/mouse.html">Cursor</a> (absolute pointer position)</li>
<li><a href="/input/mouse.html">Buttons</a></li>
<li><a href="/input/mouse.html">Scrolling</a> (mouse wheel or touchpad gesture)</li>
</ul>
</li>
<li><a href="/input/touch.html">Touchscreen</a> (with multi-touch)</li>
<li><a href="/input/gamepad.html">Gamepad (Controller, Joystick)</a> (via the <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> library)</li>
</ul>
<p>Sensors, like accelerometers and gyroscopes, are not supported yet.</p>
<p>For most input types (where it makes sense), Bevy provides two ways of
dealing with them:</p>
<ul>
<li>by checking the current state via <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html">resources</a> (<a href="/builtins.html#input-handling-resources">input resources</a>),</li>
<li>or via <a href="/programming/events.html">events</a> (<a href="/builtins.html#input-events">input events</a>).</li>
</ul>
<p>Some inputs are only provided as events.</p>
<p>Checking state is done using <a href="/programming/res.html">resources</a> such as
<a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html"><code>Input</code></a> (for binary inputs like keys or buttons),
<a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Axis.html"><code>Axis</code></a> (for analog inputs), <a href="https://docs.rs/bevy/0.7.0/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>
(for fingers on a touchscreen), etc. This way of handling input is very
convenient for implementing game logic. In these scenarios, you typically
only care about the specific inputs mapped to actions in your game. You can
check specific buttons/keys to see when they get pressed/released, or what
their current state is.</p>
<p><a href="/programming/events.html">Events</a> (<a href="/builtins.html#input-events">input events</a>) are a lower-level,
more all-encompassing approach. Use them if you want to get all activity
from that class of input device, rather than only checking for specific inputs.</p>
<h2 id="input-mapping"><a class="header" href="#input-mapping">Input Mapping</a></h2>
<p>Bevy does not yet offer a built-in way to do input mapping (configure key
bindings, etc). You need to come up with your own way of translating the
inputs into logical actions in your game/app.</p>
<p>There are some community-made plugins that may help with that: <a href="https://bevyengine.org/assets/#input">see the
input-section on bevy-assets</a>. My personal recommendation:
<a href="https://github.com/leafwing-studios/leafwing-input-manager">Input Manager plugin by Leafwing Studios</a>.</p>
<p>It may be a good idea to build your own abstractions specific to your
game. For example, if you need to handle player movement, you might want to
have a system for reading inputs and converting them to your own internal
&quot;movement intent/action events&quot;, and then another system acting on those
internal events, to actually move the player. Make sure to use <a href="/programming/system-order.html">explicit
system ordering</a> to avoid lag / frame delays.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard Input</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/keyboard_input.rs"><code>keyboard_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/keyboard_input_events.rs"><code>keyboard_input_events</code></a>.</p>
<hr />
<p>This page shows how to handle keyboard keys being pressed and released.</p>
<p>If you are interested in text input, see the <a href="input//input/char.html">Character Input</a> page instead.</p>
<p>Note: Command Key on Mac corresponds to the Super/Windows Key on PC.</p>
<h2 id="checking-key-state"><a class="header" href="#checking-key-state">Checking Key State</a></h2>
<p>Checking the state of specific keys can currently only be done by Key Code,
using the <code>Input&lt;KeyCode&gt;</code> (<a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html"><code>Input</code></a>, <a href="https://docs.rs/bevy/0.7.0/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a>)
<a href="input//programming/res.html">resource</a>:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_input(
    keys: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Space) {
        // Space was pressed
    }
    if keys.just_released(KeyCode::LControl) {
        // Left Ctrl was released
    }
    if keys.pressed(KeyCode::W) {
        // W is being held down
    }
    // we can check multiple at once with `.any_*`
    if keys.any_pressed([KeyCode::LShift, KeyCode::RShift]) {
        // Either the left or right shift are being held down
    }
    if keys.any_just_pressed([KeyCode::Delete, KeyCode::Back]) {
        // Either delete or backspace was just pressed
    }
}
</code></pre>
<h2 id="keyboard-events"><a class="header" href="#keyboard-events">Keyboard Events</a></h2>
<p>To get all keyboard activity, you can use
<a href="https://docs.rs/bevy/0.7.0/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_events(
    mut key_evr: EventReader&lt;KeyboardInput&gt;,
) {
    use bevy::input::ElementState;

    for ev in key_evr.iter() {
        match ev.state {
            ElementState::Pressed =&gt; {
                println!(&quot;Key press: {:?} ({})&quot;, ev.key_code, ev.scan_code);
            }
            ElementState::Released =&gt; {
                println!(&quot;Key release: {:?} ({})&quot;, ev.key_code, ev.scan_code);
            }
        }
    }
}
</code></pre>
<p>These events give you both the Key Code and Scan Code.
The Scan Code is represented as an arbitrary <code>u32</code> integer ID.</p>
<h2 id="key-codes-and-scan-codes"><a class="header" href="#key-codes-and-scan-codes">Key Codes and Scan Codes</a></h2>
<p>Keyboard keys can be identified by Key Code or Scan Code.</p>
<p>Key Codes represent the symbol/letter on each key and are dependent on the
keyboard layout currently active in the user's OS. Bevy represents them with
the <a href="https://docs.rs/bevy/0.7.0/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a> enum.</p>
<p>Scan Codes represent the physical key on the keyboard, regardless of the
system layout. Unfortunately, they are just arbitrary integer IDs and
platform-dependent. There is no easy way to know what to display in the
game's UI for the user, from the scan code.</p>
<p>Additionally, support for using Scan Codes in Bevy is limited. This can be
annoying for people with multiple or non-QWERTY keyboard layouts.</p>
<p>See <a href="https://github.com/bevyengine/bevy/issues/2052">Bevy Issue #2052</a> for efforts to improve this situation.</p>
<h3 id="layout-agnostic-key-bindings"><a class="header" href="#layout-agnostic-key-bindings">Layout-Agnostic Key Bindings</a></h3>
<p>You could try to provide a better experience for players, regardless of these
limitations, by:</p>
<ul>
<li>Internally recording and storing key bindings as Scan Codes</li>
<li>Handling input using <a href="input/keyboard.html#keyboard-events">events</a> and using Scan Codes to identify the key</li>
<li>Storing Key Codes only for displaying the name of a key in the UI</li>
</ul>
<p>Doing things this way means that users with multiple keyboard layouts in the
OS will not have their keybindings break if they accidentally switch their
layout mid-game, or start the game with the wrong layout.</p>
<p>Unfortunately, this also means your game UI will display the symbol from the
layout that was used when registering the key bindings. This may be wrong
or confusing if the user has changed the currently active layout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/mouse_input.rs"><code>mouse_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/mouse_input_events.rs"><code>mouse_input_events</code></a>.</p>
<hr />
<h2 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h2>
<p>Similar to <a href="input//input/keyboard.html">keyboard input</a>, mouse buttons are available
as an <a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html"><code>Input</code></a> state <a href="input//programming/res.html">resource</a>, as well as
<a href="input//programming/events.html">events</a>.</p>
<p>You can check the state of specific mouse buttons using
<a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/enum.MouseButton.html"><code>Input&lt;MouseButton&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_input(
    buttons: Res&lt;Input&lt;MouseButton&gt;&gt;,
) {
    if buttons.just_pressed(MouseButton::Left) {
        // Left button was pressed
    }
    if buttons.just_released(MouseButton::Left) {
        // Left Button was released
    }
    if buttons.pressed(MouseButton::Right) {
        // Right Button is being held down
    }
    // we can check multiple at once with `.any_*`
    if buttons.any_just_pressed([MouseButton::Left, MouseButton::Right]) {
        // Either the left or the right button was just pressed
    }
}
</code></pre>
<p>To get all press/release activity, use
<a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_events(
    mut mousebtn_evr: EventReader&lt;MouseButtonInput&gt;,
) {
    use bevy::input::ElementState;

    for ev in mousebtn_evr.iter() {
        match ev.state {
            ElementState::Pressed =&gt; {
                println!(&quot;Mouse button press: {:?}&quot;, ev.button);
            }
            ElementState::Released =&gt; {
                println!(&quot;Mouse button release: {:?}&quot;, ev.button);
            }
        }
    }
}
</code></pre>
<h2 id="mouse-scrolling--wheel"><a class="header" href="#mouse-scrolling--wheel">Mouse Scrolling / Wheel</a></h2>
<p>To detect scrolling input, use <a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn scroll_events(
    mut scroll_evr: EventReader&lt;MouseWheel&gt;,
) {
    use bevy::input::mouse::MouseScrollUnit;
    for ev in scroll_evr.iter() {
        match ev.unit {
            MouseScrollUnit::Line =&gt; {
                println!(&quot;Scroll (line units): vertical: {}, horizontal: {}&quot;, ev.y, ev.x);
            }
            MouseScrollUnit::Pixel =&gt; {
                println!(&quot;Scroll (pixel units): vertical: {}, horizontal: {}&quot;, ev.y, ev.x);
            }
        }
    }
}
</code></pre>
<p>The <a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a> enum is important: it tells
you the type of scroll input. <code>Line</code> is for hardware with fixed steps, like
the wheel on desktop mice. <code>Pixel</code> is for hardware with smooth (fine-grained)
scrolling, like laptop touchpads.</p>
<p>You should probably handle each of these differently (with different
sensitivity settings), to provide a good experience on both types of hardware.</p>
<h2 id="mouse-motion"><a class="header" href="#mouse-motion">Mouse Motion</a></h2>
<p>Use this if you don't care about the exact position of the mouse cursor,
but rather you just want to see how much it moved from frame to frame. This
is useful for things like controlling a 3D camera.</p>
<p>Use <a href="https://docs.rs/bevy/0.7.0/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a> <a href="input//programming/events.html">events</a>. Whenever the
mouse is moved, you will get an event with the delta.</p>
<pre><code class="language-rust no_run noplayground">fn mouse_motion(
    mut motion_evr: EventReader&lt;MouseMotion&gt;,
) {
    for ev in motion_evr.iter() {
        println!(&quot;Mouse moved: X: {} px, Y: {} px&quot;, ev.delta.x, ev.delta.y);
    }
}
</code></pre>
<p>You might want to <a href="input//window/mouse-grab.html">grab/lock the mouse inside the game
window</a>.</p>
<h2 id="mouse-cursor-position"><a class="header" href="#mouse-cursor-position">Mouse Cursor Position</a></h2>
<p>Use this if you want to accurately track the position pointer / cursor. This is
useful for things like clicking and hovering over objects in your game or UI.</p>
<p>You can get the current coordinates of the mouse pointer, from the respective
<a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.Window.html"><code>Window</code></a> (if the mouse is currently inside that window):</p>
<pre><code class="language-rust no_run noplayground">fn cursor_position(
    windows: Res&lt;Windows&gt;,
) {
    // Games typically only have one window (the primary window).
    // For multi-window applications, you need to use a specific window ID here.
    let window = windows.get_primary().unwrap();

    if let Some(_position) = window.cursor_position() {
        // cursor is inside the window, position given
    } else {
        // cursor is not inside the window
    }
}
</code></pre>
<p>To detect when the pointer is moved, use <a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a>
<a href="input//programming/events.html">events</a> to get the updated coordinates:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_events(
    mut cursor_evr: EventReader&lt;CursorMoved&gt;,
) {
    for ev in cursor_evr.iter() {
        println!(
            &quot;New cursor position: X: {}, Y: {}, in Window ID: {:?}&quot;,
            ev.position.x, ev.position.y, ev.id
        );
    }
}
</code></pre>
<p>Note that you can only get the position of the mouse inside a window;
you cannot get the global position of the mouse in the whole OS Desktop /
on the screen as a whole.</p>
<p>To track when the mouse cursor enters and leaves your window(s), use
<a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a> and <a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a>
<a href="input//programming/events.html">events</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text--character-input"><a class="header" href="#text--character-input">Text / Character Input</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/char_input_events.rs"><code>char_input_events</code></a>.</p>
<hr />
<p>Use this (<em>not</em> <a href="input//input/keyboard.html">keyboard input</a>) if you want to implement
text input in a Bevy app. This way, everything works as the user expects
from their operating system, including Unicode support.</p>
<p>Bevy will produce a <a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.ReceivedCharacter.html"><code>ReceivedCharacter</code></a>
<a href="input//programming/events.html">event</a> for every Unicode code point coming from the OS.</p>
<p>This example shows how to let the user input text into a string (here stored
as a <a href="input//programming/local.html">local resource</a>).</p>
<pre><code class="language-rust no_run noplayground">/// prints every char coming in; press enter to echo the full string
fn text_input(
    mut char_evr: EventReader&lt;ReceivedCharacter&gt;,
    keys: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut string: Local&lt;String&gt;,
) {
    for ev in char_evr.iter() {
        println!(&quot;Got char: '{}'&quot;, ev.char);
        string.push(ev.char);
    }

    if keys.just_pressed(KeyCode::Return) {
        println!(&quot;Text input: {}&quot;, *string);
        string.clear();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gamepad-controller-joystick"><a class="header" href="#gamepad-controller-joystick">Gamepad (Controller, Joystick)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/gamepad_input.rs"><code>gamepad_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/gamepad_input_events.rs"><code>gamepad_input_events</code></a>.</p>
<hr />
<p>Bevy has support for gamepad input hardware: console controllers,
joysticks, etc. Many different kinds of hardware should work, but
if your device is not supported, you should file an issue with the
<a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> project.</p>
<h2 id="gamepad-ids"><a class="header" href="#gamepad-ids">Gamepad IDs</a></h2>
<p>Bevy assigns a unique ID (<a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.Gamepad.html"><code>Gamepad</code></a>) to each connected
gamepad. This lets you associate the device with a specific player and
distinguish which one your inputs are coming from.</p>
<p>You can use the <a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a> <a href="input//programming/res.html">resource</a> to list
the IDs of all the currently connected gamepad devices, or to check the
status of a specific one.</p>
<p>To detect when gamepads are connected or disconnected, you can use
<a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>Example showing how to remember the first connected gamepad ID:</p>
<pre><code class="language-rust no_run noplayground">/// Simple resource to store the ID of the connected gamepad.
/// We need to know which gamepad to use for player input.
struct MyGamepad(Gamepad);

fn gamepad_connections(
    mut commands: Commands,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut gamepad_evr: EventReader&lt;GamepadEvent&gt;,
) {
    for GamepadEvent(id, kind) in gamepad_evr.iter() {
        match kind {
            GamepadEventType::Connected =&gt; {
                println!(&quot;New gamepad connected with ID: {:?}&quot;, id);

                // if we don't have any gamepad yet, use this one
                if my_gamepad.is_none() {
                    commands.insert_resource(MyGamepad(*id));
                }
            }
            GamepadEventType::Disconnected =&gt; {
                println!(&quot;Lost gamepad connection with ID: {:?}&quot;, id);

                // if it's the one we previously associated with the player,
                // disassociate it:
                if let Some(MyGamepad(old_id)) = my_gamepad.as_deref() {
                    if old_id == id {
                        commands.remove_resource::&lt;MyGamepad&gt;();
                    }
                }
            }
            // other events are irrelevant
            _ =&gt; {}
        }
    }
}
</code></pre>
<h2 id="handling-gamepad-inputs"><a class="header" href="#handling-gamepad-inputs">Handling Gamepad Inputs</a></h2>
<p>You can handle the analog sticks and triggers with <code>Axis&lt;GamepadAxis&gt;</code>
(<a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Axis.html"><code>Axis</code></a>, <a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadAxis.html"><code>GamepadAxis</code></a>). Buttons
can be handled with <code>Input&lt;GamepadButton&gt;</code> (<a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html"><code>Input</code></a>,
<a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>), similar to <a href="input//input/mouse.html">mouse
buttons</a> or <a href="input//input/keyboard.html">keyboard keys</a>.</p>
<p>Notice that the names of buttons in the <a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>
are vendor-neutral (like <code>South</code> and <code>East</code> instead of X/O or A/B).</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input(
    axes: Res&lt;Axis&lt;GamepadAxis&gt;&gt;,
    buttons: Res&lt;Input&lt;GamepadButton&gt;&gt;,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
) {
    let gamepad = if let Some(gp) = my_gamepad {
        // a gamepad is connected, we have the id
        gp.0
    } else {
        // no gamepad is connected
        return;
    };

    // The joysticks are represented using a separate axis for X and Y

    let axis_lx = GamepadAxis(gamepad, GamepadAxisType::LeftStickX);
    let axis_ly = GamepadAxis(gamepad, GamepadAxisType::LeftStickY);

    if let (Some(x), Some(y)) = (axes.get(axis_lx), axes.get(axis_ly)) {
        // combine X and Y into one vector
        let left_stick_pos = Vec2::new(x, y);

        // Example: check if the stick is pushed up
        if left_stick_pos.length() &gt; 0.9 &amp;&amp; left_stick_pos.y &gt; 0.5 {
            // do something
        }
    }

    // In a real game, the buttons would be configurable, but here we hardcode them
    let jump_button = GamepadButton(gamepad, GamepadButtonType::South);
    let heal_button = GamepadButton(gamepad, GamepadButtonType::East);

    if buttons.just_pressed(jump_button) {
        // button just pressed: make the player jump
    }

    if buttons.pressed(heal_button) {
        // button being held down: heal the player
    }
}
</code></pre>
<p>You can also handle gamepad inputs using <a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input_events(
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut gamepad_evr: EventReader&lt;GamepadEvent&gt;,
) {
    let gamepad = if let Some(gp) = my_gamepad {
        // a gamepad is connected, we have the id
        gp.0
    } else {
        // no gamepad is connected
        return;
    };

    for GamepadEvent(id, kind) in gamepad_evr.iter() {
        if id.0 != gamepad.0 {
            // event not from our gamepad
            continue;
        }

        use GamepadEventType::{AxisChanged, ButtonChanged};

        match kind {
            AxisChanged(GamepadAxisType::RightStickX, x) =&gt; {
                // Right Stick moved (X)
            }
            AxisChanged(GamepadAxisType::RightStickY, y) =&gt; {
                // Right Stick moved (Y)
            }
            ButtonChanged(GamepadButtonType::DPadDown, val) =&gt; {
                // buttons are also reported as analog, so use a threshold
                if *val &gt; 0.5 {
                    // button pressed
                }
            }
            _ =&gt; {} // don't care about other inputs
        }
    }
}
</code></pre>
<h2 id="gamepad-settings"><a class="header" href="#gamepad-settings">Gamepad Settings</a></h2>
<p>You can use the <a href="https://docs.rs/bevy/0.7.0/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a> <a href="input//programming/res.html">resource</a>
to configure dead-zones and other parameters of the various axes and
buttons. You can set the global defaults, as well as individually
per-axis/button.</p>
<p>Here is an example showing how to configure gamepads with custom settings
(not necessarily <em>good</em> settings, please don't copy these blindly):</p>
<pre><code class="language-rust no_run noplayground">// this should be run once, when the game is starting
// (transition entering your in-game state might be a good place to put it)
fn configure_gamepads(
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut settings: ResMut&lt;GamepadSettings&gt;,
) {
    let gamepad = if let Some(gp) = my_gamepad {
        // a gamepad is connected, we have the id
        gp.0
    } else {
        // no gamepad is connected
        return;
    };

    // add a larger default dead-zone to all axes (ignore small inputs, round to zero)
    settings.default_axis_settings.negative_low = -0.1;
    settings.default_axis_settings.positive_low = 0.1;

    // make the right stick &quot;binary&quot;, squash higher values to 1.0 and lower values to 0.0
    let right_stick_settings = AxisSettings {
        positive_high:  0.5, // values  0.5 to  1.0, become  1.0
        positive_low:   0.5, // values  0.0 to  0.5, become  0.0
        negative_low:  -0.5, // values -0.5 to  0.0, become  0.0
        negative_high: -0.5, // values -1.0 to -0.5, become -1.0
        // the raw value should change by at least this much,
        // for Bevy to register an input event:
        threshold: 0.01,
    };

    // make the triggers work in big/coarse steps, to get fewer events
    // reduces noise and precision
    let trigger_settings = AxisSettings {
        threshold: 0.2,
        // also set some conservative deadzones
        positive_high: 0.8,
        positive_low: 0.2,
        negative_high: -0.8,
        negative_low: -0.2,
    };

    // set these settings for the gamepad we use for our player
    settings.axis_settings.insert(
        GamepadAxis(gamepad, GamepadAxisType::RightStickX),
        right_stick_settings.clone()
    );
    settings.axis_settings.insert(
        GamepadAxis(gamepad, GamepadAxisType::RightStickY),
        right_stick_settings.clone()
    );
    settings.axis_settings.insert(
        GamepadAxis(gamepad, GamepadAxisType::LeftZ),
        trigger_settings.clone()
    );
    settings.axis_settings.insert(
        GamepadAxis(gamepad, GamepadAxisType::RightZ),
        trigger_settings.clone()
    );

    // for buttons (or axes treated as buttons), make them less sensitive
    let button_settings = ButtonSettings {
        // require them to be pressed almost all the way, to count
        press: 0.9,
        // require them to be released almost all the way, to count
        release: 0.1,
    };

    settings.default_button_settings = button_settings;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="touchscreen"><a class="header" href="#touchscreen">Touchscreen</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/touch_input.rs"><code>touch_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/input/touch_input_events.rs"><code>touch_input_events</code></a>.</p>
<hr />
<p>Multi-touch touchscreens are supported. You can track multiple fingers on
the screen, with position and pressure/force information. Bevy does not
offer gesture recognition.</p>
<p>The <a href="https://docs.rs/bevy/0.7.0/bevy/input/touch/struct.Touches.html"><code>Touches</code></a> <a href="input//programming/res.html">resource</a> allows you to track any
fingers currently on the screen:</p>
<pre><code class="language-rust no_run noplayground">fn touches(
    touches: Res&lt;Touches&gt;,
) {
    // There is a lot more information available, see the API docs.
    // This example only shows some very basic things.

    for finger in touches.iter() {
        if touches.just_pressed(finger.id()) {
            println!(&quot;A new touch with ID {} just began.&quot;, finger.id());
        }
        println!(
            &quot;Finger {} is at position ({},{}), started from ({},{}).&quot;,
            finger.id(),
            finger.position().x,
            finger.position().y,
            finger.start_position().x,
            finger.start_position().y,
        );
    }
}
</code></pre>
<p>Alternatively, you can use <a href="https://docs.rs/bevy/0.7.0/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn touch_events(
    mut touch_evr: EventReader&lt;TouchInput&gt;,
) {
    use bevy::input::touch::TouchPhase;
    for ev in touch_evr.iter() {
        // in real apps you probably want to store and track touch ids somewhere
        match ev.phase {
            TouchPhase::Started =&gt; {
                println!(&quot;Touch {} started at: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Moved =&gt; {
                println!(&quot;Touch {} moved to: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Ended =&gt; {
                println!(&quot;Touch {} ended at: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Cancelled =&gt; {
                println!(&quot;Touch {} cancelled at: {:?}&quot;, ev.id, ev.position);
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drag-and-drop-files"><a class="header" href="#drag-and-drop-files">Drag-and-Drop (Files)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/app/drag_and_drop.rs"><code>drag_and_drop</code></a>.</p>
<hr />
<p>Bevy supports the Drag-and-Drop gesture common on most desktop operating
systems, but only for files, not arbitrary data / objects.</p>
<p>If you drag a file (say, from the file manager app) into a Bevy app, Bevy
will produce a <a href="https://docs.rs/bevy/0.7.0/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a> <a href="input//programming/events.html">event</a>,
containing the path of the file that was dropped in.</p>
<p>Usually, in a graphical app, you may want to do different things depending
on where it was dropped. For this, you can <a href="input//input/mouse.html">check the mouse cursor
position</a>, or use a Bevy UI <a href="https://docs.rs/bevy/0.7.0/bevy/ui/enum.Interaction.html"><code>Interaction</code></a>.</p>
<p>For example, here is how to detect if a file was dropped onto a
special UI widget/element (which we identify with a custom marker
<a href="input//programming/ec.html#components">component</a>):</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyDropTarget;

fn file_drop(
    mut dnd_evr: EventReader&lt;FileDragAndDrop&gt;,
    query_ui_droptarget: Query&lt;&amp;Interaction, With&lt;MyDropTarget&gt;&gt;,
) {
    for ev in dnd_evr.iter() {
        println!(&quot;{:?}&quot;, ev);
        if let FileDragAndDrop::DroppedFile { id, path_buf } = ev {
            println!(&quot;Dropped file with path: {:?}&quot;, path_buf);

            if id.is_primary() {
                // it was dropped over the main window
            }

            for interaction in query_ui_droptarget.iter() {
                if *interaction == Interaction::Hovered {
                    // it was dropped over our UI element
                    // (our UI element is being hovered over)
                }
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-musical-instrument"><a class="header" href="#midi-musical-instrument">MIDI (Musical Instrument)</a></h1>
<p>Bevy does not yet have this built-in, but there is a <a href="input//setup/unofficial-plugins.html">3rd-party
plugin</a> available: <a href="https://github.com/BlackPhlox/bevy_midi"><code>bevy_midi</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-management"><a class="header" href="#window-management">Window Management</a></h1>
<p>This chapter covers topics related to working with the application's OS window.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-properties"><a class="header" href="#window-properties">Window Properties</a></h1>
<p>Page coming soon…</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<p>See the <a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/window/window_settings.rs"><code>window_settings</code></a> example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changing-the-background-color"><a class="header" href="#changing-the-background-color">Changing the Background Color</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/window/clear_color.rs"><code>clear_color</code></a>.</p>
<hr />
<p><a href="window//code/examples/clear-color.rs">Click here for the full example code.</a></p>
<hr />
<p>Use the <a href="https://docs.rs/bevy/0.7.0/bevy/core_pipeline/struct.ClearColor.html"><code>ClearColor</code></a> <a href="window//programming/res.html">resource</a> to choose the
background color.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .insert_resource(ClearColor(Color::rgb(0.4, 0.4, 0.4)))
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grabbing-the-mouse"><a class="header" href="#grabbing-the-mouse">Grabbing the Mouse</a></h1>
<p><a href="window//code/examples/mouse-grab.rs">Click here for the full example code.</a></p>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/input/mouse_grab.rs"><code>mouse_grab</code></a>.</p>
<hr />
<p>You can lock/release the mouse cursor using bevy's <a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/window/window_settings.rs">window settings
API</a>.</p>
<p>Here is an example that locks and hides the cursor in the primary window
on <a href="window//input/mouse.html">mouse click</a> and releases it when <a href="window//input/keyboard.html">pressing
<code>Esc</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_grab_system(
    mut windows: ResMut&lt;Windows&gt;,
    btn: Res&lt;Input&lt;MouseButton&gt;&gt;,
    key: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    let window = windows.get_primary_mut().unwrap();

    if btn.just_pressed(MouseButton::Left) {
        window.set_cursor_lock_mode(true);
        window.set_cursor_visibility(false);
    }

    if key.just_pressed(KeyCode::Escape) {
        window.set_cursor_lock_mode(false);
        window.set_cursor_visibility(true);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-the-window-icon"><a class="header" href="#setting-the-window-icon">Setting the Window Icon</a></h1>
<p><a href="window//code/examples/window-icon.rs">Click here for the full example code.</a></p>
<hr />
<p>You might want to set a custom Window Icon. On Windows and Linux, this is
the icon image shown in the window title bar (if any) and task bar (if any).</p>
<p>Unfortunately, Bevy does not yet provide an easy and ergonomic built-in way
to do this. However, it can be done via the <code>winit</code> APIs.</p>
<p>The way shown here is quite hacky. To save on code complexity, instead of
using Bevy's asset system to load the image in the background, we bypass
the assets system and directly load the file using the <code>image</code> library.</p>
<p>There is some WIP on adding a proper API for this to Bevy; see <a href="https://github.com/bevyengine/bevy/pull/2268">PR
#2268</a> and <a href="https://github.com/bevyengine/bevy/issues/1031">Issue #1031</a>.</p>
<p>This example shows how to set the icon for the primary/main window, from
a Bevy startup system.</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::WindowId;
use bevy::winit::WinitWindows;
use winit::window::Icon;

fn set_window_icon(
    // we have to use `NonSend` here
    windows: NonSend&lt;WinitWindows&gt;,
) {
    let primary = windows.get_window(WindowId::primary()).unwrap();

    // here we use the `image` crate to load our icon data from a png file
    // this is not a very bevy-native solution, but it will do
    let (icon_rgba, icon_width, icon_height) = {
        let image = image::open(&quot;my_icon.png&quot;)
            .expect(&quot;Failed to open icon path&quot;)
            .into_rgba8();
        let (width, height) = image.dimensions();
        let rgba = image.into_raw();
        (rgba, width, height)
    };

    let icon = Icon::from_rgba(icon_rgba, icon_width, icon_height).unwrap();

    primary.set_window_icon(Some(icon));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(set_window_icon)
        .run();
}
</code></pre>
<p>Note: that <a href="https://docs.rs/bevy/0.7.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> is a <a href="window//programming/non-send.html">non-send
resource</a>.</p>
<p>Note: you need to add <code>winit</code> to your project's dependencies, and it must
be the same version as the one used by Bevy. You can use <code>cargo tree</code> or
check <code>Cargo.lock</code> to see which is the correct version. As of Bevy 0.7,
that should be <code>winit = &quot;0.26&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-2d"><a class="header" href="#bevy-2d">Bevy 2D</a></h1>
<p>This chapter covers topics relevant to making 2D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d-camera-setup"><a class="header" href="#2d-camera-setup">2D Camera Setup</a></h1>
<p>Page coming soon…</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprites-and-atlases"><a class="header" href="#sprites-and-atlases">Sprites and Atlases</a></h1>
<p>Page coming soon…</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-3d"><a class="header" href="#bevy-3d">Bevy 3D</a></h1>
<p>This chapter covers topics relevant to making 3D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3d-camera-setup"><a class="header" href="#3d-camera-setup">3D Camera Setup</a></h1>
<p>Page coming soon…</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3d-models-and-scenes-gltf"><a class="header" href="#3d-models-and-scenes-gltf">3D Models and Scenes (GLTF)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/3d/load_gltf.rs"><code>load_gltf</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/3d/update_gltf_scene.rs"><code>update_gltf_scene</code></a>.</p>
<hr />
<p>Bevy uses the GLTF 2.0 file format for 3D assets.</p>
<p>(other formats such as Wavefront OBJ may be unofficially available via 3rd-party plugins)</p>
<h2 id="quick-start-spawning-3d-models-into-your-world"><a class="header" href="#quick-start-spawning-3d-models-into-your-world">Quick-Start: Spawning 3D Models into your World</a></h2>
<p>The simplest use case is to just load a &quot;3D model&quot; and spawn it into the game world.</p>
<p>&quot;3D models&quot; can often be complex, consisting of multiple parts. Think of a
house: the windows, roof, doors, etc., are separate pieces, that are likely
made of multiple meshes, materials, and textures. Bevy would technically
need multiple ECS Entities to represent and render the whole thing.</p>
<p>This is why your GLTF &quot;model&quot; is represented by Bevy as a Scene.  This way,
you can easily spawn it, and Bevy will create all the relevant <a href="3d//features/parent-child.html">child
entities</a> and configure them correctly.</p>
<p>So that you can treat the whole thing as &quot;a single object&quot; and position it
in the world, you can just <a href="3d//features/parent-child.html">spawn it under a parent entity</a>,
and use its <a href="3d//features/transforms.html">transform</a>.</p>
<pre><code class="language-rust no_run noplayground">fn spawn_gltf(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    // note that we have to include the `Scene0` label
    let my_gltf = ass.load(&quot;my.glb#Scene0&quot;);

    // to be able to position our 3d model:
    // spawn a parent entity with a TransformBundle
    // and spawn our gltf as a scene under it
    commands.spawn_bundle(TransformBundle {
        local: Transform::from_xyz(2.0, 0.0, -5.0),
        global: GlobalTransform::identity(),
    }).with_children(|parent| {
        parent.spawn_scene(my_gltf);
    });
}
</code></pre>
<p>If your GLTF Scene represents &quot;a whole level/map&quot;, rather than &quot;an individual
3d model&quot;, and you don't need to move it around, you can just spawn the
scene directly, without creating a parent entity.</p>
<p>Also, this example assumes that you have a simple GLTF file containing only
one &quot;default scene&quot;. GLTF is a very flexible file format. A single file can
contain many &quot;models&quot; or more complex &quot;scenes&quot;. To get a better understanding
of GLTF and possible workflows, read the rest of this page. :)</p>
<h2 id="introduction-to-gltf"><a class="header" href="#introduction-to-gltf">Introduction to GLTF</a></h2>
<p>GLTF is a modern open standard for exchanging 3D assets between different
3D software applications, like game engines and 3D modeling software.</p>
<p>The GLTF file format has two variants: human-readable ascii/text (<code>*.gltf</code>)
and binary (<code>*.glb</code>). The binary format is more compact and preferable
for packaging the assets with your game. The text format may be useful for
development, as it can be easier to manually inspect using a text editor.</p>
<p>A GLTF file can contain many objects (sub-assets): meshes, materials,
textures, scenes. When loading a GLTF file, Bevy will load all of the assets
contained inside. They will be mapped to the <a href="3d//builtins.html#assets">appropriate Bevy-internal
asset types</a>.</p>
<h2 id="the-gltf-sub-assets"><a class="header" href="#the-gltf-sub-assets">The GLTF sub-assets</a></h2>
<p>GLTF terminology can be confusing, as it sometimes uses the same words to
refer to different things, compared to Bevy. This section will try explain
the various GLTF terms.</p>
<p>To understand everything, it helps to mentally consider how these concepts are
represented in different places: in your 3D modeling software (like Blender),
in the GLTF file itself, and in Bevy.</p>
<p>GLTF <strong>Scenes</strong> are what you spawn into your game world. This is typically
what you see on the screen in your 3D modeling software. Scenes combine
all of the data needed for the game engine to create all the needed
entities to represent what you want. Conceptually, think of a scene as one
&quot;unit&quot;. Depending on your use case, this could be one &quot;3d model&quot;,
or even a whole map or game level. In Bevy, these are represented as Bevy
Scenes with all the child ECS entities.</p>
<p>GLTF Scenes are composed of GLTF <strong>Nodes</strong>. These describe the &quot;objects&quot;
in the scene, typically GLTF Meshes, but can also be other things like
Cameras and Lights. Each GLTF Node has a transform for positioning it in
the scene.  GLTF Nodes do not have a core Bevy equivalent; Bevy just uses
this data to create the ECS Entities inside of a Scene. Bevy has a special
<a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> asset type, if you need access to this data.</p>
<p>GLTF <strong>Meshes</strong> represent one conceptual &quot;3D object&quot;. These correspond
to the &quot;objects&quot; in your 3D modeling software. GLTF Meshes may be complex
and composed of multiple smaller pieces, called GLTF Primitives, each of
which may use a different Material. GLTF Meshes do not have a core Bevy
equivalent, but there is a special <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a> asset type,
which describes the primitives.</p>
<p>GLTF <strong>Primitives</strong> are individual &quot;units of 3D geometry&quot;, for the purposes of
rendering. They contain the actual geometry / vertex data, and reference the
Material to be used when drawing. In Bevy, each GLTF Primitive is represented
as a Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> asset, and must be spawned as a separate ECS
Entity to be rendered.</p>
<p>GLTF <strong>Materials</strong> describe the shading parameters for the surfaces of
your 3D models. They have full support for Physically-Based Rendering
(PBR). They also reference the textures to use. In Bevy, they are represented
as <a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a> assets, as used by the Bevy
PBR 3D renderer.</p>
<p>GLTF <strong>Textures</strong> (images) can be embedded inside the GLTF file, or stored
externally in separate image files alongside it. For example, you can have
your textures as separate PNG or JPEG files for ease of development, or
package them all inside the GLTF file for ease of distribution. In Bevy,
GLTF textures are loaded as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets.</p>
<p>GLTF <strong>Samplers</strong> describe the settings for how the GPU should use a
given Texture. Bevy does not keep these separate; this data is stored
inside the Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset (the <code>sampler</code> field of type
<a href="https://docs.rs/bevy/0.7.0/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a>).</p>
<p>GLTF <strong>Animations</strong> describe animations that interpolate various values,
such as transforms or mesh skeletons, over time. In Bevy, these are loaded
as <a href="https://docs.rs/bevy/0.7.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a> assets.</p>
<h2 id="gltf-usage-patterns"><a class="header" href="#gltf-usage-patterns">GLTF Usage Patterns</a></h2>
<p>A single GLTF file can contain any number of sub-assets of any of the above
types, referring to each other however they like.</p>
<p>Because GLTF is so flexible, it is up to you how to structure your assets.</p>
<p>A single GLTF file might be used:</p>
<ul>
<li>To represent a single &quot;3D model&quot;, containing a single
GLTF Scene with the model, so you can spawn it into your game.</li>
<li>To represent a whole level, as a GLTF Scene, possibly also including
the camera. This lets you load and spawn a whole level/map at once.</li>
<li>To represent sections of a level/map, such as a rooms, as separate GLTF Scenes.
They can share meshes and textures if needed.</li>
<li>To contain a set of many different &quot;3D models&quot;, each as a separate GLTF Scene.
This lets you load and manage the whole collection at once and spawn them individually as needed.</li>
<li>… others?</li>
</ul>
<h2 id="tools-for-creating-gltf-assets"><a class="header" href="#tools-for-creating-gltf-assets">Tools for Creating GLTF Assets</a></h2>
<p>If you are using a recent version of Blender (2.8+) for 3D modeling, GLTF
is supported out of the box. Just export and choose GLTF as the format.</p>
<p>For other tools, you can try these exporter plugins:</p>
<ul>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Blender_to_glTF">Old Blender (2.79)</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/3DSMax_to_glTF">3DSMax</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Maya_to_glTF">Autodesk Maya</a>
<ul>
<li>(or this <a href="https://kashika.co.jp/product/gltfexporter/">alternative</a>)</li>
</ul>
</li>
</ul>
<h2 id="using-gltf-sub-assets-in-bevy"><a class="header" href="#using-gltf-sub-assets-in-bevy">Using GLTF Sub-Assets in Bevy</a></h2>
<p>The various sub-assets contained in a GLTF file can be addressed in two ways:</p>
<ul>
<li>by index (integer id, in the order they appear in the file)</li>
<li>by name (text string, the names you set in your 3D modeling software
when creating the asset, which can be exported into the GLTF)</li>
</ul>
<p>To get handles to the respective assets in Bevy, you can use the
<a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="3d/gltf.html#gltf-master-asset">&quot;master asset&quot;</a>, or alternatively,
<a href="3d/gltf.html#assetpath-with-labels">AssetPath with Labels</a>.</p>
<h3 id="gltf-master-asset"><a class="header" href="#gltf-master-asset"><code>Gltf</code> master asset</a></h3>
<p>If you have a complex GLTF file, this is likely the most flexible and useful
way of navigating its contents and using the different things inside.</p>
<p>You have to wait for the GLTF file to load, and then use the <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> asset.</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::Gltf;

/// Helper resource for tracking our asset
struct MyAssetPack(Handle&lt;Gltf&gt;);

fn load_gltf(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    let gltf = ass.load(&quot;my_asset_pack.glb&quot;);
    commands.insert_resource(MyAssetPack(gltf));
}

fn spawn_gltf_objects(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
) {
    // if the GLTF has loaded, we can navigate its contents
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // spawn the first scene in the file
        commands.spawn_scene(gltf.scenes[0].clone());

        // spawn the scene named &quot;YellowCar&quot;
        // do it under a parent entity, to position it in the world
        commands.spawn_bundle(TransformBundle {
            local: Transform::from_xyz(1.0, 2.0, 3.0),
            global: GlobalTransform::identity(),
        }).with_children(|parent| {
            parent.spawn_scene(gltf.named_scenes[&quot;YellowCar&quot;].clone());
        });

        // PERF: the `.clone()`s are just for asset handles, don't worry :)
    }
}
</code></pre>
<p>For a more convoluted example, say we want to directly create a 3D PBR
entity, for whatever reason. (This is not recommended; you should probably
just use scenes)</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::GltfMesh;

fn gltf_manual_entity(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
    assets_gltfmesh: Res&lt;Assets&lt;GltfMesh&gt;&gt;,
) {
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // Get the GLTF Mesh named &quot;CarWheel&quot;
        // (unwrap safety: we know the GLTF has loaded already)
        let carwheel = assets_gltfmesh.get(&amp;gltf.named_meshes[&quot;CarWheel&quot;]).unwrap();

        // Spawn a PBR entity with the mesh and material of the first GLTF Primitive
        commands.spawn_bundle(PbrBundle {
            mesh: carwheel.primitives[0].mesh.clone(),
            // (unwrap: material is optional, we assume this primitive has one)
            material: carwheel.primitives[0].material.clone().unwrap(),
            ..Default::default()
        });
    }
}
</code></pre>
<h3 id="assetpath-with-labels"><a class="header" href="#assetpath-with-labels">AssetPath with Labels</a></h3>
<p>This is another way to access specific sub-assets. It is less reliable,
but may be easier to use in some cases.</p>
<p>Use the <a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a> to convert a path string into a
<a href="https://docs.rs/bevy/0.7.0/bevy/asset/struct.Handle.html"><code>Handle</code></a>.</p>
<p>The advantage is that you can get handles to your sub-assets immediately,
even if your GLTF file hasn't loaded yet.</p>
<p>The disadvantage is that it is more error-prone. If you specify a sub-asset
that doesn't actually exist in the file, or mis-type the label, or use the
wrong label, it will just silently not work. Also, currently only using a
numerial index is supported. You cannot address sub-assets by name.</p>
<pre><code class="language-rust no_run noplayground">fn use_gltf_things(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    // spawn the first scene in the file
    let scene0 = ass.load(&quot;my_asset_pack.glb#Scene0&quot;);
    commands.spawn_scene(scene0);

    // spawn the second scene under a parent entity
    // (to move it)
    let scene1 = ass.load(&quot;my_asset_pack.glb#Scene1&quot;);
    commands.spawn_bundle(TransformBundle {
        local: Transform::from_xyz(1.0, 2.0, 3.0),
        global: GlobalTransform::identity(),
    }).with_children(|parent| {
        parent.spawn_scene(scene1);
    });
}
</code></pre>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<p>The <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> and <a href="https://docs.rs/bevy/0.7.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>
asset types are only useful to help you navigate the contents of
your GLTF file. They are not core Bevy renderer types, and not used
by Bevy in any other way. The Bevy renderer expects Entities with
<a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>; for that you need the
<a href="https://docs.rs/bevy/0.7.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.7.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>.</p>
<h2 id="bevy-limitations"><a class="header" href="#bevy-limitations">Bevy Limitations</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
<li>Bevy's renderer requires all meshes/primitives to have per-vertex positions,
UVs, and normals. Make sure all of this data is included.</li>
<li>Meshes/primitives without textures (if the material is just a solid color)
must still include UVs regardless. Bevy will not render meshes without UVs.</li>
<li>When using normal maps in your material, tangents must also be included in the mesh.
Assets with normal maps but without tangents are valid; other software would
typically autogenerate the tangents if they are missing, but Bevy does not support
this yet. Be sure to tick the checkbox for including tangents when exporting.</li>
<li>Spot lights are not supported. Bevy currently only has Point lights and Directional lights.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-programada-enkadraĵo-framework"><a class="header" href="#bevy-programada-enkadraĵo-framework">Bevy Programada Enkadraĵo (Framework)</a></h1>
<p>Ĉi tiu ĉapitro prezentas la apartaĵojn de la Bevy kerna programada enkadraĵo. Ĝi kovras na la EKS (Ent-Komponantan Sistemon), Aplikaĵom kaj Planadon.</p>
<p>Por ekzemploj de programad-ŝablonoj vidu la <a href="/patterns.html">Programadaj
Ŝablonoj</a> ĉapitron.</p>
<p>Tuta scio de ĉi tiu ĉapitro estas utila, eĉ se vi deziras uzi na Bevy kiel io alia ol ludmotoro. Ekzemple, uzado nur de EKS por scienca simulado.</p>
<p>Tial ĉi tiu ĉapitro ne kovras la ludmotorajn partojn de Bevy. Tiuj apartaĵoj estas kovritaj en aliaj ĉapitro de la libro, kiel la <a href="/features.html">Kerno de Bevy Ludmotoro</a> ĉapitro.</p>
<p>Includes concise explanations of each core concept, with code snippets to
show how it might be used in a game. Care is taken to point out any important
considerations for using each feature and to recommend known good practices.</p>
<p>Ĝi inkluzivas mallongajn klarigojn pri ĉiu kernkoncepto kun kodaj fragmentoj, montrantaj, kiel ĝi povas esti uzata en la ludo. Oni precipe zorgas, ke indiku gravajn konsiderojn pri uzado de ĉiu funkcio kaj rekomendu konatajn plej bonajn praktikojn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eks-kiel-datuma-strukturo"><a class="header" href="#eks-kiel-datuma-strukturo">EKS kiel Datuma Strukturo</a></h1>
<p>Aktualaj oficialaj ekzemploj:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<p>Ankaŭ vizitu finitajn ludekzemplojn:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>Bevy konservas kaj kontrolas tutan vian datumon por vi, uzante na la Bevy EKS
(Ent-Komponanta Sistemo).</p>
<p>Koncipe vi povas pensi pri ĉi tio kiel pri tabeloj, kvazaŭ en datumbazo. Viaj diversaj datumtipoj (Komponantoj) estas kiel &quot;kolonoj&quot; de tabelo, kie povas ekzisti arbitre multaj &quot;vicoj&quot; (Entoj), enhavantaj valorojn de ĉiu komponanto.</p>
<p>Ekzemple, vi povas krei <code>Health</code> komponanton por via ludo. Tiam vi povas havi multajn entojn, prezentantajn malsamajn aferojn en via ludo, kiel ludanto, NLRoj (Ne Ludantaj Roluloj), aŭ monstroj, ĉiuj el kiuj povas havi <code>Health</code> valoron (samkiel aliajn signifajn komponantojn).</p>
<p>Ĝi faciligas krei ludan logikon (<a href="programming//programming/systems.html">Sistemoj</a>), kiu povas funkcii kun iu ento kun necesaj komponantoj (kiel sano-damaĝa sistemo por ĉio, kio havas na <code>Health</code>), sendepende de tio, ĉu ĝi estas la ludanto, NLR aŭ monstro (aŭ io ajn). Ĉi tio farigas vian ludlogikon tre reuzebla kaj universala.</p>
<p>La aro de komponantoj, kiujn havas donita ento, estas nomita Enta Arketipo.</p>
<p>NB, ke entoj ne estas limigitaj al nur &quot;objektoj en la ludmondo&quot;. EKS estas ĝeneraluzebla datumstrukturo. Vi povas krei entojn kaj komponantojn por konservi ajnajn datumojn.</p>
<h2 id="plenumeco"><a class="header" href="#plenumeco">Plenumeco</a></h2>
<p>Bevy havas saĝan planad-algoritmon, kiu lanĉas viajn sistemojn paralele laŭ ebleco. Ĝi faras ĉi tion aŭtomate, kiam viaj funkcioj ne bezonas konfliktantan atingon al la sama datumo. Via ludo skalos por funkcii per pluraj CPU-kernoj &quot;senpage&quot;; tio estas, sen bezono de ekstra disvolva penado de vi.</p>
<p>Por pliigi la probablecon de samtempeco, vi povas farigi vian datumon kaj kodon pli detaligitaj. Dividu vian datumon en pli malgrandajn tipojn / <code>struct</code>-ojn. Dividu vian logikon en multajn pli malgrandajn sistemojn / funkciojn. Igu ĉiun sistemon havi atingon nur al la datumo, kiu estas aktuala por ĝi. Ju malpli da atingaj konfliktoj estos, des pli rapide via ludo funkcios.</p>
<p>La ĝenerala regulo de Bevy estas: ju pli da detalo, des pli bone.</p>
<h2 id="rimarko-por-programistoj-venantaj-el-objekt-orientitaj-lingvoj"><a class="header" href="#rimarko-por-programistoj-venantaj-el-objekt-orientitaj-lingvoj">Rimarko por Programistoj, venantaj el Objekt-Orientitaj Lingvoj</a></h2>
<p>Vi eble kutimis pensi laŭ &quot;objektklasoj&quot;. Ekzemple, vi povus difini grandan monolitan <code>struct Player</code>, enhavantan ĉiujn kampojn/ecojn de la ludanto.</p>
<p>En Bevy, tion oni konsideras kiel malbona praktiko, ĉar fari ĉi tion povas malfaciligi laboron kun viaj datumoj kaj limigi plenumecon.</p>
<p>Anstataŭe, vi devus fari aferojn grajnecaj, kiam diversaj datumoj povas esti atingitaj sendepende.</p>
<p>Ekzemple, prezentu la Ludanton en via ludo kiel ento, kunmetita el apartaj komponantspecoj (apartaj <code>struct</code>-oj) por aferoj kiel la sano, XP, aŭ kio ajn gravas por via ludo. Vi ankaŭ povas ligi normajn Bevy-komponantojn al ĝi kiel <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transformo</code></a> (<a href="programming//features/transforms.html">klarigita ĉi tie</a>).</p>
<p>Ĉi tio faciligos al vi ellabori viajn sistemojn (luda logiko /
kondutoj), kaj ankaŭ plibonigi la lanĉan plenumecon de via ludo.</p>
<p>Tamen, io kiel <a href="https://docs.rs/bevy/0.7.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, aŭ aro de koordinatoj, ankoraŭ havas sencon kiel ununura <code>struct</code>, ĉar ĝiaj kampoj verŝajne ne estos utilaj sendepende.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>Entities are just a <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/entity/struct.Entity.html">simple integer ID</a>, that identifies a particular set of
component values.</p>
<p>To create (&quot;spawn&quot;) new entities, use <a href="programming//programming/commands.html"><code>Commands</code></a>.</p>
<h1 id="components-1"><a class="header" href="#components-1">Components</a></h1>
<p>Components are the data associated with entities.</p>
<p>To create a new component type, simply define a Rust <code>struct</code> or <code>enum</code>, and
derive the <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Health {
    hp: f32,
    extra: f32,
}
</code></pre>
<p>Types must be unique -- an entity can only have one component per Rust type.</p>
<p>Use wrapper (newtype) structs to make unique components out of simpler types:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct PlayerXp(u32);

#[derive(Component)]
struct PlayerName(String);
</code></pre>
<p>You can use empty structs to help you identify specific entities. These are
known as &quot;marker components&quot;. Useful with <a href="programming//programming/queries.html#query-filters">query filters</a>.</p>
<pre><code class="language-rust no_run noplayground">/// Add this to all menu ui entities to help identify them
#[derive(Component)]
struct MainMenuUI;

/// Marker for hostile game units
#[derive(Component)]
struct Enemy;

/// This will be used to identify the main player entity
#[derive(Component)]
struct Player;
</code></pre>
<p>Components can be accessed from <a href="programming//programming/systems.html">systems</a>, using <a href="programming//programming/queries.html">queries</a>.</p>
<p>You can add/remove components on existing entities, using <a href="programming//programming/commands.html"><code>Commands</code></a>.</p>
<h1 id="component-bundles"><a class="header" href="#component-bundles">Component Bundles</a></h1>
<p>Bundles are like &quot;templates&quot;, to make it easy to create entities with a
common set of components.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Bundle)]
struct PlayerBundle {
    xp: PlayerXp,
    name: PlayerName,
    health: Health,
    _p: Player,

    // We can nest/include another bundle.
    // Add the components for a standard Bevy Sprite:
    #[bundle]
    sprite: SpriteSheetBundle,
}
</code></pre>
<p>Bevy also considers arbitrary tuples of components as bundles:</p>
<pre><code>(ComponentA, ComponentB, ComponentC)
</code></pre>
<p>Note that you cannot <a href="programming//programming/queries.html">query</a> for a whole bundle. Bundles are just a
convenience when creating the entities. Query for the individual component types
that your <a href="programming//programming/systems.html">system</a> needs to access.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risurcoj"><a class="header" href="#risurcoj">Risurcoj</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Resources allow you to store a single global instance of some data type,
independently of entities.</p>
<p>Use them for data that is truly global for your app, such as configuration
/ settings.</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a resource. Currently,
no special trait or derive is required, but that may change in future Bevy
versions (similar to how <a href="programming//programming/ec.html#components">Components</a> require it).</p>
<p>Types must be unique; there can only be one instance of a given type.</p>
<pre><code class="language-rust no_run noplayground">struct GoalsReached {
    main_goal: bool,
    bonus: bool,
}
</code></pre>
<p>Resources can be accessed from <a href="programming//programming/systems.html">systems</a>, using <code>Res</code>/<code>ResMut</code>.</p>
<h2 id="resource-initialization"><a class="header" href="#resource-initialization">Resource Initialization</a></h2>
<p>Implement <code>Default</code> for simple resources:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct StartingLevel(usize);
</code></pre>
<p>For resources that need complex initialization, implement <code>FromWorld</code>:</p>
<pre><code class="language-rust no_run noplayground">struct MyFancyResource { /* stuff */ }

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS from here.
        // For instance, you can mutate other resources:
        let mut x = world.get_resource_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
</code></pre>
<p>You can initialize your resources at <a href="programming//programming/app-builder.html"><code>App</code> creation</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...

        // if it implements `Default` or `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()
        // if not, or if you want to set a specific value
        .insert_resource(StartingLevel(3))

        // ...
        .run();
}
</code></pre>
<p><a href="programming//programming/commands.html"><code>Commands</code></a> can be used to create/remove resources from
inside a system:</p>
<pre><code class="language-rust no_run noplayground">commands.insert_resource(GoalsReached { main_goal: false, bonus: false });
commands.remove_resource::&lt;MyResource&gt;();
</code></pre>
<p>If you insert a resource of a type that already exists, it will be overwritten.</p>
<p>Por ricevi valoron el la risurco vi povas uzi la metodon <code>into_inner()</code> kune kun konstruo <code>Option&lt;T&gt;</code> por plia sekureco:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct Health(u8);

fn main() {
	App::new()
		.insert_resource(Health(100))
		.add_system(get_health)
		.run();
}

fn get_health(health: Option&lt;ResMut&lt;Health&gt;&gt;) {
	if let Some(health) = health {
		let i = health.into_inner();
		println!(&quot;Health = {}&quot;, i.0);
	}
}

</code></pre>
<h2 id="usage-advice"><a class="header" href="#usage-advice">Usage Advice</a></h2>
<p>The choice of when to use entities/components vs. resources is typically
about how you want to access the data: globally from anywhere (resources),
or using ECS patterns (entities/components).</p>
<p>Even if there is only one of a certain thing in your game (such as the
player in a single-player game), it can be a good fit to use an entity
instead of resources, because entities are composed of multiple components,
some of which can be common with other entities. This can make your game
logic more flexible. For example, you could have a &quot;health/damage system&quot;
that works with both the player and enemies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/startup_system.rs"><code>startup_system</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/system_param.rs"><code>system_param</code></a>.</p>
<hr />
<p>Systems are functions you write, which are run by Bevy.</p>
<p>This is where you implement all your game logic.</p>
<p>These functions can only take <a href="programming//builtins.html#systemparams">special parameter types</a>,
to specify what you need access to. <a href="programming//pitfalls/into-system.html">If you use unsupported parameter types
in your function, you will get confusing compiler errors!</a></p>
<p>Some of the options are:</p>
<ul>
<li>accessing <a href="programming//programming/res.html">resources</a> using <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a></li>
<li>accessing <a href="programming//programming/ec.html#components">components of entities</a> using <a href="programming//programming/queries.html">queries</a> (<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a>)</li>
<li>creating/destroying entities, components, and resources using <a href="programming//programming/commands.html">Commands</a> (<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>)</li>
<li>sending/receiving <a href="programming//programming/events.html">events</a> using <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter</code></a>/<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader</code></a></li>
</ul>
<pre><code class="language-rust no_run noplayground">fn debug_start(
    // access resource
    start: Res&lt;StartingLevel&gt;
) {
    eprintln!(&quot;Starting on level {:?}&quot;, *start);
}
</code></pre>
<p>System parameters can be grouped into tuples (which can be nested). This is
useful for organization.</p>
<pre><code class="language-rust no_run noplayground">fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    // this resource might not exist, so wrap it in an Option
    mut c: Option&lt;ResMut&lt;ResourceC&gt;&gt;,
) {
    if let Some(mut c) = c {
        // do something
    }
}
</code></pre>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>To run your systems, you need to add them to Bevy via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...

        // run it only once at launch
        .add_startup_system(init_menu)
        .add_startup_system(debug_start)

        // run it every frame update
        .add_system(move_player)
        .add_system(enemies_ai)

        // ...
        .run();
}
</code></pre>
<p>The above is enough for simple projects.</p>
<p>As your project grows more complex, you might want to enhance your app builder
with some of the powerful tools that Bevy offers for managing when/how
your systems run, such as: <a href="programming//programming/system-order.html">explicit ordering</a> with
<a href="programming//programming/labels.html">labels</a>, <a href="programming//programming/system-sets.html">system sets</a>, <a href="programming//programming/states.html">states</a>,
<a href="programming//programming/run-criteria.html">run criteria</a>, and <a href="programming//programming/stages.html">stages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Queries let you access <a href="programming//programming/ecs-intro.html">components of entities</a>.</p>
<pre><code class="language-rust no_run noplayground">fn check_zero_health(
    // access entities that have `Health` and `Transform` components
    // get read-only access to `Health` and mutable access to `Transform`
    // optional component: get access to `Player` if it exists
    mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
    // get all matching entities
    for (health, mut transform, player) in query.iter_mut() {
        eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);

        // center if hp is zero
        if health.hp &lt;= 0.0 {
            transform.translation = Vec3::ZERO;
        }

        if let Some(player) = player {
            // the current entity is the player!
            // do something special!
        }
    }
}
</code></pre>
<p>Get the <a href="programming//programming/ec.html#components">components</a> associated with a specific
<a href="programming//programming/ec.html#entities">entity</a>:</p>
<pre><code class="language-rust no_run noplayground">    if let Ok((health, mut transform)) = query.get_mut(entity) {
        // do something with the components
    } else {
        // the entity does not have the components from the query
    }
</code></pre>
<p>Get the IDs (<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a>) of the entities you access with
your queries:</p>
<pre><code class="language-rust no_run noplayground">// add `Entity` to `Query` to get Entity IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
    for (e, /* ... */) in q.iter() {
        // `e` is the Entity ID of the entity we are accessing
    }
}
</code></pre>
<p>If you know that the query should only ever match a single entity, you can
use <code>single</code>/<code>single_mut</code>, instead of iterating:</p>
<pre><code class="language-rust no_run noplayground">fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
    let (player, mut transform) = q.single_mut();

    // do something with the player and its transform
}
</code></pre>
<p>(this will panic if the query matches more than one entity)</p>
<h2 id="bundles-1"><a class="header" href="#bundles-1">Bundles</a></h2>
<p>Queries work with individual components. If you created an entity using a
<a href="programming//programming/ec.html#component-bundles">bundle</a>, you need to query for the specific components from
that bundle that you care about.</p>
<p>A common beginner mistake is to query for the bundle type!</p>
<h2 id="query-filters"><a class="header" href="#query-filters">Query Filters</a></h2>
<p>Add query filters to narrow down the entities you get from the query.</p>
<p>Use <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.With.html"><code>With</code></a>/<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.Without.html"><code>Without</code></a> to only get entities
that have specific components.</p>
<pre><code class="language-rust no_run noplayground">fn debug_player_hp(
    // access the health, only for friendly players, optionally with name
    query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
    // get all matching entities
    for (health, name) in query.iter() {
        if let Some(name) = name {
            eprintln!(&quot;Player {} has {} HP.&quot;, name.0, health.hp);
        } else {
            eprintln!(&quot;Unknown player has {} HP.&quot;, health.hp);
        }
    }
}
</code></pre>
<p>Multiple filters can be combined:</p>
<ul>
<li>in a tuple to apply all of them (AND logic)</li>
<li>using the <code>Or&lt;(…)&gt;</code> wrapper to detect any of them (OR logic).
<ul>
<li>(note the tuple inside)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Use <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> to spawn/despawn entities, add/remove
components on existing entities, manage resources.</p>
<p>These actions do not take effect immediately; they are queued to be performed
later when it is safe to do so. See: <a href="programming//programming/stages.html">stages</a>.</p>
<p>(if you are not using stages, that means your other <a href="programming//programming/systems.html">systems</a>
will see them on the next frame update)</p>
<pre><code class="language-rust no_run noplayground">fn spawn_player(
    mut commands: Commands,
) {
    // manage resources
    commands.insert_resource(GoalsReached { main_goal: false, bonus: false });
    commands.remove_resource::&lt;MyResource&gt;();

    // create a new entity using `spawn`
    let entity_id = commands.spawn()
        // add a component
        .insert(ComponentA)
        // add a bundle
        .insert_bundle(MyBundle::default())
        // get the Entity ID
        .id();

    // shorthand for creating an entity with a bundle
    commands.spawn_bundle(PlayerBundle {
        name: PlayerName(&quot;Henry&quot;.into()),
        xp: PlayerXp(1000),
        health: Health {
            hp: 100.0, extra: 20.0
        },
        _p: Player,
        sprite: Default::default(),
    });

    // spawn another entity
    // NOTE: tuples of arbitrary components are valid bundles
    let other = commands.spawn_bundle((
        ComponentA::default(),
        ComponentB::default(),
        ComponentC::default(),
    )).id();

    // add/remove components of an existing entity
    commands.entity(entity_id)
        .insert(ComponentB)
        .remove::&lt;ComponentA&gt;()
        .remove_bundle::&lt;MyBundle&gt;();

    // despawn an entity
    commands.entity(other).despawn();
}

fn make_all_players_hostile(
    mut commands: Commands,
    query: Query&lt;Entity, With&lt;Player&gt;&gt;,
) {
    for entity in query.iter() {
        // add an `Enemy` component to the entity
        commands.entity(entity).insert(Enemy);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events-1"><a class="header" href="#events-1">Events</a></h1>
<p>Relevant official examples:
<a href="programming//programming/events.html"><code>event</code></a>.</p>
<hr />
<p>Send data between systems! Let your <a href="programming//programming/systems.html">systems</a> communicate with each other!</p>
<p>To send events, use an <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>.
To receive events, use an <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>.</p>
<p>Every reader tracks the events it has read independently, so you can handle
the same events from multiple <a href="programming//programming/systems.html">systems</a>.</p>
<pre><code class="language-rust no_run noplayground">struct LevelUpEvent(Entity);

fn player_level_up(
    mut ev_levelup: EventWriter&lt;LevelUpEvent&gt;,
    query: Query&lt;(Entity, &amp;PlayerXp)&gt;,
) {
    for (entity, xp) in query.iter() {
        if xp.0 &gt; 1000 {
            ev_levelup.send(LevelUpEvent(entity));
        }
    }
}

fn debug_levelups(
    mut ev_levelup: EventReader&lt;LevelUpEvent&gt;,
) {
    for ev in ev_levelup.iter() {
        eprintln!(&quot;Entity {:?} leveled up!&quot;, ev.0);
    }
}
</code></pre>
<p>You need to add your custom event types via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...
        .add_event::&lt;LevelUpEvent&gt;()
        .add_system(player_level_up)
        .add_system(debug_levelups)
        // ...
        .run();
}
</code></pre>
<p>Events should be your go-to data flow tool. As events can be sent from any
system and received by multiple systems, they are <em>extremely</em> versatile.</p>
<h2 id="possible-pitfalls"><a class="header" href="#possible-pitfalls">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the receiving
system before the sending system. The receiving system will only get a chance
to receive the events on the next frame update. If you need to ensure that
events are handled immediately / during the same frame, you can use <a href="programming//programming/system-order.html">explicit
system ordering</a>.</p>
<p>Events don't persist. They are stored until the end of the next frame,
after which they are lost. If your systems do not handle events every frame,
you could miss some.</p>
<p>The advantage of this design is that you don't have to worry about excessive
memory use from unhandled events.</p>
<p>If you don't like this, <a href="programming//patterns/manual-event-clear.html">you can have manual control over when events are
cleared</a> (at the risk of leaking / wasting memory if you
forget to clear them).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-builder-main-function"><a class="header" href="#app-builder-main-function">App Builder (main function)</a></h1>
<p>Relevant official examples: All of them ;)</p>
<p>In particular, check out the complete game examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>To enter the bevy runtime, you need to configure an <a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.App.html"><code>App</code></a>. The app is how you
define the structure of all the things that make up your project: <a href="programming//programming/plugins.html">plugins</a>,
<a href="programming//programming/systems.html">systems</a>, <a href="programming//programming/events.html">event</a> types, <a href="programming//programming/states.html">states</a>, <a href="programming//programming/stages.html">stages</a>…</p>
<p>Technically, the <a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.App.html"><code>App</code></a> contains the ECS World(s) (where all the data is stored)
and Schedule(s) (where all the <a href="programming//programming/systems.html">systems</a> to run are stored). For advanced use-cases,
<a href="programming//programming/sub-apps.html">Sub-apps</a> are a way to have more than one ECS World and Schedule.</p>
<p><a href="programming//programming/local.html">Local resources</a> do not need to be registered. They are part of
their respective <a href="programming//programming/systems.html">systems</a>.</p>
<p><a href="programming//programming/ec.html#components">Component</a> types do not need to be registered.</p>
<hr />
<p>Schedules cannot (yet) be modified at runtime; all <a href="programming//programming/systems.html">systems</a> you
want to run must be added/configured in the <a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.App.html"><code>App</code></a> ahead of time.</p>
<p>The data in the ECS World can be modified at any time; create/destroy your
<a href="programming//programming/ec.html">entities</a> and <a href="programming//programming/res.html">resources</a>, from <a href="programming//programming/systems.html">systems</a>
using <a href="programming//programming/commands.html">Commands</a>, or <a href="programming//programming/exclusive.html">exclusive systems</a> using
<a href="programming//programming/world.html">direct World access</a>.</p>
<p><a href="programming//programming/res.html">Resources</a> can also be initialized ahead of time, here in the
<a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.App.html"><code>App</code></a> builder.</p>
<hr />
<p>You also need to add the <a href="programming//programming/plugins.html#plugin-groups">plugin group</a> with Bevy's built-in functionality: either
<a href="https://docs.rs/bevy/0.7.0/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> if you are making a full game/app, or
<a href="https://docs.rs/bevy/0.7.0/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> for something like a headless server.</p>
<p>Note that there are some special <a href="programming//builtins.html#configuration-resources">configuration resources</a>
that must be added first, if you would like to use them, to take effect.</p>
<hr />
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // make sure to add any config resources first, before Bevy:
        .insert_resource(WindowDescriptor {
            // ...
            ..Default::default()
        }) // etc...

        // Bevy itself:
        .add_plugins(DefaultPlugins)

        // resources:
        .insert_resource(StartingLevel(3))
        // if it implements `Default` or `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()

        // events:
        .add_event::&lt;LevelUpEvent&gt;()

        // systems to run once at startup:
        .add_startup_system(spawn_player)

        // systems to run each frame:
        .add_system(player_level_up)
        .add_system(debug_levelups)
        .add_system(debug_stats_change)
        // ...

        // launch the app!
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quitting-the-app"><a class="header" href="#quitting-the-app">Quitting the App</a></h1>
<p>To cleanly shut down bevy, send an <a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.AppExit.html"><code>AppExit</code></a>
<a href="programming//programming/events.html">event</a> from any <a href="programming//programming/systems.html">system</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::AppExit;

fn exit_system(mut exit: EventWriter&lt;AppExit&gt;) {
    exit.send(AppExit);
}
</code></pre>
<p>For prototyping, bevy provides a system you can <a href="programming//programming/app-builder.html">add to your
<code>App</code></a>, to exit on pressing the <code>Esc</code> key:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(bevy::input::system::exit_on_esc_system)
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-resources"><a class="header" href="#local-resources">Local Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Local resources allow you to have per-<a href="programming//programming/systems.html">system</a> data.</p>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is a system parameter similar to
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, which gives you full mutable access to an
instance of some data type, that is independent from entities and components.</p>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>/<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a> refer to a single global
instance of the type, shared between all systems. On the other hand, every
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> parameter is a separate instance, exclusively for
that system.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyState;

fn my_system1(mut local: Local&lt;MyState&gt;) {
    // you can do anything you want with the local here
}

fn my_system2(mut local: Local&lt;MyState&gt;) {
    // the local in this system is a different instance
}
</code></pre>
<p>The type must implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> or
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a>. It is automatically initialized.</p>
<p>A system can have multiple <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Local.html"><code>Local</code></a>s of the same type.</p>
<h2 id="specify-an-initial-value"><a class="header" href="#specify-an-initial-value">Specify an initial value</a></h2>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is always automatically initialized using the
default value for the type.</p>
<p>If you need specific data, you can use a closure instead. Rust closures
that take system parameters are valid Bevy systems, just like standalone
functions. Using a closure allows you to &quot;move data into the function&quot;.</p>
<p>This example shows how to initialize some data to configure a system,
without using <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyConfig {
    magic: usize,
}

fn my_system(
    mut cmd: Commands,
    my_res: Res&lt;MyStuff&gt;,
    // note this isn't a valid system parameter
    config: &amp;MyConfig,
) {
    // TODO: do stuff
}

fn main() {
    let config = MyConfig {
        magic: 420,
    };

    App::new()
        // create a &quot;move closure&quot;, so we can use the `config`
        // variable that we created above
        .add_system(move |cmd: Commands, res: Res&lt;MyStuff&gt;| {
            // call our function from inside the closure
            my_system(cmd, res, &amp;config);
        })
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/app/plugin.rs"><code>plugin</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/app/plugin_group.rs"><code>plugin_group</code></a>.</p>
<hr />
<p>As your project grows, it can be useful to make it more modular. You can
split it into &quot;plugins&quot;.</p>
<p>Plugins are simply collections of things to be added to the <a href="programming//programming/app-builder.html">App
Builder</a>.</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app
            .init_resource::&lt;MyOtherResource&gt;()
            .add_event::&lt;MyEvent&gt;()
            .add_startup_system(plugin_init)
            .add_system(my_system);
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugin(MyPlugin)
        .run();
}
</code></pre>
<p>For internal organization in your own project, the main value of plugins
comes from not having to declare all your Rust types and functions as
<code>pub</code>, just so they can be accessible from <code>fn main</code> to be added to the
app builder. Plugins let you add things to your <a href="programming//programming/app-builder.html">app</a> from multiple
different places, like separate Rust files / modules.</p>
<p>You can decide how plugins fit into the architecture of your game.</p>
<p>Some suggestions:</p>
<ul>
<li>Create plugins for different <a href="programming//programming/states.html">states</a>.</li>
<li>Create plugins for various sub-systems, like physics or input handling.</li>
</ul>
<h2 id="plugin-groups"><a class="header" href="#plugin-groups">Plugin groups</a></h2>
<p>Plugin groups register multiple plugins at once.
Bevy's <a href="https://docs.rs/bevy/0.7.0/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> and
<a href="https://docs.rs/bevy/0.7.0/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> are examples of this.
To create your own plugin group:</p>
<pre><code class="language-rust no_run noplayground">struct MyPluginGroup;

impl PluginGroup for MyPluginGroup {
    fn build(&amp;mut self, group: &amp;mut PluginGroupBuilder) {
        group
            .add(FooPlugin)
            .add(BarPlugin);
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MyPluginGroup)
        .run();
}
</code></pre>
<p>When adding a plugin group to the <a href="programming//programming/app-builder.html">app</a>, you can disable some
plugins while keeping the rest.</p>
<p>For example, if you want to manually set up logging (with your own <code>tracing</code>
subscriber), you can disable Bevy's <a href="https://docs.rs/bevy/0.7.0/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>:</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins_with(DefaultPlugins, |plugins| {
        plugins.disable::&lt;LogPlugin&gt;()
    })
    .run();
</code></pre>
<p>Note that this simply disables the functionality, but it cannot actually
remove the code to avoid binary bloat. The disabled plugins still have to
be compiled into your program.</p>
<p>If you want to slim down your build, you should look at disabling Bevy's
default <a href="programming//setup/bevy-config.html">cargo features</a>, or depending on the various Bevy
sub-crates individually.</p>
<h2 id="publishing-crates"><a class="header" href="#publishing-crates">Publishing Crates</a></h2>
<p>Plugins give you a nice way to publish Bevy-based libraries for other people
to easily include into their projects.</p>
<p>If you intend to publish plugins as crates for public use, you should read
<a href="https://github.com/bevyengine/bevy/blob/main/docs/plugins_guidelines.md">the official guidelines for plugin authors</a>.</p>
<p>Don't forget to submit an entry to <a href="https://bevyengine.org/assets">Bevy Assets</a> on the official
website, so that people can find your plugin more easily. You can do this
by making a PR in <a href="https://github.com/bevyengine/bevy-assets">the Github repo</a>.</p>
<p>If you are interested in supporting bleeding-edge Bevy (main), <a href="programming//setup/bevy-git.html#advice-for-plugin-authors">see here
for advice</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-order-of-execution"><a class="header" href="#system-order-of-execution">System Order of Execution</a></h1>
<p>Bevy's scheduling algorithm is designed to deliver maximum performance
by running as many systems as possible in parallel across the available
CPU threads.</p>
<p>This is possible when the systems do not conflict over the data they need
to access. However, when a system needs to have mutable (exclusive) access
to a piece of data, other systems that need to access the same data cannot
be run at the same time. Bevy determines all of this information from the
system's function signature (the types of the parameters it takes).</p>
<p>In such situations, the order is <em>nondeterministic</em> by default. Bevy takes
no regard for when each system will run, and the order could even change
every frame!</p>
<h2 id="does-it-even-matter"><a class="header" href="#does-it-even-matter">Does it even matter?</a></h2>
<p>In many cases, you don't need to worry about this.</p>
<p>However, sometimes you need to rely on specific systems to run in a particular
order. For example:</p>
<ul>
<li>Maybe the logic you wrote in one of your systems needs any modifications
done to that data by another system to always happen first?</li>
<li>One system needs to receive <a href="programming//programming/events.html">events</a> sent by another system.</li>
<li>You are using <a href="programming//programming/change-detection.html">change detection</a>.</li>
</ul>
<p>In such situations, systems running in the wrong order typically causes
their behavior to be delayed until the next frame. In rare cases, depending
on your game logic, it may even result in more serious logic bugs!</p>
<p>It is up to you to decide if this is important.</p>
<p>With many things in typical games, such as juicy visual effects, it probably
doesn't matter if they get delayed by a frame. It might not be worthwhile
to bother with it. If you don't care, leaving the order ambiguous may also
result in better performance.</p>
<p>On the other hand, for things like handling the player input controls,
this would result in annoying lag, so you should probably fix it.</p>
<h2 id="explicit-system-ordering"><a class="header" href="#explicit-system-ordering">Explicit System Ordering</a></h2>
<p>If a specific system must always run before or after some other systems,
you can add ordering constraints:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // order doesn't matter for these systems:
        .add_system(particle_effects)
        .add_system(npc_behaviors)
        .add_system(enemy_movement)

        .add_system(input_handling)

        .add_system(
            player_movement
                // `player_movement` must always run before `enemy_movement`
                .before(enemy_movement)
                // `player_movement` must always run after `input_handling`
                .after(input_handling)
        )
        .run();
}
</code></pre>
<p><code>.before</code>/<code>.after</code> may be used as many times as you need on one system.</p>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>For more advanced use cases, you can use <a href="programming//programming/labels.html">labels</a>. Labels can
either be strings, or custom types (like <code>enum</code>s) that derive <code>SystemLabel</code>.</p>
<p>This allows you to affect multiple systems at once, with the same constraints. 
You can place multiple labels on one system. You can also use the same label
on multiple systems.</p>
<p>Each label is a reference point that other systems can be ordered around.</p>
<pre><code class="language-rust no_run noplayground">
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[derive(SystemLabel)]
enum MyLabel {
    Input,
    Player,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // create labels, because we want to have multiple affected systems
        .add_system(input_joystick.label(MyLabel::Input))
        .add_system(input_keyboard.label(MyLabel::Input))
        .add_system(input_touch.label(MyLabel::Input))

        // this will always run before anything labeled &quot;input&quot;
        .add_system(input_parameters.before(MyLabel::Input))

        // this will always run after anything labeled &quot;input&quot; and &quot;map&quot;
        // also give it a few labels it just in case
        .add_system(
            player_movement
                // can also just use strings
                .label(&quot;player_movement&quot;)
                .label(MyLabel::Player)
                .after(MyLabel::Input)
        )
        .run();
}
</code></pre>
<p>When you have multiple systems with common labels or ordering, it may be
convenient to use <a href="programming//programming/system-sets.html">system sets</a>.</p>
<h2 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h2>
<p>If you have multiple systems mutually depending on each other, then it is
clearly impossible to resolve the situation completely like that.</p>
<p>You should try to redesign your game to avoid such situations, or just accept
the consequences. You can at least make it behave predictably, using explicit
ordering to specify the order you prefer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-sets"><a class="header" href="#system-sets">System Sets</a></h1>
<p>System Sets allow you to easily apply common properties to multiple systems,
for purposes such as <a href="programming//programming/labels.html">labeling</a>, <a href="programming//programming/system-order.html">ordering</a>,
<a href="programming//programming/run-criteria.html">run criteria</a>, and <a href="programming//programming/states.html">states</a>.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // group our input handling systems into a set
        .add_system_set(
            SystemSet::new()
                .label(&quot;input&quot;)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )

        // our &quot;net&quot; systems should run before &quot;input&quot;
        .add_system_set(
            SystemSet::new()
                .label(&quot;net&quot;)
                .before(&quot;input&quot;)
                // individual systems can still have
                // their own labels (and ordering)
                .with_system(server_session.label(&quot;session&quot;))
                .with_system(server_updates.after(&quot;session&quot;))
        )

        // some ungrouped systems
        .add_system(player_movement.after(&quot;input&quot;))
        .add_system(session_ui.after(&quot;session&quot;))
        .add_system(smoke_particles)

        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/component_change_detection.rs"><code>component_change_detection</code></a>.</p>
<hr />
<p>Bevy allows you to easily detect when data is changed. You can use this to
perform actions in response to changes.</p>
<p>One of the main use cases is optimization – avoiding unnecessary work by
only doing it if the relevant data has changed. Another use case is triggering
special actions to occur on changes, like configuring something or sending
the data somewhere.</p>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<p>You can make a <a href="programming//programming/queries.html">query</a> that only yields entities if specific
<a href="programming//programming/ec.html#components">components</a> on them have been modified.</p>
<p>Use <a href="programming//programming/queries.html#query-filters">query filters</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.Added.html"><code>Added&lt;T&gt;</code></a>: detect new component instances
<ul>
<li>if the component was added to an existing entity</li>
<li>if a new entity with the component was spawned</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.Changed.html"><code>Changed&lt;T&gt;</code></a>: detect component instances that have been changed
<ul>
<li>triggers when the component is accessed mutably</li>
<li>also triggers if the component is newly-added (as per <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.Added.html"><code>Added</code></a>)</li>
</ul>
</li>
</ul>
<p>(If you want to react to removals, see the page on <a href="programming//programming/removal-detection.html">removal
detection</a>. It works differently and is much
trickier to use.)</p>
<pre><code class="language-rust no_run noplayground">/// Print the stats of friendly players when they change
fn debug_stats_change(
    query: Query&lt;
        // components
        (&amp;Health, &amp;PlayerXp),
        // filters
        (Without&lt;Enemy&gt;, Or&lt;(Changed&lt;Health&gt;, Changed&lt;PlayerXp&gt;)&gt;), 
    &gt;,
) {
    for (health, xp) in query.iter() {
        eprintln!(
            &quot;hp: {}+{}, xp: {}&quot;,
            health.hp, health.extra, xp.0
        );
    }
}

/// detect new enemies and print their health
fn debug_new_hostiles(
    query: Query&lt;(Entity, &amp;Health), Added&lt;Enemy&gt;&gt;,
) {
    for (entity, health) in query.iter() {
        eprintln!(&quot;Entity {:?} is now an enemy! HP: {}&quot;, entity, health.hp);
    }
}
</code></pre>
<h3 id="checking"><a class="header" href="#checking">Checking</a></h3>
<p>If you want to access all the entities, as normal, regardless of if they have
been modified, but you just want to check the status, you can use the special
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.ChangeTrackers.html"><code>ChangeTrackers&lt;T&gt;</code></a> query parameter.</p>
<pre><code class="language-rust no_run noplayground">/// Make sprites flash red on frames when the Health changes
fn debug_damage(
    mut query: Query&lt;(&amp;mut Sprite, ChangeTrackers&lt;Health&gt;)&gt;,
) {
    for (mut sprite, tracker) in query.iter_mut() {
        // detect if the Health changed this frame
        if tracker.is_changed() {
            sprite.color = Color::RED;
        } else {
            // extra check so we don't mutate on every frame without changes
            if sprite.color != Color::WHITE {
                sprite.color = Color::WHITE;
            }
        }
    }
}
</code></pre>
<p>This is useful for processing all entities, but doing different things
depending on if they have been modified.</p>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>For <a href="programming//programming/res.html">resources</a>, change detection is provided via methods on the
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a> system parameters.</p>
<pre><code class="language-rust no_run noplayground">fn check_res_changed(
    my_res: Res&lt;MyResource&gt;,
) {
    if my_res.is_changed() {
        // do something
    }
}

fn check_res_added(
    // use Option, not to panic if the resource doesn't exist yet
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists

        if my_res.is_added() {
            // it was just added
            // do something
        }
    }
}
</code></pre>
<p>Note that change detection cannot currently be used to detect
<a href="programming//programming/states.html">states</a> changes (via the <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/schedule/struct.State.html"><code>State</code></a>
<a href="programming//programming/res.html">resource</a>) (<a href="https://github.com/bevyengine/bevy/issues/2343">bug</a>).</p>
<h2 id="what-gets-detected"><a class="header" href="#what-gets-detected">What gets detected?</a></h2>
<p><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.Changed.html"><code>Changed</code></a> detection is triggered by
<a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>. Simply accessing components via a mutable query,
without actually performing a <code>&amp;mut</code> access, will <em>not</em> trigger it.</p>
<p>This makes change detection quite accurate. You can rely on it to optimize
your game's performance, or to otherwise trigger things to happen.</p>
<p>Also note that when you mutate a component, Bevy does not track if the new
value is actually different from the old value. It will always trigger the
change detection. If you want to avoid that, simply check it yourself:</p>
<pre><code class="language-rust no_run noplayground">fn update_player_xp(
    mut query: Query&lt;&amp;mut PlayerXp&gt;,
) {
    for mut xp in query.iter_mut() {
        let new_xp = maybe_lvl_up(&amp;xp);

        // avoid triggering change detection if the value is the same
        if new_xp != *xp {
            *xp = new_xp;
        }
    }
}
</code></pre>
<p>Change detection works on a per-<a href="programming//programming/systems.html">system</a> granularity, and is
reliable. A system will not detect changes that it made itself, only those
done by other systems, and only if it has not seen them before (the changes
happened since the last time it ran). If your system only runs sometimes
(such as with <a href="programming//programming/states.html">states</a> or <a href="programming//programming/run-criteria.html">run criteria</a>),
you do <em>not</em> have to worry about missing changes.</p>
<h2 id="possible-pitfalls-1"><a class="header" href="#possible-pitfalls-1">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the detecting
system before the changing system. The detecting system will see the change
the next time it runs, typically on the next frame update.</p>
<p>If you need to ensure that changes are handled immediately / during the same
frame, you can use <a href="programming//programming/system-order.html">explicit system ordering</a>.</p>
<p>However, when detecting component additions with <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/query/struct.Added.html"><code>Added&lt;T&gt;</code></a>
(which are typically done using <a href="programming//programming/commands.html"><code>Commands</code></a>), this is not
enough; you need <a href="programming//programming/stages.html">stages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="states"><a class="header" href="#states">States</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/state.rs"><code>state</code></a>.</p>
<p>Consider using the <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a> crate, which
provides an alternative implementation that does not suffer from the
<a href="programming/states.html#known-pitfalls-and-limitations">usability issues</a> of the one in Bevy.</p>
<hr />
<p>States allow you to structure the runtime &quot;flow&quot; of your app.</p>
<p>This is how you can implement things like:</p>
<ul>
<li>A menu screen or a loading screen</li>
<li>Pausing / unpausing the game</li>
<li>Different game modes</li>
<li>…</li>
</ul>
<p>In every state, you can have different <a href="programming//programming/systems.html">systems</a> running. You
can also add one-shot setup and cleanup systems to run when entering or
exiting a state.</p>
<p>To use states, define an enum type and add <a href="programming//programming/system-sets.html">system sets</a>
to your <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
    Paused,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // add the app state type
        .add_state(AppState::MainMenu)

        // add systems to run regardless of state, as usual
        .add_system(play_music)

        // systems to run only in the main menu
        .add_system_set(
            SystemSet::on_update(AppState::MainMenu)
                .with_system(handle_ui_buttons)
        )

        // setup when entering the state
        .add_system_set(
            SystemSet::on_enter(AppState::MainMenu)
                .with_system(setup_menu)
        )

        // cleanup when exiting the state
        .add_system_set(
            SystemSet::on_exit(AppState::MainMenu)
                .with_system(close_menu)
        )
        .run();
}
</code></pre>
<p>It is OK to have multiple system sets for the same state.</p>
<p>This is useful when you want to place <a href="programming//programming/labels.html">labels</a> and use <a href="programming//programming/system-order.html">explicit
system ordering</a>.</p>
<p>This can also be useful with <a href="programming//programming/plugins.html">Plugins</a>. Each plugin can add
its own set of systems to the same state.</p>
<p>States are implemented using <a href="programming//programming/run-criteria.html">run criteria</a> under the hood.
These special system set constructors are really just helpers to automatically
add the state management run criteria.</p>
<h2 id="controlling-states"><a class="header" href="#controlling-states">Controlling States</a></h2>
<p>Inside of systems, you can check and control the state using the
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/schedule/struct.State.html"><code>State&lt;T&gt;</code></a> resource:</p>
<pre><code class="language-rust no_run noplayground">fn play_music(
    app_state: Res&lt;State&lt;AppState&gt;&gt;,
    // ...
) {
    match app_state.current() {
        AppState::MainMenu =&gt; {
            // TODO: play menu music
        }
        AppState::InGame =&gt; {
            // TODO: play game music
        }
        AppState::Paused =&gt; {
            // TODO: play pause screen music
        }
    }
}
</code></pre>
<p>To change to another state:</p>
<pre><code class="language-rust no_run noplayground">fn enter_game(mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;) {
    app_state.set(AppState::InGame).unwrap();
    // ^ this can fail if we are already in the target state
    // or if another state change is already queued
}
</code></pre>
<p>After the systems of the current state complete, Bevy will transition to
the next state you set.</p>
<p>You can do arbitrarily many state transitions in a single frame update. Bevy
will handle all of them and execute all the relevant systems (before moving
on to the next <a href="programming//programming/stages.html">stage</a>).</p>
<h2 id="state-stack"><a class="header" href="#state-stack">State Stack</a></h2>
<p>Instead of completely transitioning from one state to another, you can also
overlay states, forming a stack.</p>
<p>This is how you can implement things like a &quot;game paused&quot; screen, or an
overlay menu, with the game world still visible / running in the background.</p>
<p>You can have some systems that are still running even when the state is
&quot;inactive&quot; (that is, in the background, with other states running on top). You
can also add one-shot systems to run when &quot;pausing&quot; or &quot;resuming&quot; the state.</p>
<p>In your <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">        // player movement only when actively playing
        .add_system_set(
            SystemSet::on_update(AppState::InGame)
                .with_system(player_movement)
        )
        // player idle animation while paused
        .add_system_set(
            SystemSet::on_inactive_update(AppState::InGame)
                .with_system(player_idle)
        )
        // animations both while paused and while active
        .add_system_set(
            SystemSet::on_in_stack_update(AppState::InGame)
                .with_system(animate_trees)
                .with_system(animate_water)
        )
        // things to do when becoming inactive
        .add_system_set(
            SystemSet::on_pause(AppState::InGame)
                .with_system(hide_enemies)
        )
        // things to do when becoming active again
        .add_system_set(
            SystemSet::on_resume(AppState::InGame)
                .with_system(reset_player)
        )
        // setup when first entering the game
        .add_system_set(
            SystemSet::on_enter(AppState::InGame)
                .with_system(setup_player)
                .with_system(setup_map)
        )
        // cleanup when finally exiting the game
        .add_system_set(
            SystemSet::on_exit(AppState::InGame)
                .with_system(despawn_player)
                .with_system(despawn_map)
        )
</code></pre>
<p>To manage states like this, use <code>push</code>/<code>pop</code>:</p>
<pre><code class="language-rust no_run noplayground">    // to go into the pause screen
    app_state.push(AppState::Paused).unwrap();
    // to go back into the game
    app_state.pop().unwrap();
</code></pre>
<p>(using <code>.set</code> as shown before replaces the active state at the top of the stack)</p>
<h2 id="known-pitfalls-and-limitations"><a class="header" href="#known-pitfalls-and-limitations">Known Pitfalls and Limitations</a></h2>
<h3 id="combining-with-other-run-criteria"><a class="header" href="#combining-with-other-run-criteria">Combining with Other Run Criteria</a></h3>
<p>Because states are implemented using <a href="programming//programming/run-criteria.html">run criteria</a>,
they cannot be combined with other uses of run criteria, such as <a href="programming//features/fixed-timestep.html">fixed
timestep</a>.</p>
<p>If you try to add another run criteria to your system set, it would replace
Bevy's state-management run criteria! This would make the system set no
longer constrained to run as part of a state!</p>
<p>Consider using <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>, which does not
have such limitations.</p>
<h3 id="multiple-stages"><a class="header" href="#multiple-stages">Multiple Stages</a></h3>
<p>Bevy states cannot work across multiple <a href="programming//programming/stages.html">stages</a>. Workarounds
are available, but they are broken and buggy.</p>
<p>This is a huge limitation in practice, as it greatly limits how you can use
<a href="programming//programming/commands.html">commands</a>. Not being able to use Commands is a big deal,
as you cannot do things like spawn entities and operate on them during the
same frame, among other important use cases.</p>
<p>Consider using <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>, which does not
have such limitations.</p>
<h3 id="with-input"><a class="header" href="#with-input">With Input</a></h3>
<p>If you want to use <a href="https://docs.rs/bevy/0.7.0/bevy/input/struct.Input.html"><code>Input&lt;T&gt;</code></a> to trigger state transitions using
a button/key press, you need to clear the input manually by calling <code>.reset</code>:</p>
<pre><code class="language-rust no_run noplayground">fn esc_to_menu(
    mut keys: ResMut&lt;Input&lt;KeyCode&gt;&gt;,
    mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Escape) {
        app_state.set(AppState::MainMenu).unwrap();
        keys.reset(KeyCode::Escape);
    }
}
</code></pre>
<p>(note that this requires <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>)</p>
<p>Not doing this can cause <a href="https://github.com/bevyengine/bevy/issues/1700">issues</a>.</p>
<p><a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a> does not have this issue.</p>
<h3 id="events-2"><a class="header" href="#events-2">Events</a></h3>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run all the time, such
as during a pause state, you will miss any events that are sent during the frames
when the receiving systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-criteria"><a class="header" href="#run-criteria">Run Criteria</a></h1>
<p>Consider using the <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a> crate, which
provides an alternative implementation that does not suffer from the
<a href="programming/run-criteria.html#known-pitfalls">usability issues</a> of the one in Bevy.</p>
<hr />
<p>Run Criteria are a mechanism for controlling if Bevy should run specific
<a href="programming//programming/systems.html">systems</a>, at runtime. This is how you can make functionality
that only runs under certain conditions.</p>
<p>Run Criteria can be applied to individual <a href="programming//programming/systems.html">systems</a>, <a href="programming//programming/system-sets.html">system
sets</a>, and <a href="programming//programming/stages.html">stages</a>.</p>
<p>Run Criteria are Bevy systems that return a value of type <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/schedule/enum.ShouldRun.html"><code>enum ShouldRun</code></a>. They can accept any <a href="programming//builtins.html#systemparams">system
parameters</a>, like a normal system.</p>
<p>This example shows how run criteria might be used to implement different
multiplayer modes:</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::schedule::ShouldRun;

#[derive(Debug, PartialEq, Eq)]
enum MultiplayerKind {
    Client,
    Host,
    Local,
}

fn run_if_connected(
    mode: Res&lt;MultiplayerKind&gt;,
    session: Res&lt;MyNetworkSession&gt;,
) -&gt; ShouldRun
{
    if *mode == MultiplayerKind::Client &amp;&amp; session.is_connected() {
        ShouldRun::Yes
    } else {
        ShouldRun::No
    }
}

fn run_if_host(
    mode: Res&lt;MultiplayerKind&gt;,
) -&gt; ShouldRun
{
    if *mode == MultiplayerKind::Host || *mode == MultiplayerKind::Local {
        ShouldRun::Yes
    } else {
        ShouldRun::No
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // if we are currently connected to a server,
        // activate our client systems
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(run_if_connected)
                .before(&quot;input&quot;)
                .with_system(server_session)
                .with_system(fetch_server_updates)
        )

        // if we are hosting the game,
        // activate our game hosting systems
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(run_if_host)
                .before(&quot;input&quot;)
                .with_system(host_session)
                .with_system(host_player_movement)
                .with_system(host_enemy_ai)
        )

        // other systems in our game
        .add_system(smoke_particles)
        .add_system(water_animation)
        .add_system_set(
            SystemSet::new()
                .label(&quot;input&quot;)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )
        .run();
}
</code></pre>
<h2 id="known-pitfalls"><a class="header" href="#known-pitfalls">Known Pitfalls</a></h2>
<h3 id="combining-multiple-run-criteria"><a class="header" href="#combining-multiple-run-criteria">Combining Multiple Run Criteria</a></h3>
<p>It is not possible to make a system that is conditional on multiple run
criteria. Bevy has a <code>.pipe</code> method that allows you to &quot;chain&quot; run criteria,
which could let you modify the output of a run criteria, but this is very
limiting in practice.</p>
<p>Consider using <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>. It allows you to
use any number of run conditions to control your systems, and does not prevent
you from using <a href="programming//programming/states.html">states</a> or <a href="programming//features/fixed-timestep.html">fixed timestep</a>.</p>
<h3 id="events-3"><a class="header" href="#events-3">Events</a></h3>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run every frame,
you will miss any events that are sent during the frames when the receiving
systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labels-1"><a class="header" href="#labels-1">Labels</a></h1>
<p>You need labels to name various things in your <a href="programming//programming/app-builder.html">app</a>, such as
<a href="programming//programming/systems.html">systems</a> (for <a href="programming//programming/system-order.html">order control</a>), <a href="programming//programming/run-criteria.html">run
criteria</a>, <a href="programming//programming/stages.html">stages</a>, and ambiguity sets.</p>
<p>Bevy uses some clever Rust type system magic, to allow you to use strings
as well as your own custom types for labels, and even mix them!</p>
<p>Using strings for labels is quick and easy for prototyping. However, they
are easy to mistype and are unstructured. The compiler cannot validate them
for you, to catch mistakes.</p>
<p>You can also use custom types (usually <code>enum</code>s) to define your labels. This
allows the compiler to check them, and helps you stay organized in larger
projects.</p>
<p>You need to derive the appropriate trait, depending on what they will be
used for: <code>StageLabel</code>, <code>SystemLabel</code>, <code>RunCriteriaLabel</code>, or <code>AmbiguitySetLabel</code>.</p>
<p>Any Rust type is suitable, as long as it has the following standard Rust
traits: <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html"><code>Clone</code></a> + <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> + <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code>Eq</code></a> +
<a href="https://doc.rust-lang.org/stable/std/hash/trait.Hash.html"><code>Hash</code></a> + <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html"><code>Debug</code></a> (and the implied <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a></p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a> + <code>'static</code>).</li>
</ul>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[derive(SystemLabel)]
enum MySystems {
    InputSet,
    Movement,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[derive(StageLabel)]
enum MyStages {
    Prepare,
    Cleanup,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[derive(StageLabel)]
struct DebugStage;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // Add our game systems:
        .add_system_set(
            SystemSet::new()
                .label(MySystems::InputSet)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )
        .add_system(player_movement.label(MySystems::Movement))

        // temporary debug system, let's just use a string label
        .add_system(debug_movement.label(&quot;temp-debug&quot;))

        // Add our custom stages:
        // note that Bevy's `CoreStage` is an enum just like ours!
        .add_stage_before(CoreStage::Update, MyStages::Prepare, SystemStage::parallel())
        .add_stage_after(CoreStage::Update, MyStages::Cleanup, SystemStage::parallel())

        .add_stage_after(CoreStage::Update, DebugStage, SystemStage::parallel())

        // we can just use a string for this one:
        .add_stage_before(CoreStage::PostUpdate, &quot;temp-debug-hack&quot;, SystemStage::parallel())

        .run();
}
</code></pre>
<p>For quick prototyping, it is convenient to just use strings as labels.</p>
<p>However, by defining your labels as custom types, the Rust compiler can check
them for you, and your IDE can auto-complete them. It is the recommended way,
as it prevents mistakes, and helps you stay organized in larger projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stages-1"><a class="header" href="#stages-1">Stages</a></h1>
<p>All <a href="programming//programming/systems.html">systems</a> to be run by Bevy are contained in stages. Every
frame update, Bevy executes each stage, in order. Within each stage, Bevy's
scheduling algorithm can run many systems in parallel, using multiple CPU
cores for good performance.</p>
<p>The boundaries between stages are effectively hard synchronization points.
They ensure that all systems of the previous stage have completed before any
systems of the next stage begin, and that there is a moment in time when no
systems are in-progress.</p>
<p>This makes it possible/safe to apply <a href="programming//programming/commands.html">Commands</a>. Any operations
performed by systems using <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> are applied at the
end of that stage.</p>
<p>Internally, Bevy has at least these built-in <a href="programming//programming/stages.html">stages</a>:</p>
<ul>
<li>In the <a href="programming//programming/app-builder.html">main app</a> (<a href="https://docs.rs/bevy/0.7.0/bevy/app/enum.CoreStage.html"><code>CoreStage</code></a>):
<code>First</code>, <code>PreUpdate</code>, <code>Update</code>, <code>PostUpdate</code>, <code>Last</code></li>
<li>In the render <a href="programming//programming/sub-apps.html">sub-app</a> (<a href="https://docs.rs/bevy/0.7.0/bevy/render/enum.RenderStage.html"><code>RenderStage</code></a>):
<code>Extract</code>, <code>Prepare</code>, <code>Queue</code>, <code>PhaseSort</code>, <code>Render</code>, <code>Cleanup</code></li>
</ul>
<p>By default, when you add your systems, they are added to <code>CoreStage::Update</code>.</p>
<p>Bevy's internal systems are in the other stages, to ensure they are ordered
correctly relative to your game logic.</p>
<p>If you want to add your own systems to any of Bevy's internal stages, you
need to beware of potential unexpected interactions with Bevy's own internal
systems. Remember: Bevy's internals are implemented using ordinary systems
and ECS, just like your own stuff!</p>
<p>You can add your own additional stages. For example, if we want our debug
systems to run after our game logic:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    // label for our debug stage
    static DEBUG: &amp;str = &quot;debug&quot;;

    App::new()
        .add_plugins(DefaultPlugins)

        // add DEBUG stage after Bevy's Update
        // also make it single-threaded
        .add_stage_after(CoreStage::Update, DEBUG, SystemStage::single_threaded())

        // systems are added to the `CoreStage::Update` stage by default
        .add_system(player_gather_xp)
        .add_system(player_take_damage)

        // add our debug systems
        .add_system_to_stage(DEBUG, debug_player_hp)
        .add_system_to_stage(DEBUG, debug_stats_change)
        .add_system_to_stage(DEBUG, debug_new_hostiles)

        .run();
}
</code></pre>
<p>If you need to manage when your systems run, relative to one another, it
is generally preferable to avoid using stages, and to use <a href="programming//programming/system-order.html">explicit system
ordering</a> instead. Stages limit parallel execution and
the performance of your game.</p>
<p>However, stages can make it easier to organize things, when you really want
to be sure that all previous systems have completed. Stages are also the
only way to apply <a href="programming//programming/commands.html">Commands</a>.</p>
<p>If you have systems that need to rely on the actions that other systems have
performed by using <a href="programming//programming/commands.html">Commands</a>, and need to do so during the
same frame, placing those systems into separate stages is the only way to
accomplish that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removal-detection"><a class="header" href="#removal-detection">Removal Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/removal_detection.rs"><code>removal_detection</code></a>.</p>
<hr />
<p>Removal detection is special. This is because, unlike with <a href="programming//programming/change-detection.html">change
detection</a>, the data does not exist in the ECS anymore
(obviously), so Bevy cannot keep tracking metadata for it.</p>
<p>Nevertheless, being able to respond to removals is important for some
applications, so Bevy offers a limited form of it.</p>
<h2 id="components-3"><a class="header" href="#components-3">Components</a></h2>
<p>You can check for <a href="programming//programming/ec.html#components">components</a> that have been removed during
the current frame. The data is cleared at the end of every frame update. Note
that this makes this feature tricky to use, and requires you to use multiple
<a href="programming//programming/stages.html">stages</a>.</p>
<p>When you remove a component (using <a href="programming//programming/commands.html">Commands</a>
(<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>)), the operation is applied at the end of the
<a href="programming//programming/stages.html">stage</a>. The <a href="programming//programming/systems.html">system</a> that checks for the removal
must run in a later stage during the same frame update. Otherwise, it will
not detect the removal.</p>
<p>Use the <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a> special system
parameter type, to get an iterator for the <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> IDs of
all the entities that had a component of type <code>T</code> that was removed earlier
this frame.</p>
<pre><code class="language-rust no_run noplayground">/// Some component type for the sake of this example.
#[derive(Component)]
struct Seen;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // we could add our system to Bevy's `PreUpdate` stage
        // (alternatively, you could create your own stage)
        .add_system_to_stage(CoreStage::PreUpdate, remove_components)
        // our detection system runs in a later stage
        // (in this case: Bevy's default `Update` stage)
        .add_system(detect_removals)
        .run();
}

fn remove_components(
    mut commands: Commands,
    q: Query&lt;(Entity, &amp;Transform), With&lt;Seen&gt;&gt;,
) {
    for (e, transform) in q.iter() {
        if transform.translation.y &lt; -10.0 {
            // remove the `Seen` component from the entity
            commands.entity(e)
                .remove::&lt;Seen&gt;();
        }
    }
}

fn detect_removals(
    removals: RemovedComponents&lt;Seen&gt;,
    // ... (maybe Commands or a Query ?) ...
) {
    for entity in removals.iter() {
        // do something with the entity
    }
}
</code></pre>
<p>(To do things with these entities, you can just use the <code>Entity</code> IDs with
<a href="programming//programming/commands.html"><code>Commands::entity()</code></a> or <a href="programming//programming/queries.html"><code>Query::get()</code></a>.)</p>
<h2 id="resources-2"><a class="header" href="#resources-2">Resources</a></h2>
<p>Bevy does not provide any API for detecting when <a href="programming//programming/res.html">resources</a> are removed.</p>
<p>You can work around this using <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> and a separate
<a href="programming//programming/local.html"><code>Local</code></a> system parameter, effectively implementing your own
detection.</p>
<pre><code class="language-rust no_run noplayground">fn detect_removed_res(
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
    mut my_res_existed: Local&lt;bool&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists!

        // remember that!
        *my_res_existed = true;

        // (... you can do something with the resource here if you want ...)
    } else if *my_res_existed {
        // the resource does not exist, but we remember it existed!
        // (it was removed)

        // forget about it!
        *my_res_existed = false;

        // ... do something now that it is gone ...
    }
}
</code></pre>
<p>Note that, since this detection is local to your system, it does not have
to happen during the same frame update.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="param-sets"><a class="header" href="#param-sets">Param Sets</a></h1>
<p>For safety reasons, a <a href="programming//programming/systems.html">system</a> cannot have multiple parameters
whose data access might have a chance of mutability conflicts over the
same data.</p>
<p>Some examples:</p>
<ul>
<li>Multiple incompatible <a href="programming//programming/queries.html">queries</a>.</li>
<li>Using <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a> while also having other system parameters to access specific data.</li>
<li>…</li>
</ul>
<p>Bevy provides a solution: wrap them in a <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    // access the health of enemies and the health of players
    // (note: some entities could be both!)
    mut set: ParamSet&lt;(
        Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
        Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
        // also access the whole world ... why not
        &amp;World,
    )&gt;,
) {
    // set health of enemies (use the 1st param in the set)
    for mut health in set.p0().iter_mut() {
        health.hp = 50.0;
    }

    // set health of players (use the 2nd param in the set))
    for mut health in set.p1().iter_mut() {
        health.hp = 100.0;
    }

    // read some data from the world (use the 3rd param in the set)
    let my_resource = set.p2().resource::&lt;MyResource&gt;();

    // since we only used the conflicting system params one at a time,
    // everything is safe and our code can compile; ParamSet guarantees this
}
</code></pre>
<p>This ensures only one of the conflicting parameters can be used at the same time.</p>
<p>The maximum number of parameters in a param set is 8.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-chaining"><a class="header" href="#system-chaining">System Chaining</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.7.0/examples/ecs/system_chaining.rs"><code>system_chaining</code></a>.</p>
<hr />
<p>You can compose a single Bevy <a href="programming//programming/systems.html">system</a> from multiple Rust functions.</p>
<p>You can make functions that can take an input and produce an output, and be
connected together to run as a single larger system.</p>
<p>This is called &quot;system chaining&quot;, but beware that the term is somewhat
misleading – you are <em>not</em> creating a chain of multiple systems to run in
order; you are creating a single large Bevy system consisting of multiple
Rust functions.</p>
<p>Note that system chaining is <em>not</em> a way of communicating between systems.
If you want to pass data between systems, you should use <a href="programming//programming/events.html">Events</a>
instead.</p>
<hr />
<p>One useful application is to be able to return errors from your system code
(allowing the use of Rust's <code>?</code> operator) and then have a separate function
for handling them:</p>
<pre><code class="language-rust no_run noplayground">fn net_receive(mut netcode: ResMut&lt;MyNetProto&gt;) -&gt; std::io::Result&lt;()&gt; {
    netcode.receive_updates()?;

    Ok(())
}

fn handle_io_errors(In(result): In&lt;std::io::Result&lt;()&gt;&gt;) {
    if let Err(e) = result {
        eprintln!(&quot;I/O error occurred: {}&quot;, e);
    }
}
</code></pre>
<p>Such functions cannot be <a href="programming//programming/app-builder.html">registered</a> individually as systems
(Bevy doesn't know what to do with the input/output). You have to connect
them in a chain:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...
        .add_system(net_receive.chain(handle_io_errors))
        // ...
        .run();
}
</code></pre>
<h2 id="performance-warning"><a class="header" href="#performance-warning">Performance Warning</a></h2>
<p>Beware that Bevy treats the whole chain as if it was a single big system,
with all the combined resources and queries. This implies that parallelism
could be limited, affecting performance.</p>
<p>Avoid adding a system that requires mutable access to anything, as part
of multiple chains. It would block all affected chains (and other systems
accessing the same data) from running in parallel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-world-access"><a class="header" href="#direct-world-access">Direct World Access</a></h1>
<p>The <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>World</code></a> is where Bevy ECS stores all data and
associated metadata. It keeps track of <a href="programming//programming/res.html">resources</a>, <a href="programming//programming/ec.html">entities and
components</a>.</p>
<p>Typically, the <a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.App.html"><code>App</code></a>'s schedule runner will run all
<a href="programming//programming/stages.html">stages</a> (which, in turn, run their <a href="programming//programming/systems.html">systems</a>)
on the main world. Regular <a href="programming//programming/systems.html">systems</a> are limited in
what data they can access from the world, by their <a href="programming//builtins.html#systemparams">system parameter
types</a>. Operations that manipulate the world itself
are only done indirectly using <a href="programming//programming/commands.html"><code>Commands</code></a>. This is how most
typical Bevy user code behaves.</p>
<p>However, there are also ways you can get full direct access to the world,
which gives you full control and freedom to do anything with any data stored
in the Bevy ECS:</p>
<ul>
<li><a href="programming//programming/exclusive.html">Exclusive systems</a></li>
<li><a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impls</li>
<li>Via the <a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.App.html"><code>App</code></a> <a href="programming//programming/app-builder.html">builder</a></li>
<li>Manually created <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>World</code></a>s for purposes like <a href="programming//programming/system-tests.html">tests</a> or scenes</li>
<li>Custom Commands</li>
<li>Custom <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/schedule/trait.Stage.html"><code>Stage</code></a> impls (not recommended, prefer exclusive systems)</li>
</ul>
<p>Direct world access lets you do things like:</p>
<ul>
<li>Freely spawn/despawn entities, insert/remove resources, etc., taking effect immediately
(no delay like when using [<code>Commands</code>] from a regular <a href="programming//programming/systems.html">system</a>)</li>
<li>Access any component, entities, and resources you want</li>
<li>Manually run systems or stages</li>
</ul>
<h2 id="working-with-the-world"><a class="header" href="#working-with-the-world">Working with the <code>World</code></a></h2>
<p>Here are some ways that you can make use of the direct world access APIs.</p>
<h3 id="systemstate"><a class="header" href="#systemstate"><code>SystemState</code></a></h3>
<p>The easiest way to do things is using a <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>.</p>
<p>This is a type that &quot;imitates a system&quot;, behaving the same way as a
<a href="programming//programming/systems.html">system</a> with various parameters would. All the same behaviors
like <a href="programming//programming/queries.html">queries</a>, <a href="programming//programming/change-detection.html">change detection</a>, and
even <a href="programming//programming/commands.html"><code>Commands</code></a> are available. You can use any <a href="programming//builtins.html#systemparams">system
params</a>.</p>
<p>It also tracks any persistent state, used for things like <a href="programming//programming/change-detection.html">change
detection</a> or caching to improve performance. Therefore,
if you plan on reusing the same <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> multiple
times, you should store it somewhere, rather than creating a new one every
time. Every time you call <code>.get(world)</code>, it behaves like another &quot;run&quot;
of a system.</p>
<p>If you are using <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, you can choose when you
want to apply them to the world. You need to manually call <code>.apply(world)</code>
on the <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>, to apply them.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example
</code></pre>
<h3 id="running-a-stage"><a class="header" href="#running-a-stage">Running a Stage</a></h3>
<p>If you want to run some systems (a common use-case is
<a href="programming//programming/system-tests.html">testing</a>), the easiest way is to construct an impromptu
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/schedule/struct.SystemStage.html"><code>SystemStage</code></a> (<a href="programming//programming/stages.html">stages</a>). This way you reuse
all the scheduling logic that Bevy normally does when running systems.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example
</code></pre>
<h3 id="navigating-by-metadata"><a class="header" href="#navigating-by-metadata">Navigating by Metadata</a></h3>
<p>The world contains a lot of metadata that allows navigating all the data
efficiently, such as information about all the stored components, entities,
archeypes.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exclusive-systems"><a class="header" href="#exclusive-systems">Exclusive Systems</a></h1>
<p>Exclusive systems are <a href="programming//programming/systems.html">systems</a> that Bevy will not run in
parallel with any other system. They can have full unrestricted access to
the whole ECS <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>World</code></a>, by taking a <code>&amp;mut World</code> parameter.</p>
<p>Inside of an exclusive system, you have full control over all data stored
in the ECS. You can do whatever you want.</p>
<p>Note that exclusive systems can limit performance, as they prevent
multi-threading (nothing else runs at the same time).</p>
<p>Some example situations where exclusive systems are useful:</p>
<ul>
<li>Dump various entities and components to a file, to implement things like
saving and loading of game save files, or scene export from an editor</li>
<li>Directly spawn/despawn <a href="programming//programming/ec.html">entities</a>, or create/remove <a href="programming//programming/res.html">resources</a>,
immediately with no delay (unlike when using <a href="programming//programming/commands.html"><code>Commands</code></a>
from a regular system)</li>
<li>Run arbitrary systems with your own scheduling algorithm</li>
<li>…</li>
</ul>
<p>See the <a href="programming//programming/world.html">direct World access page</a> to learn more about how to do
such things.</p>
<pre><code class="language-rust no_run noplayground">fn do_crazy_things(world: &amp;mut World) {
    // we can do anything with any data in the Bevy ECS here!
}
</code></pre>
<p>You need to add exclusive systems to the <a href="programming//programming/app-builder.html">App</a>, just like
regular systems, but you must call <code>.exclusive_system()</code> on them.</p>
<p>They cannot be ordered in-between regular parallel systems. Exclusive systems
always run at one of the following places:</p>
<ul>
<li><code>.at_start()</code>: at the beginning of a <a href="programming//programming/stages.html">stage</a></li>
<li><code>.at_end()</code>: at the end of a <a href="programming//programming/stages.html">stage</a>,
after <a href="programming//programming/commands.html">commands</a> from regular systems have been applied</li>
<li><code>.before_commands()</code>: after all the regular systems in a <a href="programming//programming/stages.html">stage</a>,
but before <a href="programming//programming/commands.html">commands</a> are applied</li>
</ul>
<p>(if you don't specify anything, the default is assumed <code>.at_start()</code>)</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // this will run at the start of CoreStage::Update (the default stage)
        .add_system(do_crazy_things.exclusive_system())

        // this will run at the end of CoreStage::PostUpdate
        .add_system_to_stage(
            CoreStage::PostUpdate,
            some_more_things
                .exclusive_system()
                .at_end()
        )

        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sub-apps"><a class="header" href="#sub-apps">Sub-Apps</a></h1>
<p>This page has not been written yet…</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-send-resources"><a class="header" href="#non-send-resources">Non-Send Resources</a></h1>
<p>&quot;Non-send&quot; refers to data types that must only be accessed from the &quot;main
thread&quot; of the application. Such data is marked by Rust as <code>!Send</code> (lacking
the <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> trait).</p>
<p>Some (often system) libraries have interfaces that cannot be safely used from
other threads. A common example of this are various low-level OS interfaces
for things like windowing, graphics, or audio. If you are doing advanced
things like creating a Bevy plugin for interfacing with such things, you
may encounter the need for this.</p>
<p>Normally, Bevy works by running all your <a href="programming//programming/systems.html">systems</a> on a
thread-pool, making use of many CPU cores.  However, you might need to ensure
that some code always runs on the &quot;main thread&quot;, or access data that is not
safe to access in a multithreaded way.</p>
<h2 id="non-send-systems-and-data-access"><a class="header" href="#non-send-systems-and-data-access">Non-Send Systems and Data Access</a></h2>
<p>To do this, you can use a <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> /
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a> system parameter. This behaves just like
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, letting you access an
ECS <a href="programming//programming/res.html">resource</a> (single global instance of some data), except that
the presence of such a parameter forces the Bevy scheduler to always run the
<a href="programming//programming/systems.html">system</a> on the main thread. This ensures that data never has
to be sent between threads or accessed from different threads.</p>
<p>One example of such a resource is <a href="https://docs.rs/bevy/0.7.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a>
in Bevy. This is the low-level version of <a href="https://docs.rs/bevy/0.7.0/bevy/window/struct.Windows.html"><code>Windows</code></a> that
gives you more direct access to OS window management functionality.</p>
<pre><code class="language-rust no_run noplayground">fn setup_raw_window(mut windows: NonSend&lt;WinitWindows&gt;) {
    let raw_window = windows.get_window(WindowId::primary()).unwrap();
    // do some special things
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // just add it as a normal system;
        // Bevy will notice the NonSend parameter
        // and ensure it runs on the main thread
        .add_startup_system(setup_raw_window)
        .run();
}
</code></pre>
<h2 id="custom-non-send-resources"><a class="header" href="#custom-non-send-resources">Custom Non-Send Resources</a></h2>
<p>Normally, to insert <a href="programming//programming/res.html">resources</a>, their types must be
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a>.</p>
<p>Bevy tracks non-Send resources separately, to ensure that they
can only be accessed using <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> /
<a href="https://docs.rs/bevy/0.7.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>.</p>
<p>It is not possible to insert non-send resources using
<a href="programming//programming/commands.html"><code>Commands</code></a>, only using <a href="programming//programming/world.html">direct World access</a>.
This means that you have to initialize them in an <a href="programming//programming/exclusive.html">exclusive
system</a>, <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impl,
or custom stage.</p>
<pre><code class="language-rust no_run noplayground">fn setup_platform_audio(world: &amp;mut World) {
    // assuming `OSAudioMagic` is some primitive that is not thread-safe
    let instance = OSAudioMagic::init();

    world.insert_non_send_resource(instance);
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup_platform_audio.exclusive_system())
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests-for-systems"><a class="header" href="#writing-tests-for-systems">Writing Tests for Systems</a></h1>
<p>You might want to write and run automated tests for your <a href="programming//programming/systems.html">systems</a>.</p>
<p>You can use the regular Rust testing features (<code>cargo test</code>) with Bevy.</p>
<p>To do this, you can create an empty ECS <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>World</code></a> in your
tests, and then, using <a href="programming//programming/world.html">direct World access</a>, insert whatever
<a href="programming//programming/ec.html#entities">entities</a> and <a href="programming//programming/res.html">resources</a> you need for testing. Create
a standalone <a href="programming//programming/stages.html">stage</a> with the <a href="programming//programming/systems.html">systems</a> you want to
run, and manually run it on the <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>Bevy's official repository has a fantastic <a href="https://github.com/bevyengine/bevy/blob/main/tests/how_to_test_systems.rs">example of how to do
this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-patterns"><a class="header" href="#programming-patterns">Programming Patterns</a></h1>
<p>This chapter is about any non-obvious tricks, programming techniques,
patterns and idioms, that may be useful when programming with Bevy.</p>
<p>These topics are an extension of the topics covered in the <a href="/programming.html">Bevy Programming
Framework</a> chapter. See that chapter to learn the
foundational concepts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-systems"><a class="header" href="#generic-systems">Generic Systems</a></h1>
<p>Bevy <a href="patterns//programming/systems.html">systems</a> are just plain rust functions, which means they
can be generic. You can add the same system multiple times, parametrized to
work on different Rust types or values.</p>
<h2 id="generic-over-component-types"><a class="header" href="#generic-over-component-types">Generic over Component types</a></h2>
<p>You can use the generic type parameter to specify what
<a href="patterns//programming/ec.html#components">component</a> types (and hence what <a href="patterns//programming/ecs-intro.html">entities</a>)
your <a href="patterns//programming/systems.html">system</a> should operate on.</p>
<p>This can be useful when combined with Bevy <a href="patterns//programming/states.html">states</a>.
You can do the same thing to different sets of entities depending on state.</p>
<h3 id="example-cleanup"><a class="header" href="#example-cleanup">Example: Cleanup</a></h3>
<p>One straightforward use-case is for cleanup. We can make a generic cleanup
system that just despawns all entities that have a certain component
type. Then, trivially run it on exiting different states.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::component::Component;

fn cleanup_system&lt;T: Component&gt;(
    mut commands: Commands,
    q: Query&lt;Entity, With&lt;T&gt;&gt;,
) {
    for e in q.iter() {
        commands.entity(e).despawn_recursive();
    }
}
</code></pre>
<p>Menu entities can be tagged with <code>cleanup::MenuExit</code>, entities from the game
map can be tagged with <code>cleanup::LevelUnload</code>.</p>
<p>We can add the generic cleanup system to our state transitions, to take care
of the respective entities:</p>
<pre><code class="language-rust no_run noplayground">/// Marker components to group entities for cleanup
mod cleanup {
    use bevy::prelude::*;
    #[derive(Component)]
    pub struct LevelUnload;
    #[derive(Component)]
    pub struct MenuClose;
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_state(AppState::MainMenu)
        // add the cleanup systems
        .add_system_set(SystemSet::on_exit(AppState::MainMenu)
            .with_system(cleanup_system::&lt;cleanup::MenuClose&gt;))
        .add_system_set(SystemSet::on_exit(AppState::InGame)
            .with_system(cleanup_system::&lt;cleanup::LevelUnload&gt;))
        .run();
}
</code></pre>
<h2 id="using-traits"><a class="header" href="#using-traits">Using Traits</a></h2>
<p>You can use this in combination with Traits, for when you need some sort of
varying implementation/functionality for each type.</p>
<h3 id="example-bevys-camera-projections"><a class="header" href="#example-bevys-camera-projections">Example: Bevy's Camera Projections</a></h3>
<p>(this is a use-case within Bevy itself)</p>
<p>Bevy has a <a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/trait.CameraProjection.html"><code>CameraProjection</code></a> trait. Different
projection types like <a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>
and <a href="https://docs.rs/bevy/0.7.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> implement that
trait, providing the correct logic for how to respond to resizing the window,
calculating the projection matrix, etc.</p>
<p>There is a generic system <code>fn camera_system::&lt;T: CameraProjection + Component&gt;</code>, which handles all the cameras with a given projection type. It
will call the trait methods when appropriate (like on window resize events).</p>
<p>The <a href="patterns//cookbook/custom-projection.html">Bevy Cookbook Custom Camera Projection
Example</a> shows this API in action.</p>
<h2 id="using-const-generics"><a class="header" href="#using-const-generics">Using Const Generics</a></h2>
<p>Now that Rust has support for Const Generics, functions can also be
parametrized by values, not just types.</p>
<pre><code class="language-rust no_run noplayground">fn process_layer&lt;const LAYER_ID: usize&gt;(
    // system params
) {
    // do something for this `LAYER_ID`
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(process_layer::&lt;1&gt;)
        .add_system(process_layer::&lt;2&gt;)
        .add_system(process_layer::&lt;3&gt;)
        .run();
}
</code></pre>
<p>Note that these values are static / constant at compile-time. This can be
a severe limitation. In some cases, when you might suspect that you could
use const generics, you might realize that you actually want a runtime value.</p>
<p>If you need to &quot;configure&quot; your system by passing in some data, you could,
instead, use a <a href="patterns//programming/res.html">Resource</a> or <a href="patterns//programming/local.html">Local</a>.</p>
<p>Note: As of Rust 1.59, support for using <code>enum</code> values as const generics is
not yet stable. To use <code>enum</code>s, you need Rust Nightly, and to enable the
experimental/unstable feature (put this at the top of your <code>main.rs</code> or
<code>lib.rs</code>):</p>
<pre><code class="language-rust no_run noplayground">#![feature(adt_const_params)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-storage-tablesparse-set"><a class="header" href="#component-storage-tablesparse-set">Component Storage (Table/Sparse-Set)</a></h1>
<p>Bevy ECS provides two different ways of storing data: tables and sparse sets.
The two storage kinds offer different performance characteristics.</p>
<p>The kind of storage to be used can be chosen per <a href="patterns//programming/ec.html#components">component</a> type.
When you derive the <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait, you can specify it.
The default, if unspecified, is table storage.</p>
<p>You can have components with a mixture of different storage kinds on the same entity.</p>
<p>The rest of this page is dedicated to explaining the performance trade-offs and why
you might want to choose one storage kind vs. the other.</p>
<pre><code class="language-rust no_run noplayground">/// Component for entities that can cast magic spells
#[derive(Component)] // Use the default table storage
struct Mana {
    mana: f32,
}

/// Component for enemies that currently &quot;see&quot; the player
/// Every frame, add/remove to entities based on visibility
/// (use sparse-set storage due to frequent add/remove)
#[derive(Component)]
#[component(storage = &quot;SparseSet&quot;)]
struct CanSeePlayer;

/// Component for entities that are currently taking bleed damage
/// Add to entities to apply bleed effect, remove when done
/// (use sparse-set storage to not fragment tables,
/// as this is a &quot;temporary effect&quot;)
#[derive(Component)]
#[component(storage = &quot;SparseSet&quot;)]
struct Bleeding {
    damage_rate: f32,
}
</code></pre>
<h2 id="table-storage"><a class="header" href="#table-storage">Table Storage</a></h2>
<p>Table storage is optimized for fast <a href="patterns//programming/queries.html">query</a> iteration. If the way you usually use a
specific component type is to access its data across many entities, this will offer the best
performance.</p>
<p>However, adding/removing table components to existing entities is a relatively slow operation. It
requires copying the data of all the other table components for the entity, to a different
location in memory.</p>
<p>It's OK if you have to do this sometimes, but if you are likely to add/remove a component very
frequently, you might want to switch that component type to sparse-set storage.</p>
<p>You can see why table storage was chosen as Bevy's default. Most component types are rarely
added/removed in practice. You typically spawn entities with all the components they should have,
and then access the data via queries, usually every frame. Sometimes you might add or remove
a component to change an entity's behavior, but probably not nearly as often, or every frame.</p>
<h2 id="sparse-set-storage"><a class="header" href="#sparse-set-storage">Sparse-Set Storage</a></h2>
<p>Sparse-Set storage is optimized for fast adding/removing of a component to existing entities, at
the cost of slower querying. It can be more efficient for components that you would like to add/remove very frequently.</p>
<p>An example of this might be a <a href="patterns//programming/ec.html#components">marker component</a> indicating whether an enemy can
currently see the player. You might want to have such a component type, so that you can easily
use a <a href="patterns//programming/queries.html#query-filters">query filter</a> to find all the enemies that are currently tracking the
player. However, this is something that can change every frame, as enemies or the player move
around the game level. If you add/remove this component every time the visibility status changed,
that's a lot of additions and removals.</p>
<p>You can see that situations like these are more niche and do not apply to most component types. Treat
sparse-set storage as a potential optimization you could try in specific circumstances.</p>
<h2 id="table-fragmentation"><a class="header" href="#table-fragmentation">Table Fragmentation</a></h2>
<p>Furthermore, the actual memory layout of the &quot;tables&quot; depends on the set of all table components
that each of your entities has.</p>
<p>ECS queries perform best when many of the entities they match have the same overall set of components.</p>
<p>Having a large number of entities, that all have the same component types, is very efficient
in terms of data access performance. Having diverse entities with a varied mixture of different
component types, means that their data will be fragmented in memory and be less efficient to access.</p>
<p>Sparse-Set components do not affect the memory layout of tables. Hence, components that are only
used on a few entities or as a &quot;temporary effect&quot;, might also be good candidates for sparse-set
storage. That way they don't fragment the memory of the other (table) components.</p>
<h2 id="overall-advice"><a class="header" href="#overall-advice">Overall Advice</a></h2>
<p>While this page describes the general performance characteristics and gives some guidelines, you
often cannot know if something improves performance without benchmarking.</p>
<p>You could use sparse-set storage just in obvious situations like the &quot;visibility marker&quot; example
given earlier, and otherwise leave the default table storage.</p>
<p>When your game grows complex enough and you have something to benchmark, you could try to apply
it in more places and see how it affects your results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-event-clearing"><a class="header" href="#manual-event-clearing">Manual Event Clearing</a></h1>
<p><a href="patterns//code/examples/manual-event-clear.rs">Click here to download a full example file with the code from this page.</a></p>
<hr />
<p>The <a href="patterns//programming/events.html">event</a> queue needs to be cleared periodically,
so that it does not grow indefinitely and waste unbounded memory.</p>
<p>Bevy's default cleanup strategy is to clear events every frame, but with double
buffering, so that events from the previous frame update stay available. This
means that you can handle the events only until the end of the next frame
after the one when they are sent.</p>
<p>This default works well for systems that run every frame and check for events
every time, which is the typical usage pattern.</p>
<p>However, if you have systems that do not read events every frame, they might
miss some events. Some common scenarios where this occurs are:</p>
<ul>
<li>systems with an early-return, that don't read events every time they run</li>
<li>when using <a href="patterns//features/fixed-timestep.html">fixed timestep</a></li>
<li>systems that only run in specific <a href="patterns//programming/states.html">states</a>,
such as if your game has a pause state</li>
<li>when using custom <a href="patterns//programming/run-criteria.html">run criteria</a> to control
your systems</li>
</ul>
<p>To be able to reliably manage events in such circumstances, you might want
to have manual control over how long the events are held in memory.</p>
<p>You can replace Bevy's default cleanup strategy with your own.</p>
<p>To do this, simply add your event type (wrapped as <a href="https://docs.rs/bevy/0.7.0/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a>)
to the <a href="patterns//programming/app-builder.html">app builder</a> using <code>.init_resource</code>, instead of <code>.add_event</code>.</p>
<p>(<code>.add_event</code> is actually just a convenience method that initializes the
<a href="patterns//programming/res.html">resource</a> and adds Bevy's built-in system (<a href="patterns//patterns/generic-systems.html">generic</a>
over your event type) for the default cleanup strategy)</p>
<p>You must then clear the events at your discretion. If you don't do this often
enough, your events might pile up and waste memory.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We can create <a href="patterns//patterns/generic-systems.html">generic systems</a> for this. Implement
the custom cleanup strategy, and then add that <a href="patterns//programming/systems.html">system</a> to your
<a href="https://docs.rs/bevy/0.7.0/bevy/app/struct.App.html"><code>App</code></a> as many times as you need, for each <a href="patterns//programming/events.html">event</a> type
where you want to use your custom behavior.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::event::Events;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // add the `Events&lt;T&gt;` resource manually
        // these events will not have automatic cleanup
        .init_resource::&lt;Events&lt;MySpecialEvent&gt;&gt;()

        // this is a regular event type with automatic cleanup
        .add_event::&lt;MyRegularEvent&gt;()

        // add the cleanup systems
        .add_system(my_event_manager::&lt;MySpecialEvent&gt;)
        .run();
}

/// Custom cleanup strategy for events
///
/// Generic to allow using for any custom event type
fn my_event_manager&lt;T: 'static + Send + Sync&gt;(
    mut events: ResMut&lt;Events&lt;T&gt;&gt;,
) {
    // TODO: implement your custom logic
    // for deciding when to clear the events

    // clear all events like this:
    events.clear();

    // or with double-buffering
    // (this is what Bevy's default strategy does)
    events.update();

    // or drain them, if you want to iterate,
    // to access the values:
    for event in events.drain() {
        // TODO: do something with each event
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-render-gpu-framework"><a class="header" href="#bevy-render-gpu-framework">Bevy Render (GPU) Framework</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>This chapter covers Bevy's rendering framework and how to work with the GPU.</p>
<p>Make sure you are well familiar with <a href="/programming.html">Bevy's Core Programming
Framework</a>. Everything here builds on top of it.</p>
<p>Here you will learn how to write custom rendering code. If you are simply
interested in using the existing graphical features provided by Bevy, check
out the chapters about <a href="/2d.html">2D</a> and <a href="/3d.html">3D</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-architecture-overview"><a class="header" href="#render-architecture-overview">Render Architecture Overview</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>The current Bevy render architecture premiered in Bevy 0.6. The <a href="https://bevyengine.org/news/bevy-0-6">news blog
post</a> is another place you can learn about it. :)</p>
<p>It was inspired by the Destiny Render Architecture (from the Destiny game).</p>
<h2 id="pipelined-rendering"><a class="header" href="#pipelined-rendering">Pipelined Rendering</a></h2>
<p>Bevy's renderer is architected in a way that operates independently from all
the normal app logic. It operates in its own separate <a href="gpu//programming/world.html">ECS World</a>
and has its own <a href="gpu//programming/app-builder.html">schedule</a>, with <a href="gpu//TODO.html">stages</a> and
<a href="gpu//programming/systems.html">systems</a>.</p>
<p>The plan is that, in a future Bevy version, the renderer will run in parallel
with all the normal app logic, allowing for greater performance. This is
called &quot;pipelined rendering&quot;: rendering the previous frame at the same time
as the app is processing the next frame update.</p>
<p>Every frame, the two parts are synchronized in a special <a href="gpu//programming/stages.html">stage</a>
called &quot;Extract&quot;. The Extract stage has access to both <a href="gpu//programming/world.html">ECS Worlds</a>,
allowing it to copy data from the main World into the render World.</p>
<p>From then on, the renderer only has access to the render World, and can only
use data that is stored there.</p>
<p>Every frame, all <a href="gpu//programming/ec.html">entities</a> in the render World are erased, but
<a href="gpu//programming/res.html">resources</a> are kept. If you need to persist data from frame to
frame, store it in resources. Dynamic data that could change every frame
should be copied into the render world in the Extract stage, and typically
stored using entities and components.</p>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<p>The renderer operates in multiple <a href="gpu//TODO.html">render stages</a>. This
is how the work that needs to be performed on the CPU is managed.</p>
<ul>
<li><code>Extract</code>: quickly copy the minimal data you need from the main World to the render World</li>
<li><code>Prepare</code>: send data to the GPU (buffers, textures, bind groups)</li>
<li><code>Queue</code>: generate the render jobs to be run (<a href="gpu//TODO.html">phase items</a>)</li>
<li><code>PhaseSort</code>: sort and batch <a href="gpu//TODO.html">phase items</a> for efficient rendering</li>
<li><code>Render</code>: execute the <a href="gpu//TODO.html">render graph</a> to produce actual GPU commands and do the work</li>
<li><code>Cleanup</code>: clear any data from the render World that should not persist to the next frame</li>
</ul>
<p>The ordering of the workloads to be performed on the GPU is controlled
using the <a href="gpu//TODO.html">render graph</a>. The graph consists of
<a href="gpu//TODO.html">nodes</a>, each representing a workload for the GPU,
typically a <a href="gpu//TODO.html">render pass</a>. The nodes are connected using
<a href="gpu//TODO.html">edges</a>, representing their ordering/dependencies
with regard to one another.</p>
<h2 id="layers-of-abstraction"><a class="header" href="#layers-of-abstraction">Layers of Abstraction</a></h2>
<p>The Bevy rendering framework can accomodate you working at various different
levels of abstraction, depending on how much you want to integrate with the
Bevy ecosystem and built-in features, vs. have more direct control over the GPU.</p>
<p>For most things, you would be best served by the &quot;high-level&quot; or &quot;mid-level&quot; APIs.</p>
<h3 id="low-level"><a class="header" href="#low-level">Low-Level</a></h3>
<p>Bevy works directly with <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a>, a Rust-based cross-platform
graphics API. It is the abstraction layer over the GPU APIs of the underlying
<a href="gpu//platforms.html">platform</a>. This way, the same GPU code can work on all
supported platforms. The API design of <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> is based on
the WebGPU standard, but with extensions to support native platform features,
going beyond the limitations of the web platform.</p>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends for each platform:</p>
<ul>
<li>Vulkan (Linux/Windows/Android)</li>
<li>DirectX 12 (Windows)</li>
<li>Metal (Apple)</li>
<li>WebGL2 (Web)</li>
<li>WebGPU (Web; experimental)</li>
<li>GLES3 (Linux/Android; legacy)</li>
<li>DirectX 11 (Windows; legacy; WIP (not yet ready for use))</li>
</ul>
<p><code>wgpu</code> forms the &quot;lowest level&quot; of Bevy rendering. If you really need the
most direct control over the GPU, you can pretty much use <code>wgpu</code> directly,
from within the Bevy render framework.</p>
<h3 id="mid-level"><a class="header" href="#mid-level">Mid-Level</a></h3>
<p>On top of <code>wgpu</code>, Bevy provides some abstractions that can help you, and
integrate better with the rest of Bevy.</p>
<p>The first is <a href="gpu//TODO.html">pipeline caching</a> and
<a href="gpu//TODO.html">specialization</a>. If you create your
<a href="gpu//TODO.html">render pipelines</a> via this interface, Bevy can manage
them efficiently for you, creating them when they are first used, and then
caching and reusing them, for optimal performance.</p>
<p>Caching and specialization are, analogously, also available for <a href="gpu//TODO.html">GPU Compute
pipelines</a>.</p>
<p>Similar to the <a href="gpu//TODO.html">pipeline cache</a>, there is a <a href="gpu//TODO.html">texture
cache</a>. This is what you use for rendering-internal
<a href="gpu//TODO.html">textures</a> (for example: shadow maps, reflection maps,
…), that do not originate from <a href="gpu//assets.html">assets</a>. It will manage and
reuse the GPU memory allocation, and free it when it becomes unused.</p>
<p>For using data from <a href="gpu//assets.html">assets</a>, Bevy provides the <a href="gpu//TODO.html">Render
Asset</a> abstraction to help with extracting the data from
different <a href="gpu//builtins.html#assets">asset types</a>.</p>
<p>Bevy can manage all the &quot;objects to draw&quot; using <a href="gpu//TODO.html">phases</a>,
which sort and draw <a href="gpu//TODO.html">phase items</a>. This way, Bevy
can sort each object to render, relative to everything else in the scene,
for optimal performance and correct transparency (if any).</p>
<p>Phase Items are defined using <a href="gpu//TODO.html">render commands</a>
and/or <a href="gpu//TODO.html">draw functions</a>. These are, conceputally,
the rendering equivalents of ECS <a href="gpu//programming/systems.html">systems</a> and <a href="gpu//programming/exclusive.html">exclusive
systems</a>, fetching data from the ECS World and generating
<a href="gpu//TODO.html">draw calls</a> for the GPU.</p>
<p>All of these things fit into the core architecture of the Bevy <a href="gpu//TODO.html">render
graph</a> and <a href="gpu//TODO.html">render stages</a>. During
the Render stage, <a href="gpu//TODO.html">graph nodes</a> will execute <a href="gpu//TODO.html">render
passes</a> with the <a href="gpu//TODO.html">render phases</a>,
to draw everything as it was set up in the Prepare/Queue/PhaseSort stages.</p>
<p>The <code>bevy_core_pipeline</code> crate defines a set of <a href="gpu//TODO.html">standard
phase/item</a> and main pass types. If you can, you
should work with them, for best compatibility with the Bevy ecosystem.</p>
<h3 id="high-level"><a class="header" href="#high-level">High-Level</a></h3>
<p>On top of all the mid-level APIs, Bevy provides abstractions to make many
common kinds of workloads easier.</p>
<p>The most notable higher-level features are <a href="gpu//TODO.html">meshes</a> and
<a href="gpu//TODO.html">materials</a>.</p>
<p>Meshes are the source of per-vertex data (<a href="gpu//TODO.html">vertex
attributes</a>) to be fed into
your <a href="gpu//TODO.html">shaders</a>. The material specifies what
<a href="gpu//TODO.html">shaders</a> to use and any other data that needs to be
fed into it, like <a href="gpu//TODO.html">textures</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-cookbook"><a class="header" href="#bevy-cookbook">Bevy Cookbook</a></h1>
<p>This chapter shows you how to do various practical things using Bevy.</p>
<p>Indended as a supplement to Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official examples</a>.</p>
<p>The examples are written to only focus on the relevant information for the
task at hand.</p>
<p>Only the relevant parts of the code are shown. Full compilable example files
are available and linked on each page.</p>
<p>It is assumed that you are already familiar with
<a href="/programming.html">Bevy Programming</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="show-framerate-in-console"><a class="header" href="#show-framerate-in-console">Show Framerate in Console</a></h1>
<p><a href="cookbook//code/examples/print-framerate.rs">Click here for the full example code.</a></p>
<hr />
<p>You can use bevy's builtin diagnostics system to print framerate (FPS)
to the console, for monitoring performance.</p>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin};

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugin(LogDiagnosticsPlugin::default())
        .add_plugin(FrameTimeDiagnosticsPlugin::default())
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convert-cursor-to-world-coordinates"><a class="header" href="#convert-cursor-to-world-coordinates">Convert cursor to world coordinates</a></h1>
<p><a href="cookbook//code/examples/cursor2world.rs">Click here for the full example code.</a></p>
<hr />
<p>Bevy does not yet provide built-in functions to help with finding out what
the cursor is pointing at.</p>
<h2 id="3d-games"><a class="header" href="#3d-games">3D games</a></h2>
<p>There is a good (unofficial) plugin:
<a href="https://github.com/aevyrie/bevy_mod_picking"><code>bevy_mod_picking</code></a>.</p>
<h2 id="2d-games"><a class="header" href="#2d-games">2D games</a></h2>
<p>This code should work for 2D games with orthographic projections. It is
&quot;undoing&quot; the projection and camera transformations.</p>
<p>(there will likely be <em>slight</em> inaccuracy from floating-point calculations)</p>
<p>This should work regardless of the scaling settings of your projection, and
camera <a href="cookbook//features/transforms.html">transform</a>.</p>
<pre><code class="language-rust no_run noplayground">/// Used to help identify our main camera
#[derive(Component)]
struct MainCamera;

fn setup(mut commands: Commands) {
    commands.spawn()
        .insert_bundle(OrthographicCameraBundle::new_2d())
        .insert(MainCamera);
}

fn my_cursor_system(
    // need to get window dimensions
    wnds: Res&lt;Windows&gt;,
    // query to get camera transform
    q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform), With&lt;MainCamera&gt;&gt;
) {
    // get the camera info and transform
    // assuming there is exactly one main camera entity, so query::single() is OK
    let (camera, camera_transform) = q_camera.single();

    // get the window that the camera is displaying to (or the primary window)
    let wnd = if let RenderTarget::Window(id) = camera.target {
        wnds.get(id).unwrap()
    } else {
        wnds.get_primary().unwrap()
    };

    // check if the cursor is inside the window and get its position
    if let Some(screen_pos) = wnd.cursor_position() {
        // get the size of the window
        let window_size = Vec2::new(wnd.width() as f32, wnd.height() as f32);

        // convert screen position [0..resolution] to ndc [-1..1] (gpu coordinates)
        let ndc = (screen_pos / window_size) * 2.0 - Vec2::ONE;

        // matrix for undoing the projection and camera transform
        let ndc_to_world = camera_transform.compute_matrix() * camera.projection_matrix.inverse();

        // use it to convert ndc to world-space coordinates
        let world_pos = ndc_to_world.project_point3(ndc.extend(-1.0));

        // reduce it to a 2D value
        let world_pos: Vec2 = world_pos.truncate();

        eprintln!(&quot;World coords: {}/{}&quot;, world_pos.x, world_pos.y);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-camera-projection"><a class="header" href="#custom-camera-projection">Custom Camera Projection</a></h1>
<p><a href="cookbook//code/examples/custom-projection.rs">Click here for the full example code.</a></p>
<hr />
<p>Camera with a custom projection (not using one of Bevy's standard perspective
or orthographic projections).</p>
<p>You could also use this to change the coordinate system, if you insist on
using something other than <a href="cookbook//features/coords.html">Bevy's default coordinate system</a>,
for whatever reason.</p>
<p>Here we implement a simple orthographic projection that maps <code>-1.0</code> to <code>1.0</code>
to the vertical axis of the window, and respects the window's aspect ratio
for the horizontal axis:</p>
<p>See how Bevy constructs its camera bundles, for reference:
<a href="https://docs.rs/bevy_render/0.7.0/src/bevy_render/camera/bundle.rs.html#73-167">orthographic</a>,
<a href="https://docs.rs/bevy_render/0.7.0/src/bevy_render/camera/bundle.rs.html#21-71">perspective</a>.</p>
<p>This example is based on the setup for a 2D camera:</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::primitives::Frustum;
use bevy::render::camera::{Camera, Camera2d, CameraProjection, DepthCalculation};
use bevy::render::view::VisibleEntities;

#[derive(Component)]
struct SimpleOrthoProjection {
    near: f32,
    far: f32,
    aspect: f32,
}

impl CameraProjection for SimpleOrthoProjection {
    fn get_projection_matrix(&amp;self) -&gt; Mat4 {
        Mat4::orthographic_rh(
            -self.aspect, self.aspect, -1.0, 1.0, self.near, self.far
        )
    }

    // what to do on window resize
    fn update(&amp;mut self, width: f32, height: f32) {
        self.aspect = width / height;
    }

    fn depth_calculation(&amp;self) -&gt; DepthCalculation {
        // for 2D (camera doesn't rotate)
        DepthCalculation::ZDifference

        // otherwise
        //DepthCalculation::Distance
    }

    fn far(&amp;self) -&gt; f32 {
        self.far
    }
}

impl Default for SimpleOrthoProjection {
    fn default() -&gt; Self {
        Self { near: 0.0, far: 1000.0, aspect: 1.0 }
    }
}

fn setup(mut commands: Commands) {
    // We need all the components that Bevy's built-in camera bundles would add

    let projection = SimpleOrthoProjection::default();
    let camera = Camera {
        near: projection.near,
        far: projection.far,
        ..default()
    };
    // position the camera like bevy would do by default for 2D:
    let transform = Transform::from_xyz(0.0, 0.0, projection.far - 0.1);
    // frustum construction code copied from Bevy
    let view_projection =
        projection.get_projection_matrix() * transform.compute_matrix().inverse();
    let frustum = Frustum::from_view_projection(
        &amp;view_projection,
        &amp;transform.translation,
        &amp;transform.back(),
        projection.far,
    );

    commands.spawn_bundle((
        camera,
        projection,
        frustum,
        VisibleEntities::default(),
        transform,
        GlobalTransform::default(),
        Camera2d,
    ));
}

fn main() {
    // need to add a bevy-internal camera system to update
    // the projection on window resizing

    use bevy::render::camera::camera_system;

    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup)
        .add_system_to_stage(
            CoreStage::PostUpdate,
            camera_system::&lt;SimpleOrthoProjection&gt;,
        )
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pan--orbit-camera"><a class="header" href="#pan--orbit-camera">Pan + Orbit Camera</a></h1>
<p><a href="cookbook//code/examples/pan-orbit-camera.rs">Click here for the full example code.</a></p>
<hr />
<p>This code is a community contribution.</p>
<p>Current version developed by <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/pull/1"><strong>@mirenbharta</strong></a>.
Initial work by <a href="https://github.com/bevy-cheatbook/bevy-cookbook/pull/2"><strong>@skairunner</strong></a>.</p>
<hr />
<p>This is a camera controller similar to the ones in 3D editors like Blender.</p>
<p>Use the right mouse button to rotate, middle button to pan, scroll wheel to
move inwards/outwards.</p>
<p>This is largely shown for illustrative purposes, as an example
to learn from. In your projects, you may want to try the
<a href="https://github.com/BlackPhlox/bevy_config_cam"><code>bevy_config_cam</code></a> plugin.</p>
<pre><code class="language-rust no_run noplayground">/// Tags an entity as capable of panning and orbiting.
#[derive(Component)]
struct PanOrbitCamera {
    /// The &quot;focus point&quot; to orbit around. It is automatically updated when panning the camera
    pub focus: Vec3,
    pub radius: f32,
    pub upside_down: bool,
}

impl Default for PanOrbitCamera {
    fn default() -&gt; Self {
        PanOrbitCamera {
            focus: Vec3::ZERO,
            radius: 5.0,
            upside_down: false,
        }
    }
}

/// Pan the camera with middle mouse click, zoom with scroll wheel, orbit with right mouse click.
fn pan_orbit_camera(
    windows: Res&lt;Windows&gt;,
    mut ev_motion: EventReader&lt;MouseMotion&gt;,
    mut ev_scroll: EventReader&lt;MouseWheel&gt;,
    input_mouse: Res&lt;Input&lt;MouseButton&gt;&gt;,
    mut query: Query&lt;(&amp;mut PanOrbitCamera, &amp;mut Transform, &amp;PerspectiveProjection)&gt;,
) {
    // change input mapping for orbit and panning here
    let orbit_button = MouseButton::Right;
    let pan_button = MouseButton::Middle;

    let mut pan = Vec2::ZERO;
    let mut rotation_move = Vec2::ZERO;
    let mut scroll = 0.0;
    let mut orbit_button_changed = false;

    if input_mouse.pressed(orbit_button) {
        for ev in ev_motion.iter() {
            rotation_move += ev.delta;
        }
    } else if input_mouse.pressed(pan_button) {
        // Pan only if we're not rotating at the moment
        for ev in ev_motion.iter() {
            pan += ev.delta;
        }
    }
    for ev in ev_scroll.iter() {
        scroll += ev.y;
    }
    if input_mouse.just_released(orbit_button) || input_mouse.just_pressed(orbit_button) {
        orbit_button_changed = true;
    }

    for (mut pan_orbit, mut transform, projection) in query.iter_mut() {
        if orbit_button_changed {
            // only check for upside down when orbiting started or ended this frame
            // if the camera is &quot;upside&quot; down, panning horizontally would be inverted, so invert the input to make it correct
            let up = transform.rotation * Vec3::Y;
            pan_orbit.upside_down = up.y &lt;= 0.0;
        }

        let mut any = false;
        if rotation_move.length_squared() &gt; 0.0 {
            any = true;
            let window = get_primary_window_size(&amp;windows);
            let delta_x = {
                let delta = rotation_move.x / window.x * std::f32::consts::PI * 2.0;
                if pan_orbit.upside_down { -delta } else { delta }
            };
            let delta_y = rotation_move.y / window.y * std::f32::consts::PI;
            let yaw = Quat::from_rotation_y(-delta_x);
            let pitch = Quat::from_rotation_x(-delta_y);
            transform.rotation = yaw * transform.rotation; // rotate around global y axis
            transform.rotation = transform.rotation * pitch; // rotate around local x axis
        } else if pan.length_squared() &gt; 0.0 {
            any = true;
            // make panning distance independent of resolution and FOV,
            let window = get_primary_window_size(&amp;windows);
            pan *= Vec2::new(projection.fov * projection.aspect_ratio, projection.fov) / window;
            // translate by local axes
            let right = transform.rotation * Vec3::X * -pan.x;
            let up = transform.rotation * Vec3::Y * pan.y;
            // make panning proportional to distance away from focus point
            let translation = (right + up) * pan_orbit.radius;
            pan_orbit.focus += translation;
        } else if scroll.abs() &gt; 0.0 {
            any = true;
            pan_orbit.radius -= scroll * pan_orbit.radius * 0.2;
            // dont allow zoom to reach zero or you get stuck
            pan_orbit.radius = f32::max(pan_orbit.radius, 0.05);
        }

        if any {
            // emulating parent/child to make the yaw/y-axis rotation behave like a turntable
            // parent = x and y rotation
            // child = z-offset
            let rot_matrix = Mat3::from_quat(transform.rotation);
            transform.translation = pan_orbit.focus + rot_matrix.mul_vec3(Vec3::new(0.0, 0.0, pan_orbit.radius));
        }
    }
}

fn get_primary_window_size(windows: &amp;Res&lt;Windows&gt;) -&gt; Vec2 {
    let window = windows.get_primary().unwrap();
    let window = Vec2::new(window.width() as f32, window.height() as f32);
    window
}

/// Spawn a camera like this
fn spawn_camera(mut commands: Commands) {
    let translation = Vec3::new(-2.0, 2.5, 5.0);
    let radius = translation.length();

    commands.spawn_bundle(PerspectiveCameraBundle {
        transform: Transform::from_translation(translation)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..Default::default()
    }).insert(PanOrbitCamera {
        radius,
        ..Default::default()
    });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-all-resource-types"><a class="header" href="#list-all-resource-types">List All Resource Types</a></h1>
<p><a href="cookbook//code/examples/print-resources.rs">Click here for the full example code.</a></p>
<hr />
<p>This example shows how to print a list of all types that have been added as
<a href="cookbook//programming/res.html">resources</a>.</p>
<pre><code class="language-rust no_run noplayground">fn print_resources(archetypes: &amp;Archetypes, components: &amp;Components) {
    let mut r: Vec&lt;String&gt; = archetypes
        .resource()
        .components()
        .map(|id| components.get_info(id).unwrap())
        // get_short_name removes the path information
        // i.e. `bevy_audio::audio::Audio` -&gt; `Audio`
        // if you want to see the path info replace
        // `TypeRegistration::get_short_name` with `String::from`
        .map(|info| TypeRegistration::get_short_name(info.name()))
        .collect();

    // sort list alphebetically
    r.sort();
    r.iter().for_each(|name| println!(&quot;{}&quot;, name));
}
</code></pre>
<p>Note that this does <em>not</em> give you a comprehensive list of every Bevy-provided
type that is useful as a resource. It lists the types of all the resources
<em>currently added</em> to the app (by all registered plugins, your own, etc.).</p>
<p><a href="cookbook//builtins.html">See here for a more useful list types provided in Bevy.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-on-different-platforms"><a class="header" href="#bevy-on-different-platforms">Bevy on Different Platforms</a></h1>
<p>This chapter is a collection of platform-specific information, about using
Bevy with different operating systems or environments.</p>
<p>Feel free to suggest things to add.</p>
<hr />
<p>Bevy trivially works out-of-the-box on the major desktop operating systems:
Linux, macOS, Windows. No special configuration is required.</p>
<p>See the following pages for specific tips/advice when developing for the
desktop platforms:</p>
<ul>
<li><a href="/platforms/linux.html">Linux</a></li>
<li><a href="/platforms/macos.html">macOS</a></li>
<li><a href="/platforms/windows.html">Windows</a></li>
</ul>
<p>Bevy aims to also make it easy to target other platforms, such as web browsers
(via WebAssembly), mobile (Android and iOS), and game consoles. Your Bevy
code can be the same for all platforms, with differences only in the build
process and environment setup.</p>
<p>However, that vision is not fully met yet. Currently, support for non-desktop
platforms is limited, and requires more complex configuration:</p>
<ul>
<li><a href="/platforms/wasm.html">Web Browsers</a>: Bevy works quite well on web, but with some limitations.</li>
<li>Mobile: support is minimal and broken. It will build, but may or may not run.
Expect to immediately encounter major issues.</li>
<li>Game consoles: support is still completely non-existent yet.</li>
</ul>
<p>If you are interested in these other platforms and you'd like to help improve
Bevy's cross-platform support, your contributions would be greatly welcomed!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-desktop"><a class="header" href="#linux-desktop">Linux Desktop</a></h1>
<p>If you have any additional Linux-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Desktop Linux is one of the best-supported platforms by Bevy.</p>
<p>There are some development dependencies you may need to setup, depending on your
distribution. <a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">See instructions in official Bevy repo.</a></p>
<p><a href="platforms//setup/cross/linux-windows.html">See here if you also want to build Windows EXEs from Linux</a>.</p>
<h2 id="gpu-drivers"><a class="header" href="#gpu-drivers">GPU Drivers</a></h2>
<p>Support for the Vulkan graphics API is required to run Bevy apps. You (and your
users) must ensure that you have compatible hardware and drivers installed.</p>
<p>On most modern distributions and computers, this should be no problem.</p>
<p>If Bevy apps refuse to run and print an error to the console about not being
able to find a compatible GPU, the problem is most likely with the Vulkan
components of your graphics driver not being installed correctly. You may
need to install some extra packages or reinstall your graphics drivers. Check
with your Linux distribution for what to do.</p>
<h2 id="x11-and-wayland"><a class="header" href="#x11-and-wayland">X11 and Wayland</a></h2>
<p>As of the year 2021, the Linux desktop ecosystem is fragmented between
the legacy X11 stack and the modern Wayland stack. Many distributions are
switching to Wayland-based desktop environments by default.</p>
<p>Bevy supports both, but only X11 support is enabled by default. If you are
running a Wayland-based desktop, this means your Bevy app will run in the
XWayland compatibility layer.</p>
<p>To enable native Wayland support for Bevy, enable the <code>wayland</code> cargo feature:</p>
<pre><code class="language-toml">[dependencies]
bevy = { version = &quot;0.7&quot;, features = [&quot;wayland&quot;] }
</code></pre>
<p>Now your app will be built with support for both X11 and Wayland.</p>
<p>If you want to remove X11 support for whatever reason, disable the <code>x11</code>
cargo default feature.</p>
<p>You can override which display protocol to use at runtime, using an
environment variable:</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=x11
</code></pre>
<p>(to run using X11/XWayland on a Wayland desktop)</p>
<p>or</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=wayland
</code></pre>
<p>(to require the use of Wayland)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos-desktop"><a class="header" href="#macos-desktop">macOS Desktop</a></h1>
<p>If you have any additional macOS-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>(this page is currently empty; please help!)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-desktop"><a class="header" href="#windows-desktop">Windows Desktop</a></h1>
<p>If you have any additional Windows-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Windows is one of the best-supported platforms by Bevy.</p>
<p>Both the MSVC and the GNU compiler toolchains should work.</p>
<p><a href="platforms//setup/cross/linux-windows.html">You can also build Windows EXEs while working in Linux</a>.</p>
<h2 id="distributing-your-app"><a class="header" href="#distributing-your-app">Distributing Your App</a></h2>
<p>The EXE built with <code>cargo build</code> can work standalone without any extra files or DLLs.</p>
<p>Your <code>assets</code> folder needs be distributed alongside it. Bevy will search for it in
the same directory as the EXE on the user's computer.</p>
<p>The easiest way to give your game to other people to play is to put them
together in a ZIP file. If you use some other method of installation,
install the <code>assets</code> folder and the EXE to the same path.</p>
<h2 id="disabling-the-windows-console"><a class="header" href="#disabling-the-windows-console">Disabling the Windows Console</a></h2>
<p>By default, when you run a Bevy app (or any Rust program for that matter)
on Windows, a Console window also shows up. To disable this,
place this Rust attribute at the top of your <code>main.rs</code>:</p>
<pre><code class="language-rust no_run noplayground">#![windows_subsystem = &quot;windows&quot;)]
</code></pre>
<p>This tells Windows that your executable is a graphical application, not a
command-line program. Windows will know not display a console.</p>
<p>However, the console can be useful for development, to see log messages.
You can disable it only for release builds, and leave it enabled in debug
builds, like this:</p>
<pre><code class="language-rust no_run noplayground">#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]
</code></pre>
<h2 id="creating-an-icon-for-your-app"><a class="header" href="#creating-an-icon-for-your-app">Creating an icon for your app</a></h2>
<p>There are two places where you might want to put your application icon:</p>
<ul>
<li>The EXE file (how it looks in the file explorer)</li>
<li>The window at runtime (how it looks in the taskbar and the window title bar)</li>
</ul>
<h3 id="setting-the-exe-icon"><a class="header" href="#setting-the-exe-icon">Setting the EXE icon</a></h3>
<p>(adapted from <a href="https://github.com/NiklasEi/bevy_game_template">here</a>)</p>
<p>The EXE icon can be set using a cargo build script.</p>
<p>Add a build dependency of <code>embed_resources</code> to your <code>Cargo.toml</code> allow embedding assets into your compiled executables</p>
<pre><code class="language-toml">[build-dependencies]
embed-resource = &quot;1.6.3&quot;
</code></pre>
<p>Create a <code>build.rs</code> file in your project folder:</p>
<pre><code class="language-rust no_run noplayground">extern crate embed_resource;

fn main() {
    let target = std::env::var(&quot;TARGET&quot;).unwrap();
    if target.contains(&quot;windows&quot;) {
        embed_resource::compile(&quot;icon.rc&quot;);
    }
}
</code></pre>
<p>Create a <code>icon.rc</code> file in your project folder:</p>
<pre><code>app_icon ICON &quot;icon.ico&quot;
</code></pre>
<p>Create your icon as <code>icon.ico</code> in your project folder.</p>
<h3 id="setting-the-window-icon-1"><a class="header" href="#setting-the-window-icon-1">Setting the Window Icon</a></h3>
<p>See <a href="platforms//window/icon.html">Bevy Cookbook: Setting the Window Icon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h1>
<p>This sub-chapter covers how to make builds of your Bevy apps to run on a
different Operating System than the one you are working on.</p>
<ul>
<li><a href="setup//setup/cross/linux-windows.html">Create Windows EXEs from Linux</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-windows-exes-from-linux"><a class="header" href="#build-windows-exes-from-linux">Build Windows EXEs from Linux</a></h1>
<p>(also check out the <a href="setup/cross//platforms/windows.html">Windows Platform page</a> for info
about developing for Windows generally)</p>
<hr />
<p>Rust offers two different toolchains for building for Windows:</p>
<ul>
<li><a href="setup/cross/linux-windows.html#first-time-setup-msvc">MSVC</a>: the default when working in Windows, requires downloading Microsoft SDKs</li>
<li><a href="setup/cross/linux-windows.html#first-time-setup-gnu">GNU</a>: alternative MINGW-based build, may be easier to setup</li>
</ul>
<h2 id="first-time-setup-msvc"><a class="header" href="#first-time-setup-msvc">First-Time Setup (MSVC)</a></h2>
<h3 id="rust-toolchain-msvc"><a class="header" href="#rust-toolchain-msvc">Rust Toolchain (MSVC)</a></h3>
<p>You can actually use the same MSVC-based Rust toolchain, that is the standard
when working on Windows, from Linux.</p>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-msvc
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="microsoft-windows-sdks"><a class="header" href="#microsoft-windows-sdks">Microsoft Windows SDKs</a></h3>
<p>You need to install the Microsoft Windows SDKs, just like when working on
Windows. On Linux, this can be done with an easy script called <code>xwin</code>. You
need to accept Microsoft's proprietary license.</p>
<p>Install <code>xwin</code>:</p>
<pre><code class="language-sh">cargo install xwin
</code></pre>
<p>Now, use <code>xwin</code> to accept the Microsoft license, download all the files
from Microsoft servers, and install them to a directory of your choosing.</p>
<p>For example, to install to <code>/opt/xwin/</code>:</p>
<pre><code class="language-sh">xwin --accept-license 1 splat --output /opt/xwin
</code></pre>
<h3 id="linking-msvc"><a class="header" href="#linking-msvc">Linking (MSVC)</a></h3>
<p>Rust needs to know how to link the final EXE file.</p>
<p>The default Microsoft linker (<code>link.exe</code>) is not available on Linux. Instead,
we need to use the LLD linker (this is also recommended when working on
Windows anyway). Just install the <code>lld</code> package from your Linux distro.</p>
<p>We also need to tell Rust the location of the Microsoft Windows SDK libraries
(that were installed with <code>xwin</code> in <a href="setup/cross/linux-windows.html#microsoft-windows-sdks">the previous step</a>).</p>
<p>Add this to <code>.cargo/config.toml</code> (in your home folder or in your bevy project):</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = &quot;lld&quot;
rustflags = [
  &quot;-Lnative=/opt/xwin/crt/lib/x86_64&quot;,
  &quot;-Lnative=/opt/xwin/sdk/lib/um/x86_64&quot;,
  &quot;-Lnative=/opt/xwin/sdk/lib/ucrt/x86_64&quot;
]
</code></pre>
<h2 id="first-time-setup-gnu"><a class="header" href="#first-time-setup-gnu">First-Time Setup (GNU)</a></h2>
<h3 id="rust-toolchain-gnu"><a class="header" href="#rust-toolchain-gnu">Rust Toolchain (GNU)</a></h3>
<p>You can also use the alternative GNU-based Windows toolchain.</p>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="mingw"><a class="header" href="#mingw">MINGW</a></h3>
<p>The GNU toolchain requires the MINGW environment to be installed. Your distro likely
provides a package for it. Search your distro for a cross-compilation mingw package.</p>
<p>It might be called something like: <code>cross-x86_64-w64-mingw32</code>, but that varies in different distros.</p>
<p>You don't need any files from Microsoft.</p>
<h2 id="building-your-project"><a class="header" href="#building-your-project">Building Your Project</a></h2>
<p>Finally, with all the setup done, you can just build your Rust/Bevy projects
for Windows:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-gnu --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browser-webassembly"><a class="header" href="#browser-webassembly">Browser (WebAssembly)</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>You can make web browser games using Bevy. This chapter will help you with
the things you need to know to do it. This page gives an overview of Bevy's
Web support.</p>
<p>Your Bevy app will be compiled for WebAssembly (WASM), which allows it to
be embedded in a web page and run inside the browser.</p>
<p>Performance will be limited, as WebAssembly is slower than native code and
does not currently support multithreading.</p>
<p>Not all 3rd-party plugins are compatible. If you need extra unofficial plugins,
you will have to check if they are compatible with WASM.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The same Bevy project, without any special code modifications, can be built
for either web or desktop/native.</p>
<p>However, you will need a &quot;website&quot; with some HTML and JavaScript to load and
run your game. For development and testing, this could be just a minimal shim.
It can be easily autogenerated.</p>
<p>To deploy, you will need a server to host your website for other
people to access. You could use GitHub's hosting service: <a href="platforms//platforms/wasm/gh-pages.html">GitHub
Pages</a>.</p>
<h2 id="additional-caveats"><a class="header" href="#additional-caveats">Additional Caveats</a></h2>
<p>When users load your site to play your game, their browser will need to
download the files. <a href="platforms//platforms/wasm/size-opt.html">Optimizing for size</a> is important,
so that your game can load fast and not waste data bandwidth.</p>
<p>Some minor extra configuration is needed to be able to:</p>
<ul>
<li><a href="platforms//platforms/wasm/panic-console.html">See Rust panic messages</a></li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>First, add WASM support to your Rust installation. Using Rustup:</p>
<pre><code class="language-sh">rustup target install wasm32-unknown-unknown
</code></pre>
<p>Now, to run your Bevy project in the browser.</p>
<h3 id="wasm-server-runner"><a class="header" href="#wasm-server-runner"><code>wasm-server-runner</code></a></h3>
<p>The easiest and most automatic way to get started is the
<a href="https://github.com/jakobhellermann/wasm-server-runner"><code>wasm-server-runner</code></a> tool.</p>
<p>Install it:</p>
<pre><code class="language-sh">cargo install wasm-server-runner
</code></pre>
<p>Set up <code>cargo</code> to use it, in <code>.cargo/config.toml</code> (in your project folder,
or globally in your user home folder):</p>
<pre><code class="language-toml">[target.wasm32-unknown-unknown]
runner = &quot;wasm-server-runner&quot;
</code></pre>
<p>Now you can just run your game with:</p>
<pre><code class="language-sh">cargo run --target wasm32-unknown-unknown
</code></pre>
<p>It will automatically run a minimal local webserver and open your game in your browser.</p>
<h3 id="wasm-bindgen"><a class="header" href="#wasm-bindgen"><code>wasm-bindgen</code></a></h3>
<p><code>wasm-bindgen</code> is the tool to generate all the files needed to put the game on your website.</p>
<p>Run:</p>
<pre><code class="language-sh">cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --out-dir ./out/ --target web ./target/
</code></pre>
<p><code>./out/</code> is the directory where it will place the output files.</p>
<p>You need to put these on your web server.</p>
<h3 id="higher-level-tools"><a class="header" href="#higher-level-tools">Higher-level Tools</a></h3>
<p>Here are some higher-level alternatives. These tools can do more for you
and automate more of your workflow, but are more opinionated in how they work.</p>
<ul>
<li><a href="https://trunkrs.dev">Trunk</a></li>
<li><a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-messages"><a class="header" href="#panic-messages">Panic Messages</a></h1>
<p>Unless we do something about it, you will not be able to see Rust panic
messages when running in a web browser. This means that, if your game crashes,
you will not know why.</p>
<p>To fix this, we can set up a panic hook that will cause
the messages to appear in the browser console, using the
<a href="https://github.com/rustwasm/console_error_panic_hook">console_error_panic_hook</a> crate.</p>
<p>Add the crate to your dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
console_error_panic_hook = &quot;0.1&quot;
</code></pre>
<p>At the start of your main function, before doing anything else, add this:</p>
<pre><code class="language-rust no_run noplayground">    // When building for WASM, print panics to the browser console
    #[cfg(target_arch = &quot;wasm32&quot;)]
    console_error_panic_hook::set_once();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimize-for-size"><a class="header" href="#optimize-for-size">Optimize for Size</a></h1>
<p>When serving a WASM binary, the smaller it is, the faster the browser can
download it. Faster downloads means faster page load times and less data
bandwidth use, and that means happier users.</p>
<p>This page gives some suggestions for how to make your WASM files smaller.</p>
<p><em>Do not prematurely optimize!</em> You probably don't need small WASM files during
development, and many of these techniques can get in the way of your workflow!
They may come at the cost of longer compile times or less debuggability.</p>
<p>Depending on the nature of your application, your mileage may vary, and
performing measurements of binary size and execution speed is recommended.</p>
<p><a href="https://github.com/rustwasm/twiggy">Twiggy</a> is a code size profiler for WASM binaries, which
you can use to make measurements.</p>
<p>For additional information and more techniques, refer to the Code Size
chapter in the <a href="https://rustwasm.github.io/docs/book/reference/code-size.html">Rust WASM book</a>.</p>
<h2 id="compiling-for-size-instead-of-speed"><a class="header" href="#compiling-for-size-instead-of-speed">Compiling for size instead of speed</a></h2>
<p>You can change the optimization profile of the compiler, to tell it to
prioritize small output size, rather than performance.</p>
<p>(although in some rare cases, optimizing for size can actually improve speed)</p>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>These are two different profiles for size optimization. Usually, <code>z</code> produces
smaller files than <code>s</code>, but sometimes it can be the opposite. Measure to
confirm which one works better for you.</p>
<h2 id="link-time-optimization-lto"><a class="header" href="#link-time-optimization-lto">Link-Time Optimization (LTO)</a></h2>
<p>In <code>Cargo.toml</code>, add the following:</p>
<pre><code class="language-toml">[profile.release]
lto = &quot;thin&quot;
</code></pre>
<p>LTO tells the compiler to optimize all code together, considering all
crates as if they were one. It may be able to inline and prune functions
much more aggressively.</p>
<p>This typically results in smaller size <em>and</em> better performance, but do
measure to confirm. Sometimes, the size can actually be larger.</p>
<p>The downside here is that compilation will take much longer. Do this only
for release builds you publish for other users.</p>
<h2 id="use-the-wasm-opt-tool"><a class="header" href="#use-the-wasm-opt-tool">Use the <code>wasm-opt</code> tool</a></h2>
<p>The <a href="https://github.com/WebAssembly/binaryen">binaryen</a> toolkit is a set of extra tools for working
with WASM. One of them is <code>wasm-opt</code>. It goes much further than what the
compiler can do, and can be used to further optimize for either speed or size:</p>
<pre><code class="language-shell"># Optimize for size (s profile).
wasm-opt -Os -o output.wasm input.wasm

# Optimize for size (z profile).
wasm-opt -Oz -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm

# Optimize aggressively for both size and speed.
wasm-opt -O -ol 100 -s 100 -o output.wasm input.wasm
</code></pre>
<hr />
<p>Do you know of more WASM size-optimization techniques? Post about them in the
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub Issue Tracker</a> so that they can be added to this page!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hosting-on-github-pages"><a class="header" href="#hosting-on-github-pages">Hosting on GitHub Pages</a></h1>
<p>GitHub Pages is a hosting service that allows you to publish your website
on GitHub's servers.</p>
<p>For more details, visit the official <a href="https://docs.github.com/en/pages">GitHub Pages
documentation</a>.</p>
<p>Deploying a website (like your WASM game) to GitHub pages is done by
putting the files in a special branch in a GitHub repository. You could
create a separate repository for this, but you could also do it from the
same repository as your source code.</p>
<p>You will need the final website files for deployment.</p>
<hr />
<p>Create an empty branch in your git repository:</p>
<pre><code class="language-shell">git checkout --orphan web
git reset --hard
</code></pre>
<p>You should now be in an empty working directory.</p>
<p>Put all files necessary for hosting, including your HTML, WASM, JavaScript,
and <code>assets</code> files, and commit them into git:</p>
<pre><code class="language-shell">git add *
git commit
</code></pre>
<p>(or better, manually list your files in the above command, in place of the <code>*</code> wildcard)</p>
<p>Push your new branch to GitHub:</p>
<pre><code class="language-shell">git push -u origin web --force
</code></pre>
<p>In the GitHub Web UI, go to the repository settings, go to the &quot;GitHub Pages&quot;
section, then under &quot;Source&quot; pick the branch &quot;web&quot; and the <code>/</code> (root) folder.
Then click &quot;Save&quot;.</p>
<p>Wait a little bit, and your site should become available at
<code>https://your-name.github.io/your-repo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aŭtoroj"><a class="header" href="#aŭtoroj">Aŭtoroj</a></h1>
<p>Aŭtoroj de <strong>Unofficial Bevy Cheatbook</strong>:</p>
<hr />
<ul>
<li>Ida Iyes <code>@inodentry</code>: la ĉefa aŭtoro</li>
<li>Alice I. Cecile <code>@alice-i-cecile</code>: review, advice, reporting lots of good suggestions</li>
<li>nile <code>@TheRawMeatball</code>: review, useful issue reports</li>
<li><code>@Zaszi</code>: writing the initial draft of the WASM chapter</li>
<li><code>@skairunner</code> and <code>@mirenbharta</code>: developing the Pan+Orbit camera example</li>
<li><code>@billyb2</code>: the Fixed Timestep example</li>
</ul>
<hr />
<p>Teamo de <strong>Bevy Tromplibro Esperanto Traduko</strong>:</p>
<hr />
<ul>
<li>linuksulo <code>@andezitgq</code>: la tradukanto-ideulo</li>
</ul>
<hr />
<p>La plej grandan dankon al <a href="https://github.com/bevyengine/bevy">Projekto Bevy</a> mem kaj al ĝia fondinto <code>@cart</code> por kreado de ĉi tiu mirinda komunumo kaj ludmotoro unue! Ĝi ebligis ĉion ĉi tion. Vi vere ŝanĝis nian vivon! ❤️</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kontakti-kun-la-aŭtoro"><a class="header" href="#kontakti-kun-la-aŭtoro">Kontakti kun la aŭtoro</a></h1>
<p>Vi povas trovi <code>@inodentry</code> en sekvaj lokoj:</p>
<ul>
<li>Discord: <code>Ida Iyes#0981</code></li>
<li>Twitter: <a href="https://twitter.com/IyesGames"><code>@IyesGames</code></a></li>
<li>GitHub: <a href="https://github.com/inodentry"><code>@inodentry</code></a></li>
<li>Reddit: <a href="https://reddit.com/u/iyesgames"><code>iyesgames</code></a></li>
</ul>
<p>Por plibonigoj aŭ korektoj al ĉi tiu libro, bonvolu registri problemon <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kontribuado-al-bevy"><a class="header" href="#kontribuado-al-bevy">Kontribuado al Bevy</a></h1>
<p>Se vi volas helpi la projekton Bevy Game Engine, rigardu la <a href="https://github.com/bevyengine/bevy/blob/main/CONTRIBUTING.md">oficialan kontribuadan gvidilon</a> de Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kontribuado"><a class="header" href="#kontribuado">Kontribuado</a></h1>
<p>Estu ĝentila. Se vi bezonas kondutkodon, rigardu tiun de Bevy.</p>
<p>Se vi havas sugestojn por la libro, kiel ideojn por nova enhavo, aŭ se vi rimarkas ion malĝustan aŭ misgvida, bonvolu registri problemojn en la <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">deponejo de GitHub</a>!</p>
<h2 id="kod-kontribuado"><a class="header" href="#kod-kontribuado">Kod-kontribuado</a></h2>
<p>Se vi simple volas kontribui kodekzemplojn al la libro, ne timi fari memreklamon! Mi povas zorgi pri skribo de la libroteksto / paĝo, en kiu via kodo
estos montrata.</p>
<h3 id="kuirlibraj-ekzemploj"><a class="header" href="#kuirlibraj-ekzemploj">Kuirlibraj Ekzemploj</a></h3>
<p>La kodo por kuirlibraj ekzemploj devas esti provizita kiel plena, lanĉebla ekzempla dosiero en <code>src/code/examples</code> vojo. La libropaĝo nur montros la konvenajn partojn de la kodo sen malnecesa kaldrono.</p>
<p>Always use <a href="https://rust-lang.github.io/mdBook/format/mdbook.html#including-portions-of-a-file">mdbook anchor syntax</a>, not line numbers,
to denote the parts of the code to be shown on the page.</p>
<p>Ĉiam uzu <a href="https://rust-lang.github.io/mdBook/format/mdbook.html#including-portions-of-a-file">mdbook ankro-sintakson</a></p>
<h3 id="aŭtor-mencioj"><a class="header" href="#aŭtor-mencioj">Aŭtor-mencioj</a></h3>
<p>Se vi kontribuos ekzemplon por <a href="https://bevy-cheatbook.github.io/cookbook.html">Originala Kuirlibro</a>, la aŭtoro mencios vin en la libro per via GitHub-uzantnomo kaj la ligilo.</p>
<h2 id="kontribuado-al-libroteksto"><a class="header" href="#kontribuado-al-libroteksto">Kontribuado al Libroteksto</a></h2>
<p>La aŭtoro ne kunigas direkte la librotekston, verkitan de aliaj homoj. Ĉi tio estas ĉar mi deziras konservi certan redaktistan stilon.</p>
<p>Se vi dezirus verki novan enhavon por la libro, ne timu fari reklamon kun la inkludita enhavo, sed notu, ke ĝi verŝajne ne estos konservita samkiel vi skribis ĝin.</p>
<h2 id="licencado"><a class="header" href="#licencado">Licencado</a></h2>
<p>Por eviti komplikaĵojn kun kopirajto kaj licencado, vi konsentas provizi ajnajn kontribuojn, kiujn vi faras al la projekto per la <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 Malatribua Permesilo</a>.</p>
<p>Atentu, ke ĝi rajtigas ne konservi kopirajton de via laboro dum relicencado.</p>
<p>Kiel estis priskribita antaŭe, la reala publikigita enhavo en la libro estas propra derivita laboro de la libraŭtoro, bazita sur viaj kontribuoj. Vd. la <a href="./introduction.html#permesilo">licencon</a>.</p>
<h2 id="bevy-versio"><a class="header" href="#bevy-versio">Bevy versio</a></h2>
<p>Enhavo, verkita por la nuna eldono de Bevy, estas akceptita por la <code>main</code> branĉo de la originala libro.</p>
<p>Enhavo, verkita por novaj disvolvaĵoj en la ĉefa branĉo de Bevy, estas akceptita por la <code>next</code> branĉo de la originala libro, en preparo por la venonta Bevy-eldono.</p>
<h2 id="stil-gvidaĵo"><a class="header" href="#stil-gvidaĵo">Stil-gvidaĵo</a></h2>
<ul>
<li>
<p>Celu simplecon kaj minimumismon. Ne skribu pri maloportunaj kaj senrilataj aferoj.</p>
</li>
<li>
<p>Perfekteco estas atingita ne kiam estas nenio por aldoni, sed kiam estas nenio por forigi.</p>
</li>
<li>
<p>Ne forgesu indiki potencialajn erarojn kaj aliajn gravajn praktikajn konsiderojn.</p>
</li>
<li>
<p>Penu uzi la plej ofte uzantajn terminologion kaj ĉefvortojn por igi aferojn facile troveblaj. Ne elpensu novan/kroman terminologion mem.
it instead.</p>
</li>
<li>
<p>Evitu ripetadon de informoj, trovitaj aliloke en la libro, anstataŭe provizu ligon al ĝi.</p>
</li>
</ul>
<h3 id="koda-stilo"><a class="header" href="#koda-stilo">Koda stilo</a></h3>
<p>Evitu longajn liniojn de kodo por legebligi ĝin en malgrandaj ekranoj.</p>
<p>Uzu prudentan formatadon, kiu ne multe distingiĝas de la ĝenerale akceptitaj konvencioj, uzataj de la Rustlingva komunumo. Sed ne estas necese uzi na <code>rustfmt</code>. Se devio de ĉi tiuj normoj permesas pli bone prezenti la kodon en la kunteksto de la libro, tiam tio estas preferinda.</p>
<h3 id="teksta-stilo"><a class="header" href="#teksta-stilo">Teksta stilo</a></h3>
<p>Farigu ĝin facila por legado:</p>
<ul>
<li>Estu lakona. Provu kovri ĉiujn gravajn informojn sen detalaj klarigoj.</li>
<li>Preferu simplan lingvon kun mallongaj frazoj.</li>
<li>Evitu informan troŝarĝon:
<ul>
<li>Dividu aferojn en mallongajn alineojn.</li>
<li>Evitu diskuti multajn (eĉ rilatajn) temojn samtempe.</li>
<li>Diskutu progresintan uzadon aparte de bazaĵoj.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="nagbar.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
